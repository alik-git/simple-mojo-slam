url:https://docs.modular.com/mojo/stdlib/algorithm/
package

algorithm





url:https://docs.modular.com/mojo/stdlib/algorithm/functional/
module

functional





url:https://docs.modular.com/mojo/stdlib/algorithm/functional/elementwise
function

elementwise

elementwise[func: fn[Int, Int](StaticIntTuple[$1]) capturing -> None, simd_width: Int, rank: Int](shape: StaticIntTuple[rank])

Executes func[width, rank](indices), possibly as sub-tasks, for a suitable combination of width and indices so as to cover shape. Returns when all sub-tasks have completed.

Parameters:

Args:

​func (fn[Int, Int](StaticIntTuple[$1]) capturing -> None): The body function.
​simd_width (Int): The SIMD vector width to use.
​rank (Int): The rank of the buffer.

​shape (StaticIntTuple[rank]): The shape of the buffer.





url:https://docs.modular.com/mojo/stdlib/algorithm/functional/map
function

map

map[func: fn(Int) capturing -> None](size: Int)

Maps a function over a range from 0 to size.

Parameters:

Args:

​func (fn(Int) capturing -> None): Function to map.

​size (Int): The number of elements.





url:https://docs.modular.com/mojo/stdlib/algorithm/functional/parallelize
function

parallelize

parallelize[func: fn(Int) capturing -> None]()

Executes func(0) ... func(N-1) as sub-tasks in parallel, and returns when all are complete. N is chosen to be the number of processors on the system.

Parameters:

​func (fn(Int) capturing -> None): The function to invoke.





url:https://docs.modular.com/mojo/stdlib/algorithm/functional/parallelize_over_rows
function

parallelize_over_rows

parallelize_over_rows[func: fn(Int, Int) capturing -> None](shape: StaticIntTuple[size], axis: Int, grain_size: Int)

Parallelize func over non-axis dims of shape.

Parameters:

Args:

​func (fn(Int, Int) capturing -> None): Function to call on range of rows.

​shape (StaticIntTuple[size]): Shape to parallelize over.
​axis (Int): Rows are slices along the axis dimension of shape.
​grain_size (Int): The minimum number of elements to warrant using an additional thread.





url:https://docs.modular.com/mojo/stdlib/algorithm/functional/stencil
function

stencil

stencil[rank: Int, stencil_rank: Int, stencil_axis: StaticIntTuple[$1], simd_width: Int, type: DType, map_fn: fn(StaticIntTuple[$1]) capturing -> Tuple[StaticIntTuple[$1], StaticIntTuple[$1]], map_strides: fn(dim: Int) capturing -> Int, load_fn: fn[Int, DType](StaticIntTuple[$0]) capturing -> SIMD[$1, $0], compute_init_fn: fn[Int]() capturing -> SIMD[$4, $0], compute_fn: fn[Int](StaticIntTuple[$0], SIMD[$4, $0], SIMD[$4, $0]) capturing -> SIMD[$4, $0], compute_finalize_fn: fn[Int](StaticIntTuple[$0], SIMD[$4, $0]) capturing -> None](shape: StaticIntTuple[rank], input_shape: StaticIntTuple[rank])

Computes stencil operation in parallel.

Computes output as a function that processes input stencils, stencils are
computed as a continuous region for each output point that is determined
by map_fn : map_fn(y) -> lower_bound, upper_bound. The boundary conditions
for regions that fail out of the input domain are handled by load_fn.

Parameters:

Args:

​rank (Int): Input and output domain rank.
​stencil_rank (Int): Rank of stencil subdomain slice.
​stencil_axis (StaticIntTuple[$1]): Stencil subdomain axes.
​simd_width (Int): The SIMD vector width to use.
​type (DType): The input and output data type.
​map_fn (fn(StaticIntTuple[$1]) capturing -> Tuple[StaticIntTuple[$1], StaticIntTuple[$1]]): A function that a point in the output domain to the input co-domain.
​map_strides (fn(dim: Int) capturing -> Int): A function that returns the stride for the dim.
​load_fn (fn[Int, DType](StaticIntTuple[$0]) capturing -> SIMD[$1, $0]): A function that loads a vector of simd_width from input.
​compute_init_fn (fn[Int]() capturing -> SIMD[$4, $0]): A function that initializes vector compute over the stencil.
​compute_fn (fn[Int](StaticIntTuple[$0], SIMD[$4, $0], SIMD[$4, $0]) capturing -> SIMD[$4, $0]): A function the process the value computed for each point in the stencil.
​compute_finalize_fn (fn[Int](StaticIntTuple[$0], SIMD[$4, $0]) capturing -> None): A function that finalizes the computation of a point in the output domain given a stencil.

​shape (StaticIntTuple[rank]): The shape of the output buffer.
​input_shape (StaticIntTuple[rank]): The shape of the input buffer.





url:https://docs.modular.com/mojo/stdlib/algorithm/functional/sync_parallelize
function

sync_parallelize

sync_parallelize[func: fn(Int) capturing -> None](num_work_items: Int)

Executes func(0) ... func(num_work_items-1) as parallel sub-tasks, and returns when all are complete.

Parameters:

Args:

​func (fn(Int) capturing -> None): The function to invoke.

​num_work_items (Int): Number of parallel tasks.





url:https://docs.modular.com/mojo/stdlib/algorithm/functional/tile
function

tile

tile[workgroup_function: fn[Int](Int) capturing -> None, tile_size_list: VariadicList[Int]](offset: Int, upperbound: Int)

A generator that launches work groups in specified list of tile sizes.

A workgroup function is a function that can process a configurable
consecutive "tile" of workload. E.g.
work_on[3](5)
should launch computation on item 5,6,7, and should be semantically
equivalent to
work_on[1](5), work_on[1](6), work_on[1](7).

This generator will try to proceed with the given list of tile sizes on the
listed order. E.g.
tile[func, (3,2,1)](offset, upperbound)
will try to call func[3] starting from offset until remaining work is less
than 3 from upperbound and then try func[2], and then func[1], etc.

Parameters:

Args:

​workgroup_function (fn[Int](Int) capturing -> None): Workgroup function that processes one tile of workload.
​tile_size_list (VariadicList[Int]): List of tile sizes to launch work.

​offset (Int): The initial index to start the work from.
​upperbound (Int): The runtime upperbound that the work function should not exceed.





url:https://docs.modular.com/mojo/stdlib/algorithm/functional/tile_and_unswitch
function

tile_and_unswitch

tile_and_unswitch[workgroup_function: fn[Int, Bool](Int, Int) capturing -> None, tile_size_list: VariadicList[Int]](offset: Int, upperbound: Int)

Performs time and unswitch functional transformation.

A variant of static tile given a workgroup function that can be unswitched.
This generator is a fused version of tile and unswitch, where the static
unswitch is true throughout the "inner" portion of the workload and is
false only on the residue tile.

Parameters:

Args:

​workgroup_function (fn[Int, Bool](Int, Int) capturing -> None): Workgroup function that processes one tile of workload.
​tile_size_list (VariadicList[Int]): List of tile sizes to launch work.

​offset (Int): The initial index to start the work from.
​upperbound (Int): The runtime upperbound that the work function should not exceed.





url:https://docs.modular.com/mojo/stdlib/algorithm/functional/tile_middle_unswitch_boundaries
function

tile_middle_unswitch_boundaries

tile_middle_unswitch_boundaries[work_fn: fn[Int, Bool](Int) capturing -> None, middle_tile_sizes: VariadicList[Int], left_tile_size: Int = 1, right_tile_size: Int = 1](left_boundary_start: Int, left_boundary_end: Int, right_boundary_start: Int, right_boundary_end: Int)

Divides 1d iteration space into three parts and tiles them with different steps.

The 1d iteration space is divided into:
1. [left_boundary_start, left_boundary_end), effected by left boundary.
2. [left_boundary_end, right_boundary_start), not effected by any boundary.
3. [right_boundary_start, right_boundary_end), effected by right boundary.

work_fn's switch is true for the left and right boundaries, implying boundary
conditions like padding in convolution. The middle part is tiled with static
tile sizes with the switch as false.

middle_tile_sizes should be in descending order for optimal performance.
(Larger tile size appeared later in the list fails the while-loop.)

Parameters:

Args:

​work_fn (fn[Int, Bool](Int) capturing -> None): Work function that processes one tile of workload.
​middle_tile_sizes (VariadicList[Int]): List of tile sizes for the middle part.
​left_tile_size (Int): Tile size for the left boundary region.
​right_tile_size (Int): Tile size for the right boundary region.

​left_boundary_start (Int): Start index of the left boundary.
​left_boundary_end (Int): End index of the left boundary.
​right_boundary_start (Int): Start index of the right boundary.
​right_boundary_end (Int): End index of the right boundary.





url:https://docs.modular.com/mojo/stdlib/algorithm/functional/unswitch
function

unswitch

unswitch[switched_func: fn[Bool]() capturing -> None](dynamic_switch: Bool)

Performs a functional unswitch transformation.

Unswitch is a simple pattern that is similar idea to loop unswitching
pass but extended to functional patterns. The pattern facilitates the
following code transformation that reduces the number of branches in the
generated code

Before:

After:

This unswitch function generalizes that pattern with the help of meta
parameters and can be used to perform both loop unswitching and other
tile predicate lifting like in simd and amx.

TODO: Generalize to support multiple predicates.
TODO: Once nested lambdas compose well should make unswitch compose with
tile in an easy way.

Parameters:

Args:

​switched_func (fn[Bool]() capturing -> None): The function containing the inner loop logic that can be unswitched.

​dynamic_switch (Bool): The dynamic condition that enables the unswitched code path.





url:https://docs.modular.com/mojo/stdlib/algorithm/functional/vectorize
function

vectorize

vectorize[func: fn[Int](Int) capturing -> None, simd_width: Int, /, *, unroll_factor: Int = 1](size: Int)

Simplifies SIMD optimized loops by mapping a function across a range from 0 to size, incrementing by simd_width at each step. The remainder of size % simd_width will run in separate iterations.

The below example demonstrates how you could improve the performance of a
loop, by setting multiple values at the same time using SIMD registers on
the machine:

On a machine with a SIMD register size of 128, this will set 4xInt32 values
on each iteration. The remainder of 10 % 4 is 2, so those last two elements
will be set in two separate iterations:

You can also unroll the loop to potentially improve performance at the cost
of binary size:

In the generated assembly the function calls will be repeated, resulting in
fewer arithmetic, comparison, and conditional jump operations. The assembly
would look like this in psuedocode:

You can pass size as a parameter if it's compile time known to reduce the
iterations for the remainder. This only occurs if the remainder is an
exponent of 2 (2, 4, 8, 16, ...). The remainder loop will still unroll for
performance improvements if not an exponent of 2.

Parameters:

Args:

​func (fn[Int](Int) capturing -> None): The function that will be called in the loop body.
​simd_width (Int): The SIMD vector width.
​unroll_factor (Int): The unroll factor for the main loop (Default 1).

​size (Int): The upper limit for the loop.





url:https://docs.modular.com/mojo/stdlib/algorithm/memory/
module

memory





url:https://docs.modular.com/mojo/stdlib/algorithm/memory/parallel_memcpy
function

parallel_memcpy

parallel_memcpy[type: DType](dest: DTypePointer[type, 0], src: DTypePointer[type, 0], count: Int, count_per_task: Int, num_tasks: Int)

Copies count elements from a memory buffer src to dest in parallel by spawning num_tasks tasks each copying count_per_task elements.

Parameters:

Args:

​type (DType): The element dtype.

​dest (DTypePointer[type, 0]): The destination buffer.
​src (DTypePointer[type, 0]): The source buffer.
​count (Int): Number of elements in the buffer.
​count_per_task (Int): Task size.
​num_tasks (Int): Number of tasks to run in parallel.





url:https://docs.modular.com/mojo/stdlib/algorithm/reduction/
module

reduction





url:https://docs.modular.com/mojo/stdlib/algorithm/reduction/all_true
function

all_true

all_true(src: Buffer[type, size, address_space]) -> Bool

Returns True if all the elements in a buffer are True and False otherwise.

Args:

Returns:

True if all of the elements of the buffer are True and False otherwise.

​src (Buffer[type, size, address_space]): The buffer.





url:https://docs.modular.com/mojo/stdlib/algorithm/reduction/any_true
function

any_true

any_true(src: Buffer[type, size, address_space]) -> Bool

Returns True if any the elements in a buffer are True and False otherwise.

Args:

Returns:

True if any of the elements of the buffer are True and False otherwise.

​src (Buffer[type, size, address_space]): The buffer.





url:https://docs.modular.com/mojo/stdlib/algorithm/reduction/argmax
function

argmax

argmax(input: NDBuffer[type, rank, shape, address_space], axis: Int, output: NDBuffer[type, rank, shape, address_space])

Finds the indices of the maximum element along the specified axis.

Args:

​input (NDBuffer[type, rank, shape, address_space]): The input tensor.
​axis (Int): The axis.
​output (NDBuffer[type, rank, shape, address_space]): The output tensor.





url:https://docs.modular.com/mojo/stdlib/algorithm/reduction/argmin
function

argmin

argmin(input: NDBuffer[type, rank, shape, address_space], axis: Int, output: NDBuffer[type, rank, shape, address_space])

Finds the indices of the minimum element along the specified axis.

Args:

​input (NDBuffer[type, rank, shape, address_space]): The input tensor.
​axis (Int): The axis.
​output (NDBuffer[type, rank, shape, address_space]): The output tensor.





url:https://docs.modular.com/mojo/stdlib/algorithm/reduction/cumsum
function

cumsum

cumsum(dst: Buffer[type, size, address_space], src: Buffer[type, size, address_space])

Computes the cumulative sum of all elements in a buffer.    dst[i] = src[i] + src[i-1] + ... + src[0].

Args:

​dst (Buffer[type, size, address_space]): The buffer that stores the result of cumulative sum operation.
​src (Buffer[type, size, address_space]): The buffer of elements for which the cumulative sum is computed.





url:https://docs.modular.com/mojo/stdlib/algorithm/reduction/map_reduce
function

map_reduce

map_reduce[simd_width: Int, size: Dim, type: DType, acc_type: DType, input_gen_fn: fn[DType, Int](Int) capturing -> SIMD[$0, $1], reduce_vec_to_vec_fn: fn[DType, DType, Int](SIMD[$0, $2], SIMD[$1, $2]) capturing -> SIMD[$0, $2], reduce_vec_to_scalar_fn: fn[DType, Int](SIMD[$0, $1]) -> SIMD[$0, 1]](dst: Buffer[type, size, 0], init: SIMD[acc_type, 1]) -> SIMD[$3, 1]

Stores the result of calling input_gen_fn in dst and simultaneously reduce the result using a custom reduction function.

Parameters:

Args:

Returns:

The computed reduction value.

​simd_width (Int): The vector width for the computation.
​size (Dim): The buffer size.
​type (DType): The buffer elements dtype.
​acc_type (DType): The dtype of the reduction accumulator.
​input_gen_fn (fn[DType, Int](Int) capturing -> SIMD[$0, $1]): A function that generates inputs to reduce.
​reduce_vec_to_vec_fn (fn[DType, DType, Int](SIMD[$0, $2], SIMD[$1, $2]) capturing -> SIMD[$0, $2]): A mapping function. This function is used to combine (accumulate) two chunks of input data: e.g. we load two 8xfloat32 vectors of elements and need to reduce them into a single 8xfloat32 vector.
​reduce_vec_to_scalar_fn (fn[DType, Int](SIMD[$0, $1]) -> SIMD[$0, 1]): A reduction function. This function is used to reduce a vector to a scalar. E.g. when we got 8xfloat32 vector and want to reduce it to an float32 scalar.

​dst (Buffer[type, size, 0]): The output buffer.
​init (SIMD[acc_type, 1]): The initial value to use in accumulator.





url:https://docs.modular.com/mojo/stdlib/algorithm/reduction/max
function

max

max(src: Buffer[type, size, address_space]) -> SIMD[$0, 1]

Computes the max element in a buffer.

Args:

Returns:

The maximum of the buffer elements.

​src (Buffer[type, size, address_space]): The buffer.





url:https://docs.modular.com/mojo/stdlib/algorithm/reduction/mean
function

mean

mean(src: Buffer[type, size, address_space]) -> SIMD[$0, 1]

Computes the mean value of the elements in a buffer.

Args:

Returns:

The mean value of the elements in the given buffer.

​src (Buffer[type, size, address_space]): The buffer of elements for which the mean is computed.





url:https://docs.modular.com/mojo/stdlib/algorithm/reduction/min
function

min

min(src: Buffer[type, size, address_space]) -> SIMD[$0, 1]

Computes the min element in a buffer.

Args:

Returns:

The minimum of the buffer elements.

​src (Buffer[type, size, address_space]): The buffer.





url:https://docs.modular.com/mojo/stdlib/algorithm/reduction/none_true
function

none_true

none_true(src: Buffer[type, size, address_space]) -> Bool

Returns True if none of the elements in a buffer are True and False otherwise.

Args:

Returns:

True if none of the elements of the buffer are True and False otherwise.

​src (Buffer[type, size, address_space]): The buffer.





url:https://docs.modular.com/mojo/stdlib/algorithm/reduction/product
function

product

product(src: Buffer[type, size, address_space]) -> SIMD[$0, 1]

Computes the product of the buffer elements.

Args:

Returns:

The product of the buffer elements.

​src (Buffer[type, size, address_space]): The buffer.





url:https://docs.modular.com/mojo/stdlib/algorithm/reduction/reduce
function

reduce

reduce[reduce_fn: fn[DType, DType, Int](SIMD[$0, $2], SIMD[$1, $2]) capturing -> SIMD[$0, $2]](src: Buffer[type, size, address_space], init: SIMD[type, 1]) -> SIMD[$4, 1]

Computes a custom reduction of buffer elements.

Parameters:

Args:

Returns:

The computed reduction value.

​reduce_fn (fn[DType, DType, Int](SIMD[$0, $2], SIMD[$1, $2]) capturing -> SIMD[$0, $2]): The lambda implementing the reduction.

​src (Buffer[type, size, address_space]): The input buffer.
​init (SIMD[type, 1]): The initial value to use in accumulator.





url:https://docs.modular.com/mojo/stdlib/algorithm/reduction/reduce_boolean
function

reduce_boolean

reduce_boolean[reduce_fn: fn[DType, Int](SIMD[$0, $1]) capturing -> Bool, continue_fn: fn(Bool) capturing -> Bool](src: Buffer[type, size, address_space], init: Bool) -> Bool

Computes a bool reduction of buffer elements. The reduction will early exit if the continue_fn returns False.

Parameters:

Args:

Returns:

The computed reduction value.

​reduce_fn (fn[DType, Int](SIMD[$0, $1]) capturing -> Bool): A boolean reduction function. This function is used to reduce a vector to a scalar. E.g. when we got 8xfloat32 vector and want to reduce it to a bool.
​continue_fn (fn(Bool) capturing -> Bool): A function to indicate whether we want to continue processing the rest of the iterations. This takes the result of the reduce_fn and returns True to continue processing and False to early exit.

​src (Buffer[type, size, address_space]): The input buffer.
​init (Bool): The initial value to use.





url:https://docs.modular.com/mojo/stdlib/algorithm/reduction/sum
function

sum

sum(src: Buffer[type, size, address_space]) -> SIMD[$0, 1]

Computes the sum of buffer elements.

Args:

Returns:

The sum of the buffer elements.

​src (Buffer[type, size, address_space]): The buffer.





url:https://docs.modular.com/mojo/stdlib/algorithm/reduction/variance
function

variance

variance(src: Buffer[type, size, address_space], mean_value: SIMD[type, 1], correction: Int = 1) -> SIMD[$0, 1]

Given a mean, computes the variance of elements in a buffer.

The mean value is used to avoid a second pass over the data:

Args:

Returns:

The variance value of the elements in a buffer.

​src (Buffer[type, size, address_space]): The buffer.
​mean_value (SIMD[type, 1]): The mean value of the buffer.
​correction (Int): Normalize variance by size - correction.





url:https://docs.modular.com/mojo/stdlib/base64/
package

base64





url:https://docs.modular.com/mojo/stdlib/base64/base64/
module

base64





url:https://docs.modular.com/mojo/stdlib/base64/base64/b16decode
function

b16decode

b16decode(str: String) -> String

Performs base16 decoding on the input string.

Args:

Returns:

The decoded string.

​str (String): A base16 encoded string.





url:https://docs.modular.com/mojo/stdlib/base64/base64/b16encode
function

b16encode

b16encode(str: String) -> String

Performs base16 encoding on the input string.

Args:

Returns:

Base16 encoding of the input string.

​str (String): The input string.





url:https://docs.modular.com/mojo/stdlib/base64/base64/b64decode
function

b64decode

b64decode(str: String) -> String

Performs base64 decoding on the input string.

Args:

Returns:

The decoded string.

​str (String): A base64 encoded string.





url:https://docs.modular.com/mojo/stdlib/base64/base64/b64encode
function

b64encode

b64encode(str: String) -> String

Performs base64 encoding on the input string.

Args:

Returns:

Base64 encoding of the input string.

​str (String): The input string.





url:https://docs.modular.com/mojo/stdlib/benchmark/
package

benchmark





url:https://docs.modular.com/mojo/stdlib/benchmark/bencher/
module

bencher





url:https://docs.modular.com/mojo/stdlib/benchmark/bencher/Bench
struct

Bench

__init__(inout self: Self, config: Optional[BenchConfig] = #kgen.none, mode: Mode = 0)

Constructs a Benchmark object based on specific configuration and mode.

Args:

​config (Optional[BenchConfig]): Benchmark configuration object to control length and frequency of benchmarks.
​mode (Mode): Benchmark mode object representing benchmark or test mode.

__init__(inout self: Self, config: Optional[BenchConfig] = #kgen.none, mode: Mode = 0)

Constructs a Benchmark object based on specific configuration and mode.

Args:

​config (Optional[BenchConfig]): Benchmark configuration object to control length and frequency of benchmarks.
​mode (Mode): Benchmark mode object representing benchmark or test mode.

__init__(inout self: Self, config: Optional[BenchConfig] = #kgen.none, mode: Mode = 0)

Constructs a Benchmark object based on specific configuration and mode.

Args:

​config (Optional[BenchConfig]): Benchmark configuration object to control length and frequency of benchmarks.
​mode (Mode): Benchmark mode object representing benchmark or test mode.

bench_with_input[T: AnyType, bench_fn: fn(inout Bencher, $0) capturing -> None](inout self: Self, bench_id: BenchId, input: T, throughput_elems: Optional[Int] = #kgen.none, measures: List[ThroughputMeasure] = List())

Benchmarks an input function with input args of type AnyType.

Parameters:

Args:

​T (AnyType): Benchmark function input type.
​bench_fn (fn(inout Bencher, $0) capturing -> None): The function to be benchmarked.

​bench_id (BenchId): The benchmark Id object used for identification.
​input (T): Represents the target function's input arguments.
​throughput_elems (Optional[Int]): Optional argument representing algorithmic throughput.
​measures (List[ThroughputMeasure]): Optional arg used to represent a list of ThroughputMeasure's.

bench_function[bench_fn: fn(inout Bencher) capturing -> None](inout self: Self, bench_id: BenchId, throughput_elems: Optional[Int] = #kgen.none, measures: List[ThroughputMeasure] = List())

Benchmarks or Tests an input function.

Parameters:

Args:

​bench_fn (fn(inout Bencher) capturing -> None): The function to be benchmarked.

​bench_id (BenchId): The benchmark Id object used for identification.
​throughput_elems (Optional[Int]): Optional argument representing algorithmic throughput.
​measures (List[ThroughputMeasure]): Optional arg used to represent a list of ThroughputMeasure's.

dump_report(self: Self)

Prints out the report from a Benchmark execution.





url:https://docs.modular.com/mojo/stdlib/benchmark/bencher/BenchConfig
struct

BenchConfig

__init__(inout self: Self, out_file: Optional[Path] = #kgen.none, min_runtime_secs: SIMD[float64, 1] = #kgen.float_literal<1|10>, max_runtime_secs: SIMD[float64, 1] = 1, warmup_iters: Int = 2, max_batch_size: Int = 0, max_iters: Int = 1000000000, num_repetitions: Int = 1, flush_denormals: Bool = 1)

Constructs and initializes Benchmark config object with default and inputed values.

Args:

​out_file (Optional[Path]): Output file to write results to.
​min_runtime_secs (SIMD[float64, 1]): Upper bound on benchmarking time in secs (default 0.1).
​max_runtime_secs (SIMD[float64, 1]): Lower bound on benchmarking time in secs (default 1).
​warmup_iters (Int): Number of warmup iterations to run before starting benchmarking (default 2).
​max_batch_size (Int): The maximum number of iterations to perform per time measurement.
​max_iters (Int): Max number of iterations to run (default 1_000_000_000).
​num_repetitions (Int): Number of times the benchmark has to be repeated.
​flush_denormals (Bool): Whether or not the denormal values are flushed.

__init__(inout self: Self, out_file: Optional[Path] = #kgen.none, min_runtime_secs: SIMD[float64, 1] = #kgen.float_literal<1|10>, max_runtime_secs: SIMD[float64, 1] = 1, warmup_iters: Int = 2, max_batch_size: Int = 0, max_iters: Int = 1000000000, num_repetitions: Int = 1, flush_denormals: Bool = 1)

Constructs and initializes Benchmark config object with default and inputed values.

Args:

​out_file (Optional[Path]): Output file to write results to.
​min_runtime_secs (SIMD[float64, 1]): Upper bound on benchmarking time in secs (default 0.1).
​max_runtime_secs (SIMD[float64, 1]): Lower bound on benchmarking time in secs (default 1).
​warmup_iters (Int): Number of warmup iterations to run before starting benchmarking (default 2).
​max_batch_size (Int): The maximum number of iterations to perform per time measurement.
​max_iters (Int): Max number of iterations to run (default 1_000_000_000).
​num_repetitions (Int): Number of times the benchmark has to be repeated.
​flush_denormals (Bool): Whether or not the denormal values are flushed.

__init__(inout self: Self, out_file: Optional[Path] = #kgen.none, min_runtime_secs: SIMD[float64, 1] = #kgen.float_literal<1|10>, max_runtime_secs: SIMD[float64, 1] = 1, warmup_iters: Int = 2, max_batch_size: Int = 0, max_iters: Int = 1000000000, num_repetitions: Int = 1, flush_denormals: Bool = 1)

Constructs and initializes Benchmark config object with default and inputed values.

Args:

​out_file (Optional[Path]): Output file to write results to.
​min_runtime_secs (SIMD[float64, 1]): Upper bound on benchmarking time in secs (default 0.1).
​max_runtime_secs (SIMD[float64, 1]): Lower bound on benchmarking time in secs (default 1).
​warmup_iters (Int): Number of warmup iterations to run before starting benchmarking (default 2).
​max_batch_size (Int): The maximum number of iterations to perform per time measurement.
​max_iters (Int): Max number of iterations to run (default 1_000_000_000).
​num_repetitions (Int): Number of times the benchmark has to be repeated.
​flush_denormals (Bool): Whether or not the denormal values are flushed.





url:https://docs.modular.com/mojo/stdlib/benchmark/bencher/BenchId
struct

BenchId

__init__(inout self: Self, func_name: String, input_id: String)

Constructs a Benchmark Id object from input function name and Id phrase.

Args:

​func_name (String): The target function name.
​input_id (String): The target function input id phrase.

__init__(inout self: Self, func_name: String, input_id: String)

Constructs a Benchmark Id object from input function name and Id phrase.

Args:

​func_name (String): The target function name.
​input_id (String): The target function input id phrase.

__init__(inout self: Self, func_name: String, input_id: String)

Constructs a Benchmark Id object from input function name and Id phrase.

Args:

​func_name (String): The target function name.
​input_id (String): The target function input id phrase.





url:https://docs.modular.com/mojo/stdlib/benchmark/bencher/BenchMetric
struct

BenchMetric

__eq__(self: Self, other: Self) -> Bool

Compares two metrics for equality.

Args:

Returns:

True if the two metrics are equal.

​other (Self): The metric to compare.

__eq__(self: Self, other: Self) -> Bool

Compares two metrics for equality.

Args:

Returns:

True if the two metrics are equal.

​other (Self): The metric to compare.

__eq__(self: Self, other: Self) -> Bool

Compares two metrics for equality.

Args:

Returns:

True if the two metrics are equal.

​other (Self): The metric to compare.

__ne__(self: Self, other: Self) -> Bool

Compares two metrics for inequality.

Args:

Returns:

True if the two metrics are NOT equal.

​other (Self): The metric to compare.

check_name(self: Self, alt_name: String) -> Bool

Check whether a string contains the metric's name.

Args:

Returns:

True if 'alt_name' is valid alternative of the metric's name.

​alt_name (String): Alternative name of a metric.

static get_metric_from_list(name: String, metric_list: List[BenchMetric]) -> Self

Return a metric from a given list by only using metric's name.

Args:

Returns:

Return a metric from a given list by only using metric's name.

​name (String): Metric's name (String).
​metric_list (List[BenchMetric]): List of metrics to search.





url:https://docs.modular.com/mojo/stdlib/benchmark/bencher/Bencher
struct

Bencher

__init__(inout self: Self, num_iters: Int)

Constructs a Bencher object to run and time a function.

Args:

​num_iters (Int): Number of times to run the target function.

__init__(inout self: Self, num_iters: Int)

Constructs a Bencher object to run and time a function.

Args:

​num_iters (Int): Number of times to run the target function.

__init__(inout self: Self, num_iters: Int)

Constructs a Bencher object to run and time a function.

Args:

​num_iters (Int): Number of times to run the target function.

iter[iter_fn: fn() capturing -> None](inout self: Self)

Returns the total elapsed time by running a target function a particular number of times.

Parameters:

​iter_fn (fn() capturing -> None): The target function to benchmark.

iter_custom[iter_fn: fn(Int) capturing -> Int](inout self: Self)

Times a target function with custom number of iterations.

Parameters:

​iter_fn (fn(Int) capturing -> Int): The target function to benchmark.





url:https://docs.modular.com/mojo/stdlib/benchmark/bencher/BenchmarkInfo
struct

BenchmarkInfo

__init__(inout self: Self, name: String, result: Report, elems: Optional[Int], measures: List[ThroughputMeasure] = List(), verbose_timing: Bool = 0)

Constructs a Benchmark Info object to return Benchmark report and Stats.

Args:

​name (String): The name of the benchmark.
​result (Report): The output report after executing a benchmark.
​elems (Optional[Int]): Optional arg used to represent a specific metric like throughput.
​measures (List[ThroughputMeasure]): Optional arg used to represent a list of ThroughputMeasure's.
​verbose_timing (Bool): Whether to print verbose timing results.

__init__(inout self: Self, name: String, result: Report, elems: Optional[Int], measures: List[ThroughputMeasure] = List(), verbose_timing: Bool = 0)

Constructs a Benchmark Info object to return Benchmark report and Stats.

Args:

​name (String): The name of the benchmark.
​result (Report): The output report after executing a benchmark.
​elems (Optional[Int]): Optional arg used to represent a specific metric like throughput.
​measures (List[ThroughputMeasure]): Optional arg used to represent a list of ThroughputMeasure's.
​verbose_timing (Bool): Whether to print verbose timing results.

__init__(inout self: Self, name: String, result: Report, elems: Optional[Int], measures: List[ThroughputMeasure] = List(), verbose_timing: Bool = 0)

Constructs a Benchmark Info object to return Benchmark report and Stats.

Args:

​name (String): The name of the benchmark.
​result (Report): The output report after executing a benchmark.
​elems (Optional[Int]): Optional arg used to represent a specific metric like throughput.
​measures (List[ThroughputMeasure]): Optional arg used to represent a list of ThroughputMeasure's.
​verbose_timing (Bool): Whether to print verbose timing results.





url:https://docs.modular.com/mojo/stdlib/benchmark/bencher/Mode
struct

Mode

__eq__(self: Self, other: Self) -> Bool

Check if its Benchmark mode or test mode.

Args:

Returns:

If its a test mode or benchmark mode.

​other (Self): The mode to be compared against.

__eq__(self: Self, other: Self) -> Bool

Check if its Benchmark mode or test mode.

Args:

Returns:

If its a test mode or benchmark mode.

​other (Self): The mode to be compared against.

__eq__(self: Self, other: Self) -> Bool

Check if its Benchmark mode or test mode.

Args:

Returns:

If its a test mode or benchmark mode.

​other (Self): The mode to be compared against.





url:https://docs.modular.com/mojo/stdlib/benchmark/bencher/ThroughputMeasure
struct

ThroughputMeasure

__init__(inout self: Self, name: String, value: Int, reference: List[BenchMetric] = BenchMetric(0, "Elements", "GElement/s"), BenchMetric(1, "Bytes", "GB/s"), BenchMetric(2, "FLOPS", "GFLOPS/s"))

Create a ThroughputMeasure based on metric's name (String).

Example:
For the default bench metrics BenchMetric.DEFAULTS the
following are equivalent:
- ThroughputMeasure(BenchMetric.fmas, 1024)
- ThroughputMeasure("fmas", 1024)
- ThroughputMeasure("fmas", 1024, BenchMetric.DEFAULTS)

Args:

​name (String): The name of BenchMetric in its corresponding reference.
​value (Int): The measured value to assign to this metric.
​reference (List[BenchMetric]): Reference variadic list of BenchMetrics that contains this metric.

__init__(inout self: Self, name: String, value: Int, reference: List[BenchMetric] = BenchMetric(0, "Elements", "GElement/s"), BenchMetric(1, "Bytes", "GB/s"), BenchMetric(2, "FLOPS", "GFLOPS/s"))

Create a ThroughputMeasure based on metric's name (String).

Example:
For the default bench metrics BenchMetric.DEFAULTS the
following are equivalent:
- ThroughputMeasure(BenchMetric.fmas, 1024)
- ThroughputMeasure("fmas", 1024)
- ThroughputMeasure("fmas", 1024, BenchMetric.DEFAULTS)

Args:

​name (String): The name of BenchMetric in its corresponding reference.
​value (Int): The measured value to assign to this metric.
​reference (List[BenchMetric]): Reference variadic list of BenchMetrics that contains this metric.

__init__(inout self: Self, name: String, value: Int, reference: List[BenchMetric] = BenchMetric(0, "Elements", "GElement/s"), BenchMetric(1, "Bytes", "GB/s"), BenchMetric(2, "FLOPS", "GFLOPS/s"))

Create a ThroughputMeasure based on metric's name (String).

Example:
For the default bench metrics BenchMetric.DEFAULTS the
following are equivalent:
- ThroughputMeasure(BenchMetric.fmas, 1024)
- ThroughputMeasure("fmas", 1024)
- ThroughputMeasure("fmas", 1024, BenchMetric.DEFAULTS)

Args:

​name (String): The name of BenchMetric in its corresponding reference.
​value (Int): The measured value to assign to this metric.
​reference (List[BenchMetric]): Reference variadic list of BenchMetrics that contains this metric.

compute(self: Self, elapsed_sec: SIMD[float64, 1]) -> SIMD[float64, 1]

Compute throughput rate for this metric per unit of time (second).

Args:

Returns:

The throughput values as a floating point 64.

​elapsed_sec (SIMD[float64, 1]): Elapsed time measured in seconds.





url:https://docs.modular.com/mojo/stdlib/benchmark/benchmark/
module

benchmark





url:https://docs.modular.com/mojo/stdlib/benchmark/benchmark/Batch
struct

Batch

mean(self: Self, unit: String = "s") -> SIMD[float64, 1]

Returns the average duration of the batch.

Args:

Returns:

The average duration of the batch.

​unit (String): The time unit to display for example: ns, ms, s (default s).

mean(self: Self, unit: String = "s") -> SIMD[float64, 1]

Returns the average duration of the batch.

Args:

Returns:

The average duration of the batch.

​unit (String): The time unit to display for example: ns, ms, s (default s).

mean(self: Self, unit: String = "s") -> SIMD[float64, 1]

Returns the average duration of the batch.

Args:

Returns:

The average duration of the batch.

​unit (String): The time unit to display for example: ns, ms, s (default s).





url:https://docs.modular.com/mojo/stdlib/benchmark/benchmark/Report
struct

Report

__init__(inout self: Self)

Default initializer for the Report.

Sets all values to 0

__init__(inout self: Self)

Default initializer for the Report.

Sets all values to 0

__init__(inout self: Self)

Default initializer for the Report.

Sets all values to 0

__copyinit__(inout self: Self, existing: Self)

Creates a shallow copy (it doesn't copy the data).

Args:

​existing (Self): The Report to copy.

iters(self: Self) -> Int

The total benchmark iterations.

Returns:

The total benchmark iterations.

duration(self: Self, unit: String = "s") -> SIMD[float64, 1]

The total duration it took to run all benchmarks.

Args:

Returns:

The total duration it took to run all benchmarks.

​unit (String): The time unit to display for example: ns, ms, s (default s).

mean(self: Self, unit: String = "s") -> SIMD[float64, 1]

The average duration of all benchmark runs.

Args:

Returns:

The average duration of all benchmark runs.

​unit (String): The time unit to display for example: ns, ms, s (default s).

min(self: Self, unit: String = "s") -> SIMD[float64, 1]

The batch of benchmarks that was the fastest to run.

Args:

Returns:

The fastest duration out of all batches.

​unit (String): The time unit to display for example: ns, ms, s (default s).

max(self: Self, unit: String = "s") -> SIMD[float64, 1]

The batch of benchmarks that was the slowest to run.

Args:

Returns:

The slowest duration out of all batches.

​unit (String): The time unit to display for example: ns, ms, s (default s).

print(self: Self, unit: String = "s")

Prints out the shortened version of the report.

Args:

​unit (String): The time unit to display for example: ns, ms, s (default s).

print_full(self: Self, unit: String = "s")

Prints out the full version of the report with each batch of benchmark runs.

Args:

​unit (String): The time unit to display for example: ns, ms, s (default s).





url:https://docs.modular.com/mojo/stdlib/benchmark/benchmark/Unit
struct

Unit





url:https://docs.modular.com/mojo/stdlib/benchmark/benchmark/run
function

run

run[func: fn() -> None](num_warmup: Int = 2, max_iters: Int = 1000000000, min_runtime_secs: SIMD[float64, 1] = 2, max_runtime_secs: SIMD[float64, 1] = 60, max_batch_size: Int = 0) -> Report

Benchmarks the function passed in as a parameter.

Benchmarking continues until 'min_time_ns' has elapsed and either
max_time_ns OR max_iters is achieved.

Parameters:

Args:

Returns:

Average execution time of func in ns.

​func (fn() -> None): The function to benchmark.

​num_warmup (Int): Number of warmup iterations to run before starting benchmarking (default 2).
​max_iters (Int): Max number of iterations to run (default 1_000_000_000).
​min_runtime_secs (SIMD[float64, 1]): Upper bound on benchmarking time in secs (default 2).
​max_runtime_secs (SIMD[float64, 1]): Lower bound on benchmarking time in secs (default 60).
​max_batch_size (Int): The maximum number of iterations to perform per time measurement.





url:https://docs.modular.com/mojo/stdlib/benchmark/compiler/
module

compiler





url:https://docs.modular.com/mojo/stdlib/benchmark/compiler/keep
function

keep

keep(val: Bool)

Provides a hint to the compiler to not optimize the variable use away.

This is useful in benchmarking to avoid the compiler not deleting the
code to be benchmarked because the variable is not used in a side-effecting
manner.

Args:

​val (Bool): The value to not optimize away.





url:https://docs.modular.com/mojo/stdlib/benchmark/memory/
module

memory





url:https://docs.modular.com/mojo/stdlib/benchmark/memory/clobber_memory
function

clobber_memory

clobber_memory()

Forces all pending memory writes to be flushed to memory.

This ensures that the compiler does not optimize away memory writes if it
deems them to be not neccessary. In effect, this operation acts a barrier
to memory reads and writes.





url:https://docs.modular.com/mojo/stdlib/benchmark/quick_bench/
module

quick_bench





url:https://docs.modular.com/mojo/stdlib/benchmark/quick_bench/QuickBench
struct

QuickBench

__init__(inout self: Self)

Just initialize the Bench object.

__init__(inout self: Self)

Just initialize the Bench object.

__init__(inout self: Self)

Just initialize the Bench object.

dump_report(self: Self)

Prints out the report from a Benchmark execution collected in Bench object.

run[T_out: AnyTrivialRegType](inout self: Self, func: fn() -> T_out, *, bench_id: BenchId, measures: List[ThroughputMeasure] = List())

Benchmark function func with no input arguments and return type T_out.

Parameters:

Args:

​T_out (AnyTrivialRegType): Output type of func.

​func (fn() -> T_out): The function to be benchmarked (run in benchmark iterations).
​bench_id (BenchId): The benchmark Id object used for identification.
​measures (List[ThroughputMeasure]): Optional arg used to represent a list of ThroughputMeasure's.





url:https://docs.modular.com/mojo/stdlib/bit/
package

bit





url:https://docs.modular.com/mojo/stdlib/bit/bit/
module

bit





url:https://docs.modular.com/mojo/stdlib/bit/bit/bit_ceil
function

bit_ceil

bit_ceil(val: Int) -> Int

Computes the smallest power of 2 that is greater than or equal to the input value. Any integral value less than or equal to 1 will be ceiled to 1.

Args:

Returns:

The smallest power of 2 that is greater than or equal to the input value.

​val (Int): The input value.





url:https://docs.modular.com/mojo/stdlib/bit/bit/bit_floor
function

bit_floor

bit_floor(val: Int) -> Int

Computes the largest power of 2 that is less than or equal to the input value. Any integral value less than or equal to 0 will be floored to 0.

Args:

Returns:

The largest power of 2 that is less than or equal to the input value.

​val (Int): The input value.





url:https://docs.modular.com/mojo/stdlib/bit/bit/bit_not
function

bit_not

bit_not[type: DType, simd_width: Int](val: SIMD[type, simd_width]) -> SIMD[$0, $1]

Performs a bitwise NOT operation on an SIMD vector of integer values.

Constraints:

The element type of the input vector must be integral.

Parameters:

Args:

Returns:

A SIMD value where the element at position i is computed as a bitwise NOT of the integer value at position i of the input value.

​type (DType): dtype used for the computation.
​simd_width (Int): SIMD width used for the computation.

​val (SIMD[type, simd_width]): The input value.





url:https://docs.modular.com/mojo/stdlib/bit/bit/bit_reverse
function

bit_reverse

bit_reverse[type: DType, simd_width: Int](val: SIMD[type, simd_width]) -> SIMD[$0, $1]

Element-wise reverses the bitpattern of a SIMD vector of integer values.

Constraints:

The element type of the input vector must be integral.

Parameters:

Args:

Returns:

A SIMD value where the element at position i has a reversed bitpattern of an integer value of the element at position i of the input value.

​type (DType): dtype used for the computation.
​simd_width (Int): SIMD width used for the computation.

​val (SIMD[type, simd_width]): The input value.





url:https://docs.modular.com/mojo/stdlib/bit/bit/bit_width
function

bit_width

bit_width(val: Int) -> Int

Computes the minimum number of bits required to represent the integer.

Args:

Returns:

The number of bits required to represent the integer.

​val (Int): The input value.





url:https://docs.modular.com/mojo/stdlib/bit/bit/byte_swap
function

byte_swap

byte_swap[type: DType, simd_width: Int](val: SIMD[type, simd_width]) -> SIMD[$0, $1]

Byte-swaps a SIMD vector of integer values with an even number of bytes.

Byte swap an integer value or vector of integer values with an even number
of bytes (positive multiple of 16 bits). This is equivalent to llvm.bswap
intrinsic that has the following semantics:

The llvm.bswap.i16 intrinsic returns an i16 value that has the high and
low byte of the input i16 swapped. Similarly, the llvm.bswap.i32 intrinsic
returns an i32 value that has the four bytes of the input i32 swapped, so
that if the input bytes are numbered 0, 1, 2, 3 then the returned i32 will
have its bytes in 3, 2, 1, 0 order. The llvm.bswap.i48, llvm.bswap.i64
and other intrinsics extend this concept to additional even-byte lengths (6
bytes, 8 bytes and more, respectively).

Constraints:

The element type of the input vector must be an integral type with an even number of bytes (Bitwidth % 16 == 0).

Parameters:

Args:

Returns:

A SIMD value where the element at position i is the value of the element at position i of the input value with its bytes swapped.

​type (DType): dtype used for the computation.
​simd_width (Int): SIMD width used for the computation.

​val (SIMD[type, simd_width]): The input value.





url:https://docs.modular.com/mojo/stdlib/bit/bit/countl_zero
function

countl_zero

countl_zero(val: Int) -> Int

Counts the number of leading zeros of an integer.

Args:

Returns:

The number of leading zeros of the input.

​val (Int): The input value.





url:https://docs.modular.com/mojo/stdlib/bit/bit/countr_zero
function

countr_zero

countr_zero(val: Int) -> Int

Counts the number of trailing zeros for an integer.

Args:

Returns:

The number of trailing zeros of the input.

​val (Int): The input value.





url:https://docs.modular.com/mojo/stdlib/bit/bit/is_power_of_two
function

is_power_of_two

is_power_of_two(val: Int) -> Bool

Checks if the input value is a power of 2.

Args:

Returns:

True if the input value is a power of 2, False otherwise.

​val (Int): The input value.





url:https://docs.modular.com/mojo/stdlib/bit/bit/pop_count
function

pop_count

pop_count[type: DType, simd_width: Int](val: SIMD[type, simd_width]) -> SIMD[$0, $1]

Counts the number of bits set in a SIMD vector of integer values.

Constraints:

The element type of the input vector must be integral.

Parameters:

Args:

Returns:

A SIMD value where the element at position i contains the number of bits set in the element at position i of the input value.

​type (DType): dtype used for the computation.
​simd_width (Int): SIMD width used for the computation.

​val (SIMD[type, simd_width]): The input value.





url:https://docs.modular.com/mojo/stdlib/bit/bit/rotate_bits_left
function

rotate_bits_left

rotate_bits_left[shift: Int](x: Int) -> Int

Shifts the bits of an input to the left by shift bits (with wrap-around).

Constraints:

-size <= shift < size

Parameters:

Args:

Returns:

The input rotated to the left by shift elements (with wrap-around).

​shift (Int): The number of bit positions by which to rotate the bits of the integer to the left (with wrap-around).

​x (Int): The input value.





url:https://docs.modular.com/mojo/stdlib/bit/bit/rotate_bits_right
function

rotate_bits_right

rotate_bits_right[shift: Int](x: Int) -> Int

Shifts the bits of an input to the right by shift bits (with wrap-around).

Constraints:

-size <= shift < size

Parameters:

Args:

Returns:

The input rotated to the right by shift elements (with wrap-around).

​shift (Int): The number of bit positions by which to rotate the bits of the integer to the right (with wrap-around).

​x (Int): The input value.





url:https://docs.modular.com/mojo/stdlib/buffer/
package

buffer





url:https://docs.modular.com/mojo/stdlib/buffer/buffer/
module

buffer





url:https://docs.modular.com/mojo/stdlib/buffer/buffer/Buffer
struct

Buffer

__init__(inout self: Self)

Default initializer for Buffer. By default the fields are all initialized to 0.

__init__(inout self: Self)

Default initializer for Buffer. By default the fields are all initialized to 0.

__init__(inout self: Self)

Default initializer for Buffer. By default the fields are all initialized to 0.

__getitem__(self: Self, idx: Int) -> SIMD[type, 1]

Loads a single element (SIMD of size 1) from the buffer at the specified index.

Args:

Returns:

The value at the idx position.

​idx (Int): The index into the Buffer.

__setitem__(self: Self, idx: Int, val: scalar<#lit.struct.extract<:_stdlib::_builtin::_dtype::_DType type, "value">>)

Stores a single value into the buffer at the specified index.

Args:

​idx (Int): The index into the Buffer.
​val (scalar<#lit.struct.extract<:_stdlib::_builtin::_dtype::_DType type, "value">>): The value to store.

load[*, width: Int = 1, alignment: Int = alignof[stdlib::builtin::dtype::DType,__mlir_type.!kgen.target]() if triple_is_nvidia_cuda() else 1](self: Self, idx: Int) -> SIMD[type, $0]

Loads a simd value from the buffer at the specified index.

Parameters:

Args:

Returns:

The simd value starting at the idx position and ending at idx+width.

​width (Int): The simd_width of the load.
​alignment (Int): The alignment value.

​idx (Int): The index into the Buffer.

store[*, width: Int = 1, alignment: Int = alignof[stdlib::builtin::dtype::DType,__mlir_type.!kgen.target]() if triple_is_nvidia_cuda() else 1](self: Self, idx: Int, val: SIMD[type, width])

Stores a simd value into the buffer at the specified index.

Parameters:

Args:

​width (Int): The width of the simd vector.
​alignment (Int): The alignment value.

​idx (Int): The index into the Buffer.
​val (SIMD[type, width]): The value to store.

simd_nt_store[width: Int](self: Self, idx: Int, val: SIMD[type, width])

Stores a simd value using non-temporal store.

Constraints:

The address must be properly aligned, 64B for avx512, 32B for avx2, and 16B for avx.

Parameters:

Args:

​width (Int): The width of the simd vector.

​idx (Int): The index into the Buffer.
​val (SIMD[type, width]): The value to store.

prefetch[params: PrefetchOptions](self: Self, idx: Int)

Prefetches the data at the given index.

Parameters:

Args:

​params (PrefetchOptions): The prefetch configuration.

​idx (Int): The index of the prefetched location.

bytecount(self: Self) -> Int

Returns the size of the Buffer in bytes.

Returns:

The size of the Buffer in bytes.

zero(self: Self)

Sets all bytes of the Buffer to 0.

fill(self: Self, val: SIMD[type, 1])

Assigns val to all elements in the Buffer.

The fill is performed in chunks of size N, where N is the native SIMD
width of type on the system.

Args:

​val (SIMD[type, 1]): The value to store.

tofile(self: Self, path: Path)

Write values to a file.

Args:

​path (Path): Path to the output file.

static aligned_stack_allocation[alignment: Int]() -> Self

Constructs a buffer instance backed by stack allocated memory space.

Parameters:

Returns:

Constructed buffer with the allocated space.

​alignment (Int): Address alignment requirement for the allocation.

static stack_allocation() -> Self

Constructs a buffer instance backed by stack allocated memory space.

Returns:

Constructed buffer with the allocated space.





url:https://docs.modular.com/mojo/stdlib/buffer/buffer/DynamicRankBuffer
struct

DynamicRankBuffer

__init__(inout self: Self, data: DTypePointer[invalid, 0], rank: Int, shape: StaticIntTuple[8], type: DType)

Construct DynamicRankBuffer.

Args:

​data (DTypePointer[invalid, 0]): Pointer to the underlying data.
​rank (Int): Rank of the buffer.
​shape (StaticIntTuple[8]): Shapes of the buffer.
​type (DType): dtype of the buffer.

__init__(inout self: Self, data: DTypePointer[invalid, 0], rank: Int, shape: StaticIntTuple[8], type: DType)

Construct DynamicRankBuffer.

Args:

​data (DTypePointer[invalid, 0]): Pointer to the underlying data.
​rank (Int): Rank of the buffer.
​shape (StaticIntTuple[8]): Shapes of the buffer.
​type (DType): dtype of the buffer.

__init__(inout self: Self, data: DTypePointer[invalid, 0], rank: Int, shape: StaticIntTuple[8], type: DType)

Construct DynamicRankBuffer.

Args:

​data (DTypePointer[invalid, 0]): Pointer to the underlying data.
​rank (Int): Rank of the buffer.
​shape (StaticIntTuple[8]): Shapes of the buffer.
​type (DType): dtype of the buffer.

to_buffer[type: DType](self: Self) -> Buffer[$0, Dim(), 0]

Casts DynamicRankBuffer to Buffer.

Parameters:

Returns:

Constructed Buffer.

​type (DType): dtype of the buffer.

to_ndbuffer[type: DType, rank: Int](self: Self) -> NDBuffer[$0, $1, create_unknown[stdlib::builtin::int::Int](), 0]

Casts the buffer to NDBuffer.

Constraints:

Rank of DynamicRankBuffer must equal rank of NDBuffer.

Parameters:

Returns:

Constructed NDBuffer.

​type (DType): dtype of the buffer.
​rank (Int): Rank of the buffer.

rank_dispatch[func: fn[Int]() capturing -> None](self: Self)

Dispatches the function call based on buffer rank.

Constraints:

Rank must be positive and less or equal to 8.

Parameters:

​func (fn[Int]() capturing -> None): Function to dispatch. The function should be parametrized on an index parameter, which will be used for rank when the function will be called.

num_elements(self: Self) -> Int

Gets number of elements in the buffer.

Returns:

The number of elements in the buffer.

get_shape[rank: Int](self: Self) -> StaticIntTuple[$0]

Gets a static tuple representing the buffer shape.

Parameters:

Returns:

A static tuple of size 'Rank' filled with buffer shapes.

​rank (Int): Rank of the buffer.

dim(self: Self, idx: Int) -> Int

Gets given dimension.

Args:

Returns:

The buffer size on the given dimension.

​idx (Int): The dimension index.





url:https://docs.modular.com/mojo/stdlib/buffer/buffer/NDBuffer
struct

NDBuffer

__init__(inout self: Self)

Default initializer for NDBuffer. By default the fields are all initialized to 0.

__init__(inout self: Self)

Default initializer for NDBuffer. By default the fields are all initialized to 0.

__init__(inout self: Self)

Default initializer for NDBuffer. By default the fields are all initialized to 0.

__getitem__(self: Self, *idx: Int) -> SIMD[type, 1]

Gets an element from the buffer from the specified index.

Args:

Returns:

The value of the element.

​*idx (Int): Index of the element to retrieve.

__setitem__(self: Self, idx: StaticIntTuple[rank], val: SIMD[type, 1])

Stores a single value into the buffer at the specified index.

Args:

​idx (StaticIntTuple[rank]): The index into the Buffer.
​val (SIMD[type, 1]): The value to store.

__add__(self: Self, rhs: NDBuffer[type, rank, shape, address_space]) -> Self

Adds a NDBuffer.

Args:

Returns:

The addition result.

​rhs (NDBuffer[type, rank, shape, address_space]): The RHS of the add operation.

__sub__(self: Self, rhs: Self) -> Self

Subtracts a scalar.

Args:

Returns:

The subtraction result.

​rhs (Self): The RHS of the sub operation.

__mul__(self: Self, rhs: Self) -> Self

Multiplies a NDBuffer.

Args:

Returns:

The division result.

​rhs (Self): The RHS of the mul operation.

__imul__(inout self: Self, rhs: SIMD[float32, 1])

In-place multiplies a scalar.

Args:

​rhs (SIMD[float32, 1]): The RHS of the mul operation.

__itruediv__(inout self: Self, rhs: NDBuffer[type, rank, shape, address_space])

In-place divides a NDBuffer.

Args:

​rhs (NDBuffer[type, rank, shape, address_space]): The RHS of the div operation.

get_rank(self: Self) -> Int

Returns the rank of the buffer.

Returns:

The rank of NDBuffer.

get_shape(self: Self) -> StaticIntTuple[rank]

Returns the shapes of the buffer.

Returns:

A static tuple of size 'rank' representing shapes of the NDBuffer.

get_nd_index(self: Self, idx: Int) -> StaticIntTuple[rank]

Computes the NDBuffer's ND-index based on the flat index.

Args:

Returns:

The index positions.

​idx (Int): The flat index.

num_elements(self: Self) -> Int

Computes the NDBuffer's number of elements.

Returns:

The total number of elements in the NDBuffer.

size(self: Self) -> Int

Computes the NDBuffer's number of elements.

Returns:

The total number of elements in the NDBuffer.

tile[*tile_sizes: Dim](self: Self, tile_coords: StaticIntTuple[rank]) -> NDBuffer[type, rank, $0, address_space]

Returns an n-d tile "slice" of the buffer of size tile_sizes at    coords.

Parameters:

Args:

Returns:

The tiled buffer at tile_coords.

​*tile_sizes (Dim): The size of the tiles.

​tile_coords (StaticIntTuple[rank]): The tile index.

load[*, width: Int = 1, alignment: Int = alignof[stdlib::builtin::dtype::DType,__mlir_type.!kgen.target]() if triple_is_nvidia_cuda() else 1](self: Self, *idx: Int) -> SIMD[type, $0]

Loads a simd value from the buffer at the specified index.

Constraints:

The buffer must be contiguous or width must be 1.

Parameters:

Args:

Returns:

The simd value starting at the idx position and ending at idx+width.

​width (Int): The simd_width of the load.
​alignment (Int): The alignment value.

​*idx (Int): The index into the NDBuffer.

store[*, width: Int = 1, alignment: Int = alignof[stdlib::builtin::dtype::DType,__mlir_type.!kgen.target]() if triple_is_nvidia_cuda() else 1](self: Self, idx: StaticIntTuple[rank], val: SIMD[type, width])

Stores a simd value into the buffer at the specified index.

Constraints:

The buffer must be contiguous or width must be 1.

Parameters:

Args:

​width (Int): The width of the simd vector.
​alignment (Int): The alignment value.

​idx (StaticIntTuple[rank]): The index into the Buffer.
​val (SIMD[type, width]): The value to store.

simd_nt_store[width: Int](self: Self, idx: StaticIntTuple[rank], val: SIMD[type, width])

Stores a simd value using non-temporal store.

Constraints:

The buffer must be contiguous. The address must be properly aligned, 64B for avx512, 32B for avx2, and 16B for avx.

Parameters:

Args:

​width (Int): The width of the simd vector.

​idx (StaticIntTuple[rank]): The index into the Buffer.
​val (SIMD[type, width]): The value to store.

dim[index: Int](self: Self) -> Int

Gets the buffer dimension at the given index.

Parameters:

Returns:

The buffer size at the given dimension.

​index (Int): The number of dimension to get.

stride(self: Self, index: Int) -> Int

Gets the buffer stride at the given index.

Args:

Returns:

The stride at the given dimension.

​index (Int): The number of dimension to get the stride for.

flatten(self: Self) -> Buffer[type, Dim(), address_space]

Constructs a flattened Buffer counterpart for this NDBuffer.

Constraints:

The buffer must be contiguous.

Returns:

Constructed Buffer object.

make_dims_unknown(self: Self) -> NDBuffer[type, rank, create_unknown[stdlib::builtin::int::Int](), address_space]

Rebinds the NDBuffer to one with unknown shape.

Returns:

The rebound NDBuffer with unknown shape.

bytecount(self: Self) -> Int

Returns the size of the NDBuffer in bytes.

Returns:

The size of the NDBuffer in bytes.

zero(self: Self)

Sets all bytes of the NDBuffer to 0.

Constraints:

The buffer must be contiguous.

tofile(self: Self, path: Path)

Write values to a file.

Args:

​path (Path): Path to the output file.

fill(self: Self, val: SIMD[type, 1])

Assigns val to all elements in the Buffer.

The fill is performed in chunks of size N, where N is the native SIMD
width of type on the system.

Args:

​val (SIMD[type, 1]): The value to store.

static aligned_stack_allocation[alignment: Int]() -> Self

Constructs an NDBuffer instance backed by stack allocated memory space.

Parameters:

Returns:

Constructed NDBuffer with the allocated space.

​alignment (Int): Address alignment requirement for the allocation.

static stack_allocation() -> Self

Constructs an NDBuffer instance backed by stack allocated memory space.

Returns:

Constructed NDBuffer with the allocated space.

prefetch[params: PrefetchOptions](self: Self, *idx: Int)

Prefetches the data at the given index.

Parameters:

Args:

​params (PrefetchOptions): The prefetch configuration.

​*idx (Int): The N-D index of the prefetched location.





url:https://docs.modular.com/mojo/stdlib/buffer/buffer/partial_simd_load
function

partial_simd_load

partial_simd_load[width: Int](storage: DTypePointer[type, address_space], lbound: Int, rbound: Int, pad_value: SIMD[type, 1]) -> SIMD[$1, $0]

Loads a vector with dynamic bound.

Out of bound data will be filled with pad value. Data is valid if
lbound <= idx < rbound for idx from 0 to (simd_width-1). For example:

Parameters:

Args:

Returns:

The SIMD vector loaded and zero-filled.

​width (Int): The system simd vector size.

​storage (DTypePointer[type, address_space]): Pointer to the address to perform load.
​lbound (Int): Lower bound of valid index within simd (inclusive).
​rbound (Int): Upper bound of valid index within simd (non-inclusive).
​pad_value (SIMD[type, 1]): Value to fill for out of bound indices.





url:https://docs.modular.com/mojo/stdlib/buffer/buffer/partial_simd_store
function

partial_simd_store

partial_simd_store[width: Int](storage: DTypePointer[type, address_space], lbound: Int, rbound: Int, data: SIMD[type, width])

Stores a vector with dynamic bound.

Out of bound data will ignored. Data is valid if lbound <= idx < rbound for
idx from 0 to (simd_width-1).

e.g.
addr 0 1 2  3
data 0 0 0  0

Parameters:

Args:

​width (Int): The system simd vector size.

​storage (DTypePointer[type, address_space]): Pointer to the address to perform load.
​lbound (Int): Lower bound of valid index within simd (inclusive).
​rbound (Int): Upper bound of valid index within simd (non-inclusive).
​data (SIMD[type, width]): The vector value to store.





url:https://docs.modular.com/mojo/stdlib/buffer/buffer/prod_dims
function

prod_dims

prod_dims[start_dim: Int, end_dim: Int](x: NDBuffer[type, rank, shape, address_space]) -> Int

Computes the product of a slice of the given buffer's dimensions.

Parameters:

Args:

Returns:

The product of the specified slice of the buffer's dimensions.

​start_dim (Int): The index at which to begin computing the product.
​end_dim (Int): The index at which to stop computing the product.

​x (NDBuffer[type, rank, shape, address_space]): The NDBuffer whose dimensions will be multiplied.





url:https://docs.modular.com/mojo/stdlib/buffer/list/
module

list





url:https://docs.modular.com/mojo/stdlib/buffer/list/Dim
struct

Dim

__init__[type: Intable](value: type) -> Self

Creates a statically-known dimension.

Parameters:

Args:

Returns:

A dimension with a static value.

​type (Intable): The Intable type.

​value (type): The static dimension value.

__init__[type: Intable](value: type) -> Self

Creates a statically-known dimension.

Parameters:

Args:

Returns:

A dimension with a static value.

​type (Intable): The Intable type.

​value (type): The static dimension value.

__init__[type: Intable](value: type) -> Self

Creates a statically-known dimension.

Parameters:

Args:

Returns:

A dimension with a static value.

​type (Intable): The Intable type.

​value (type): The static dimension value.

__bool__(self: Self) -> Bool

Returns True if the dimension has a static value.

Returns:

Whether the dimension has a static value.

__eq__(self: Self, rhs: Self) -> Bool

Compares two dimensions for equality.

Args:

Returns:

True if the dimensions are the same.

​rhs (Self): The other dimension.

__ne__(self: Self, rhs: Self) -> Bool

Compare two dimensions for inequality.

Args:

Returns:

True if they are not equal.

​rhs (Self): The dimension to compare.

__mul__(self: Self, rhs: Self) -> Self

Multiplies two dimensions.

If either are unknown, the result is unknown as well.

Args:

Returns:

The product of the two dimensions.

​rhs (Self): The other dimension.

__floordiv__(self: Self, rhs: Self) -> Self

Divide by the given dimension and round towards negative infinity.

If either are unknown, the result is unknown as well.

Args:

Returns:

The floor division of the two dimensions.

​rhs (Self): The divisor dimension.

__rfloordiv__(self: Self, rhs: Self) -> Self

Divide the given argument by self and round towards negative infinity.

If either are unknown, the result is unknown as well.

Args:

Returns:

The floor of the argument divided by self.

​rhs (Self): The dimension to divide by this Dim.

has_value(self: Self) -> Bool

Returns True if the dimension has a static value.

Returns:

Whether the dimension has a static value.

is_dynamic(self: Self) -> Bool

Returns True if the dimension has a dynamic value.

Returns:

Whether the dimension is dynamic.

get(self: Self) -> Int

Gets the static dimension value.

Returns:

The static dimension value.

is_multiple[alignment: Int](self: Self) -> Bool

Checks if the dimension is aligned.

Parameters:

Returns:

Whether the dimension is aligned.

​alignment (Int): The alignment requirement.





url:https://docs.modular.com/mojo/stdlib/buffer/list/DimList
struct

DimList

__init__(inout self: Self, values: Tuple[Int])

Creates a dimension list from the given list of values.

Args:

​values (Tuple[Int]): The initial dim values list.

__init__(inout self: Self, values: Tuple[Int])

Creates a dimension list from the given list of values.

Args:

​values (Tuple[Int]): The initial dim values list.

__init__(inout self: Self, values: Tuple[Int])

Creates a dimension list from the given list of values.

Args:

​values (Tuple[Int]): The initial dim values list.

get[i: Int](self: Self) -> Int

Gets the static dimension value at a specified index.

Parameters:

Returns:

The static dimension value at the specified index.

​i (Int): The dimension index.

at[i: Int](self: Self) -> Dim

Gets the dimension at a specified index.

Parameters:

Returns:

The dimension at the specified index.

​i (Int): The dimension index.

has_value[i: Int](self: Self) -> Bool

Returns True if the dimension at the given index has a static value.

Parameters:

Returns:

Whether the specified dimension has a static value.

​i (Int): The dimension index.

product[length: Int](self: Self) -> Dim

Computes the product of all the dimensions in the list.

If any are dynamic, the result is a dynamic dimension value.

Parameters:

Returns:

The product of all the dimensions.

​length (Int): The number of elements in the list.

product_range[start: Int, end: Int](self: Self) -> Dim

Computes the product of a range of the dimensions in the list.

If any in the range are dynamic, the result is a dynamic dimension
value.

Parameters:

Returns:

The product of all the dimensions.

​start (Int): The starting index.
​end (Int): The end index.

contains[length: Int](self: Self, value: Dim) -> Bool

Determines whether the dimension list contains a specified dimension value.

Parameters:

Args:

Returns:

True if the list contains a dimension of the specified value.

​length (Int): The number of elements in the list.

​value (Dim): The value to find.

all_known[length: Int](self: Self) -> Bool

Determines whether all dimensions are statically known.

Parameters:

Returns:

True if all dimensions have a static value.

​length (Int): The number of elements in the list.

static create_unknown[length: Int]() -> Self

Creates a dimension list of all dynamic dimension values.

Parameters:

Returns:

A list of all dynamic dimension values.

​length (Int): The number of elements in the list.





url:https://docs.modular.com/mojo/stdlib/builtin/
package

builtin





url:https://docs.modular.com/mojo/stdlib/builtin/anytype/
module

anytype





url:https://docs.modular.com/mojo/stdlib/builtin/anytype/AnyType
trait

AnyType

__del__(owned self: T, /)

Destroy the contained value.

The destructor receives an owned value and is expected to perform any
actions needed to end the lifetime of the object. In the simplest case,
this is nothing, and the language treats the object as being dead at the
end of this function.

__del__(owned self: T, /)

Destroy the contained value.

The destructor receives an owned value and is expected to perform any
actions needed to end the lifetime of the object. In the simplest case,
this is nothing, and the language treats the object as being dead at the
end of this function.

__del__(owned self: T, /)

Destroy the contained value.

The destructor receives an owned value and is expected to perform any
actions needed to end the lifetime of the object. In the simplest case,
this is nothing, and the language treats the object as being dead at the
end of this function.





url:https://docs.modular.com/mojo/stdlib/builtin/bin/
module

bin





url:https://docs.modular.com/mojo/stdlib/builtin/bin/bin
function

bin

bin(b: SIMD[bool, 1], /) -> String

Returns the binary representation of a scalar bool.

Args:

Returns:

The binary string representation of b.

​b (SIMD[bool, 1]): A scalar bool value.





url:https://docs.modular.com/mojo/stdlib/builtin/bool/
module

bool





url:https://docs.modular.com/mojo/stdlib/builtin/bool/Bool
struct

Bool

__init__(value: i1) -> Self

Construct a Bool value given a __mlir_type.i1 value.

Args:

Returns:

The constructed Bool value.

​value (i1): The initial __mlir_type.i1 value.

__init__(value: i1) -> Self

Construct a Bool value given a __mlir_type.i1 value.

Args:

Returns:

The constructed Bool value.

​value (i1): The initial __mlir_type.i1 value.

__init__(value: i1) -> Self

Construct a Bool value given a __mlir_type.i1 value.

Args:

Returns:

The constructed Bool value.

​value (i1): The initial __mlir_type.i1 value.

__bool__(self: Self) -> Self

Convert to Bool.

Returns:

This value.

__neg__(self: Self) -> Int

Defines the unary - operation.

Returns:

0 for -False and -1 for -True.

__invert__(self: Self) -> Self

Inverts the Bool value.

Returns:

True if the object is false and False otherwise.

__lt__(self: Self, rhs: Self) -> Self

Compare this Bool to RHS using less-than comparison.

Args:

Returns:

True if self is False and rhs is True.

​rhs (Self): The rhs of the operation.

__le__(self: Self, rhs: Self) -> Self

Compare this Bool to RHS using less-than-or-equal comparison.

Args:

Returns:

True if self is False and rhs is True or False.

​rhs (Self): The rhs of the operation.

__eq__(self: Self, rhs: Self) -> Self

Compare this Bool to RHS.

Performs an equality comparison between the Bool value and the argument.
This method gets invoked when a user uses the == infix operator.

Args:

Returns:

True if the two values match and False otherwise.

​rhs (Self): The rhs value of the equality statement.

__ne__(self: Self, rhs: Self) -> Self

Compare this Bool to RHS.

Performs a non-equality comparison between the Bool value and the
argument. This method gets invoked when a user uses the != infix
operator.

Args:

Returns:

False if the two values do match and True otherwise.

​rhs (Self): The rhs value of the non-equality statement.

__gt__(self: Self, rhs: Self) -> Self

Compare this Bool to RHS using greater-than comparison.

Args:

Returns:

True if self is True and rhs is False.

​rhs (Self): The rhs of the operation.

__ge__(self: Self, rhs: Self) -> Self

Compare this Bool to RHS using greater-than-or-equal comparison.

Args:

Returns:

True if self is True and rhs is True or False.

​rhs (Self): The rhs of the operation.

__and__(self: Self, rhs: Self) -> Self

Returns self & rhs.

Bitwise and's the Bool value with the argument. This method gets invoked
when a user uses the and infix operator.

Args:

Returns:

self & rhs.

​rhs (Self): The right hand side of the and statement.

__or__(self: Self, rhs: Self) -> Self

Returns self | rhs.

Bitwise or's the Bool value with the argument. This method gets invoked
when a user uses the or infix operator.

Args:

Returns:

self | rhs.

​rhs (Self): The right hand side of the or statement.

__xor__(self: Self, rhs: Self) -> Self

Returns self ^ rhs.

Bitwise Xor's the Bool value with the argument. This method gets invoked
when a user uses the ^ infix operator.

Args:

Returns:

self ^ rhs.

​rhs (Self): The right hand side of the xor statement.

__rand__(self: Self, lhs: Self) -> Self

Returns lhs & self.

Args:

Returns:

lhs & self.

​lhs (Self): The left hand side of the and statement.

__ror__(self: Self, lhs: Self) -> Self

Returns lhs | self.

Args:

Returns:

lhs | self.

​lhs (Self): The left hand side of the or statement.

__rxor__(self: Self, lhs: Self) -> Self

Returns lhs ^ self.

Args:

Returns:

lhs ^ self.

​lhs (Self): The left hand side of the xor statement.

__iand__(inout self: Self, rhs: Self)

Computes self & rhs and store the result in self.

Args:

​rhs (Self): The right hand side of the and statement.

__ixor__(inout self: Self, rhs: Self)

Computes self ^ rhs and stores the result in self.

Args:

​rhs (Self): The right hand side of the xor statement.

__ior__(inout self: Self, rhs: Self)

Computes self | rhs and store the result in self.

Args:

​rhs (Self): The right hand side of the or statement.





url:https://docs.modular.com/mojo/stdlib/builtin/bool/Boolable
trait

Boolable

__bool__(self: T) -> Bool

Get the boolean representation of the value.

Returns:

The boolean representation of the value.

__bool__(self: T) -> Bool

Get the boolean representation of the value.

Returns:

The boolean representation of the value.

__bool__(self: T) -> Bool

Get the boolean representation of the value.

Returns:

The boolean representation of the value.





url:https://docs.modular.com/mojo/stdlib/builtin/bool/all
function

all

all[T: BoolableCollectionElement](list: List[T]) -> Bool

Checks if all elements in the list are truthy.

Parameters:

Args:

Returns:

True if all elements in the list are truthy, False otherwise.

​T (BoolableCollectionElement): The type of elements to check.

​list (List[T]): The list to check.





url:https://docs.modular.com/mojo/stdlib/builtin/bool/any
function

any

any[T: BoolableCollectionElement](list: List[T]) -> Bool

Checks if any element in the list is truthy.

Parameters:

Args:

Returns:

True if any element in the list is truthy, False otherwise.

​T (BoolableCollectionElement): The type of elements to check.

​list (List[T]): The list to check.





url:https://docs.modular.com/mojo/stdlib/builtin/bool/bool-function
function

bool

bool(value: None) -> Bool

Get the bool representation of the None type.

Args:

Returns:

The bool representation of the object.

​value (None): The object to get the bool representation of.





url:https://docs.modular.com/mojo/stdlib/builtin/breakpoint/
module

breakpoint





url:https://docs.modular.com/mojo/stdlib/builtin/breakpoint/breakpoint
function

breakpoint

breakpoint()

Cause an execution trap with the intention of requesting the attention of a debugger.





url:https://docs.modular.com/mojo/stdlib/builtin/builtin_list/
module

builtin_list





url:https://docs.modular.com/mojo/stdlib/builtin/builtin_list/ListLiteral
struct

ListLiteral

__init__(inout self: Self, owned *args: *Ts)

Construct the list literal from the given values.

Args:

​*args (*Ts): The init values.

__init__(inout self: Self, owned *args: *Ts)

Construct the list literal from the given values.

Args:

​*args (*Ts): The init values.

__init__(inout self: Self, owned *args: *Ts)

Construct the list literal from the given values.

Args:

​*args (*Ts): The init values.

__moveinit__(inout self: Self, owned existing: Self)

Move construct the list.

Args:

​existing (Self): The value to move from.

get[i: Int, T: Movable](self: Self) -> ref [*[0,0]] $1

Get a list element at the given index.

Parameters:

Returns:

The element at the given index.

​i (Int): The element index.
​T (Movable): The element type.





url:https://docs.modular.com/mojo/stdlib/builtin/builtin_list/VariadicList
struct

VariadicList

__init__(inout self: Self, *value: type)

Constructs a VariadicList from a variadic list of arguments.

Args:

​*value (type): The variadic argument list to construct the variadic list with.

__init__(inout self: Self, *value: type)

Constructs a VariadicList from a variadic list of arguments.

Args:

​*value (type): The variadic argument list to construct the variadic list with.

__init__(inout self: Self, *value: type)

Constructs a VariadicList from a variadic list of arguments.

Args:

​*value (type): The variadic argument list to construct the variadic list with.

__getitem__(self: Self, idx: Int) -> type

Gets a single element on the variadic list.

Args:

Returns:

The element on the list corresponding to the given index.

​idx (Int): The index of the element to access on the list.





url:https://docs.modular.com/mojo/stdlib/builtin/builtin_list/VariadicListMem
struct

VariadicListMem

__init__(inout self: Self, value: variadic<!lit.ref<:trait<_stdlib::_builtin::_anytype::_AnyType> element_type, mut=elt_is_mutable, lifetime>, borrow_in_mem>)

Constructs a VariadicList from a variadic argument type.

Args:

​value (variadic<!lit.ref<:trait<_stdlib::_builtin::_anytype::_AnyType> element_type, mut=elt_is_mutable, lifetime>, borrow_in_mem>): The variadic argument to construct the list with.

__init__(inout self: Self, value: variadic<!lit.ref<:trait<_stdlib::_builtin::_anytype::_AnyType> element_type, mut=elt_is_mutable, lifetime>, borrow_in_mem>)

Constructs a VariadicList from a variadic argument type.

Args:

​value (variadic<!lit.ref<:trait<_stdlib::_builtin::_anytype::_AnyType> element_type, mut=elt_is_mutable, lifetime>, borrow_in_mem>): The variadic argument to construct the list with.

__init__(inout self: Self, value: variadic<!lit.ref<:trait<_stdlib::_builtin::_anytype::_AnyType> element_type, mut=elt_is_mutable, lifetime>, borrow_in_mem>)

Constructs a VariadicList from a variadic argument type.

Args:

​value (variadic<!lit.ref<:trait<_stdlib::_builtin::_anytype::_AnyType> element_type, mut=elt_is_mutable, lifetime>, borrow_in_mem>): The variadic argument to construct the list with.

__moveinit__(inout self: Self, owned existing: Self)

Moves constructor.

Args:

​existing (Self): The existing VariadicListMem.

__del__(owned self: Self)

Destructor that releases elements if owned.

__getitem__(self: Self, idx: Int) -> ref [{lifetime, (mutcast imm *[0,0])}] element_type

Gets a single element on the variadic list.

Args:

Returns:

A low-level pointer to the element on the list corresponding to the given index.

​idx (Int): The index of the element to access on the list.





url:https://docs.modular.com/mojo/stdlib/builtin/builtin_list/VariadicPack
struct

VariadicPack

__init__(inout self: Self, value: !lit.ref.pack<:variadic<:!lit.anytrait<<_stdlib::_builtin::_anytype::_AnyType>> element_trait> element_types, mut=elt_is_mutable, lifetime>, is_owned: Bool)

Constructs a VariadicPack from the internal representation.

Args:

​value (!lit.ref.pack<:variadic<:!lit.anytrait<<_stdlib::_builtin::_anytype::_AnyType>> element_trait> element_types, mut=elt_is_mutable, lifetime>): The argument to construct the pack with.
​is_owned (Bool): Whether this is an 'owned' pack or 'inout'/'borrowed'.

__init__(inout self: Self, value: !lit.ref.pack<:variadic<:!lit.anytrait<<_stdlib::_builtin::_anytype::_AnyType>> element_trait> element_types, mut=elt_is_mutable, lifetime>, is_owned: Bool)

Constructs a VariadicPack from the internal representation.

Args:

​value (!lit.ref.pack<:variadic<:!lit.anytrait<<_stdlib::_builtin::_anytype::_AnyType>> element_trait> element_types, mut=elt_is_mutable, lifetime>): The argument to construct the pack with.
​is_owned (Bool): Whether this is an 'owned' pack or 'inout'/'borrowed'.

__init__(inout self: Self, value: !lit.ref.pack<:variadic<:!lit.anytrait<<_stdlib::_builtin::_anytype::_AnyType>> element_trait> element_types, mut=elt_is_mutable, lifetime>, is_owned: Bool)

Constructs a VariadicPack from the internal representation.

Args:

​value (!lit.ref.pack<:variadic<:!lit.anytrait<<_stdlib::_builtin::_anytype::_AnyType>> element_trait> element_types, mut=elt_is_mutable, lifetime>): The argument to construct the pack with.
​is_owned (Bool): Whether this is an 'owned' pack or 'inout'/'borrowed'.

__del__(owned self: Self)

Destructor that releases elements if owned.

__getitem__[index: Int](self: Self) -> ref [lifetime] element_types[$0.value]

Return a reference to an element of the pack.

Parameters:

Returns:

A reference to the element.  The Reference's mutability follows the mutability of the pack argument convention.

​index (Int): The element of the pack to return.

each[func: fn[element_trait]($0) capturing -> None](self: Self)

Apply a function to each element of the pack in order.  This applies the specified function (which must be parametric on the element type) to each element of the pack, from the first element to the last, passing in each element as a borrowed argument.

Parameters:

​func (fn[element_trait]($0) capturing -> None): The function to apply to each element.

each_idx[func: fn[Int, element_trait]($1) capturing -> None](self: Self)

Apply a function to each element of the pack in order.  This applies the specified function (which must be parametric on the element type) to each element of the pack, from the first element to the last, passing in each element as a borrowed argument.

Parameters:

​func (fn[Int, element_trait]($1) capturing -> None): The function to apply to each element.





url:https://docs.modular.com/mojo/stdlib/builtin/builtin_slice/
module

builtin_slice





url:https://docs.modular.com/mojo/stdlib/builtin/builtin_slice/Slice
struct

Slice

__init__(inout self: Self, start: Int, end: Int)

Construct slice given the start and end values.

Args:

​start (Int): The start value.
​end (Int): The end value.

__init__(inout self: Self, start: Int, end: Int)

Construct slice given the start and end values.

Args:

​start (Int): The start value.
​end (Int): The end value.

__init__(inout self: Self, start: Int, end: Int)

Construct slice given the start and end values.

Args:

​start (Int): The start value.
​end (Int): The end value.

__getitem__(self: Self, idx: Int) -> Int

Get the slice index.

Args:

Returns:

The slice index.

​idx (Int): The index.

__eq__(self: Self, other: Self) -> Bool

Compare this slice to the other.

Args:

Returns:

True if start, end, and step values of this slice match the corresponding values of the other slice and False otherwise.

​other (Self): The slice to compare to.

__ne__(self: Self, other: Self) -> Bool

Compare this slice to the other.

Args:

Returns:

False if start, end, and step values of this slice match the corresponding values of the other slice and True otherwise.

​other (Self): The slice to compare to.

unsafe_indices(self: Self) -> Int

Return the length of the slice.

Only use this function if start/end is guaranteed to be not None.

Returns:

The length of the slice.





url:https://docs.modular.com/mojo/stdlib/builtin/builtin_slice/slice-function
function

slice

slice(end: Int) -> Slice

Construct slice given the end value.

Args:

Returns:

The constructed slice.

​end (Int): The end value.





url:https://docs.modular.com/mojo/stdlib/builtin/comparable/
module

comparable





url:https://docs.modular.com/mojo/stdlib/builtin/comparable/Comparable
trait

Comparable

__lt__(self: T, rhs: T) -> Bool

Define whether self is less than rhs.

Args:

Returns:

True if self is less than rhs.

​rhs (T): The right hand side of the comparison.

__lt__(self: T, rhs: T) -> Bool

Define whether self is less than rhs.

Args:

Returns:

True if self is less than rhs.

​rhs (T): The right hand side of the comparison.

__lt__(self: T, rhs: T) -> Bool

Define whether self is less than rhs.

Args:

Returns:

True if self is less than rhs.

​rhs (T): The right hand side of the comparison.

__le__(self: T, rhs: T) -> Bool

Define whether self is less than or equal to rhs.

Args:

Returns:

True if self is less than or equal to rhs.

​rhs (T): The right hand side of the comparison.

__eq__(self: T, other: T) -> Bool

Define whether two instances of the object are equal to each other.

Args:

Returns:

True if the instances are equal according to the type's definition of equality, False otherwise.

​other (T): Another instance of the same type.

__ne__(self: T, other: T) -> Bool

Define whether two instances of the object are not equal to each other.

Args:

Returns:

True if the instances are not equal according to the type's definition of equality, False otherwise.

​other (T): Another instance of the same type.

__gt__(self: T, rhs: T) -> Bool

Define whether self is greater than rhs.

Args:

Returns:

True if self is greater than rhs.

​rhs (T): The right hand side of the comparison.

__ge__(self: T, rhs: T) -> Bool

Define whether self is greater than or equal to rhs.

Args:

Returns:

True if self is greater than or equal to rhs.

​rhs (T): The right hand side of the comparison.





url:https://docs.modular.com/mojo/stdlib/builtin/constrained/
module

constrained





url:https://docs.modular.com/mojo/stdlib/builtin/constrained/constrained
function

constrained

constrained[cond: Bool, msg: StringLiteral = "param assertion failed"]()

Compile time checks that the condition is true.

The constrained is similar to static_assert in C++ and is used to
introduce constraints on the enclosing function. In Mojo, the assert places
a constraint on the function. The message is displayed when the assertion
fails.

Parameters:

​cond (Bool): The bool value to assert.
​msg (StringLiteral): The message to display on failure.





url:https://docs.modular.com/mojo/stdlib/builtin/coroutine/
module

coroutine





url:https://docs.modular.com/mojo/stdlib/builtin/coroutine/Coroutine
struct

Coroutine

__init__(handle: !co.routine) -> Self

Construct a coroutine object from a handle.

Args:

Returns:

The constructed coroutine object.

​handle (!co.routine): The init handle.

__init__(handle: !co.routine) -> Self

Construct a coroutine object from a handle.

Args:

Returns:

The constructed coroutine object.

​handle (!co.routine): The init handle.

__init__(handle: !co.routine) -> Self

Construct a coroutine object from a handle.

Args:

Returns:

The constructed coroutine object.

​handle (!co.routine): The init handle.

__del__(owned self: Self)

Destroy the coroutine object.

__await__(self: Self) -> type

Suspends the current coroutine until the coroutine is complete.

Returns:

The coroutine promise.

get(self: Self) -> type

Get the value of the fulfilled coroutine promise.

Returns:

The value of the fulfilled promise.





url:https://docs.modular.com/mojo/stdlib/builtin/coroutine/RaisingCoroutine
struct

RaisingCoroutine

__init__(inout self: Self, handle: !co.routine)

Construct a coroutine object from a handle.

Args:

​handle (!co.routine): The init handle.

__init__(inout self: Self, handle: !co.routine)

Construct a coroutine object from a handle.

Args:

​handle (!co.routine): The init handle.

__init__(inout self: Self, handle: !co.routine)

Construct a coroutine object from a handle.

Args:

​handle (!co.routine): The init handle.

__del__(owned self: Self)

Destroy the coroutine object.

__await__(self: Self) -> type

Suspends the current coroutine until the coroutine is complete.

Returns:

The coroutine promise.

get(self: Self) -> type

Get the value of the fulfilled coroutine promise.

Returns:

The value of the fulfilled promise.





url:https://docs.modular.com/mojo/stdlib/builtin/debug_assert/
module

debug_assert





url:https://docs.modular.com/mojo/stdlib/builtin/debug_assert/debug_assert
function

debug_assert

debug_assert[stringable: Stringable](cond: Bool, msg: stringable)

Asserts that the condition is true.

The debug_assert is similar to assert in C++. It is a no-op in release
builds unless MOJO_ENABLE_ASSERTIONS is defined.

Right now, users of the mojo-sdk must explicitly specify -D MOJO_ENABLE_ASSERTIONS
to enable assertions.  It is not sufficient to compile programs with -debug-level full
for enabling assertions in the library.

Parameters:

Args:

​stringable (Stringable): The type of the message.

​cond (Bool): The bool value to assert.
​msg (stringable): The message to display on failure.





url:https://docs.modular.com/mojo/stdlib/builtin/dtype/
module

dtype





url:https://docs.modular.com/mojo/stdlib/builtin/dtype/DType
struct

DType

__eq__(self: Self, rhs: Self) -> Bool

Compares one DType to another for equality.

Args:

Returns:

True if the DTypes are the same and False otherwise.

​rhs (Self): The DType to compare against.

__eq__(self: Self, rhs: Self) -> Bool

Compares one DType to another for equality.

Args:

Returns:

True if the DTypes are the same and False otherwise.

​rhs (Self): The DType to compare against.

__eq__(self: Self, rhs: Self) -> Bool

Compares one DType to another for equality.

Args:

Returns:

True if the DTypes are the same and False otherwise.

​rhs (Self): The DType to compare against.

__ne__(self: Self, rhs: Self) -> Bool

Compares one DType to another for non-equality.

Args:

Returns:

False if the DTypes are the same and True otherwise.

​rhs (Self): The DType to compare against.

get_value(self: Self) -> dtype

Gets the associated internal kgen.dtype value.

Returns:

The kgen.dtype value.

isa[other: Self](self: Self) -> Bool

Checks if this DType matches the other one, specified as a parameter.

Parameters:

Returns:

True if the DTypes are the same and False otherwise.

​other (Self): The DType to compare against.

is_bool(self: Self) -> Bool

Checks if this DType is Bool.

Returns:

True if the DType is Bool and False otherwise.

is_uint8(self: Self) -> Bool

Checks if this DType is UInt8.

Returns:

True if the DType is UInt8 and False otherwise.

is_int8(self: Self) -> Bool

Checks if this DType is Int8.

Returns:

True if the DType is Int8 and False otherwise.

is_uint16(self: Self) -> Bool

Checks if this DType is UInt16.

Returns:

True if the DType is UInt16 and False otherwise.

is_int16(self: Self) -> Bool

Checks if this DType is Int16.

Returns:

True if the DType is Int16 and False otherwise.

is_uint32(self: Self) -> Bool

Checks if this DType is UInt32.

Returns:

True if the DType is UInt32 and False otherwise.

is_int32(self: Self) -> Bool

Checks if this DType is Int32.

Returns:

True if the DType is Int32 and False otherwise.

is_uint64(self: Self) -> Bool

Checks if this DType is UInt64.

Returns:

True if the DType is UInt64 and False otherwise.

is_int64(self: Self) -> Bool

Checks if this DType is Int64.

Returns:

True if the DType is Int64 and False otherwise.

is_bfloat16(self: Self) -> Bool

Checks if this DType is BFloat16.

Returns:

True if the DType is BFloat16 and False otherwise.

is_float16(self: Self) -> Bool

Checks if this DType is Float16.

Returns:

True if the DType is Float16 and False otherwise.

is_float32(self: Self) -> Bool

Checks if this DType is Float32.

Returns:

True if the DType is Float32 and False otherwise.

is_tensor_float32(self: Self) -> Bool

Checks if this DType is Tensor Float32.

Returns:

True if the DType is Tensor Float32 and False otherwise.

is_float64(self: Self) -> Bool

Checks if this DType is Float64.

Returns:

True if the DType is Float64 and False otherwise.

is_index(self: Self) -> Bool

Checks if this DType is Index.

Returns:

True if the DType is Index and False otherwise.

is_index32(self: Self) -> Bool

Checks if this DType is Index and 32 bit.

Returns:

True if this DType is Index and 32 bit, False otherwise.

is_index64(self: Self) -> Bool

Checks if this DType is Index and 64 bit.

Returns:

True if this DType is Index and 64 bit, False otherwise.

is_address(self: Self) -> Bool

Checks if this DType is Address.

Returns:

True if the DType is Address and False otherwise.

is_unsigned(self: Self) -> Bool

Returns True if the type parameter is unsigned and False otherwise.

Returns:

Returns True if the input type parameter is unsigned.

is_signed(self: Self) -> Bool

Returns True if the type parameter is signed and False otherwise.

Returns:

Returns True if the input type parameter is signed.

is_integral(self: Self) -> Bool

Returns True if the type parameter is an integer and False otherwise.

Returns:

Returns True if the input type parameter is an integer.

is_floating_point(self: Self) -> Bool

Returns True if the type parameter is a floating-point and False otherwise.

Returns:

Returns True if the input type parameter is a floating-point.

is_half_float(self: Self) -> Bool

Returns True if the type is a half-precision floating point type, e.g. either fp16 or bf16.

Returns:

True if the type is a half-precision float, false otherwise..

is_numeric(self: Self) -> Bool

Returns True if the type parameter is numeric (i.e. you can perform arithmetic operations on).

Returns:

Returns True if the input type parameter is either integral or floating-point.

sizeof(self: Self) -> Int

Returns the size in bytes of the current DType.

Returns:

Returns the size in bytes of the current DType.

bitwidth(self: Self) -> Int

Returns the size in bits of the current DType.

Returns:

Returns the size in bits of the current DType.

dispatch_integral[func: fn[DType]() capturing -> None](self: Self)

Dispatches an integral function corresponding to the current DType.

Constraints:

DType must be integral.

Parameters:

​func (fn[DType]() capturing -> None): A parametrized on dtype function to dispatch.

dispatch_floating[func: fn[DType]() capturing -> None](self: Self)

Dispatches a floating-point function corresponding to the current DType.

Constraints:

DType must be floating-point or integral.

Parameters:

​func (fn[DType]() capturing -> None): A parametrized on dtype function to dispatch.

dispatch_arithmetic[func: fn[DType]() capturing -> None](self: Self)

Dispatches a function corresponding to the current DType.

Parameters:

​func (fn[DType]() capturing -> None): A parametrized on dtype function to dispatch.





url:https://docs.modular.com/mojo/stdlib/builtin/equality_comparable/
module

equality_comparable





url:https://docs.modular.com/mojo/stdlib/builtin/equality_comparable/EqualityComparable
trait

EqualityComparable

__eq__(self: T, other: T) -> Bool

Define whether two instances of the object are equal to each other.

Args:

Returns:

True if the instances are equal according to the type's definition of equality, False otherwise.

​other (T): Another instance of the same type.

__eq__(self: T, other: T) -> Bool

Define whether two instances of the object are equal to each other.

Args:

Returns:

True if the instances are equal according to the type's definition of equality, False otherwise.

​other (T): Another instance of the same type.

__eq__(self: T, other: T) -> Bool

Define whether two instances of the object are equal to each other.

Args:

Returns:

True if the instances are equal according to the type's definition of equality, False otherwise.

​other (T): Another instance of the same type.

__ne__(self: T, other: T) -> Bool

Define whether two instances of the object are not equal to each other.

Args:

Returns:

True if the instances are not equal according to the type's definition of equality, False otherwise.

​other (T): Another instance of the same type.





url:https://docs.modular.com/mojo/stdlib/builtin/error/
module

error





url:https://docs.modular.com/mojo/stdlib/builtin/error/Error
struct

Error

__init__() -> Self

Default constructor.

Returns:

The constructed Error object.

__init__() -> Self

Default constructor.

Returns:

The constructed Error object.

__init__() -> Self

Default constructor.

Returns:

The constructed Error object.

__copyinit__(existing: Self) -> Self

Creates a deep copy of an existing error.

Returns:

The copy of the original error.

__del__(owned self: Self)

Releases memory if allocated.

__bool__(self: Self) -> Bool

Returns True if the error is set and false otherwise.

Returns:

True if the error object contains a value and False otherwise.





url:https://docs.modular.com/mojo/stdlib/builtin/file/
module

file





url:https://docs.modular.com/mojo/stdlib/builtin/file/FileHandle
struct

FileHandle

__init__(inout self: Self)

Default constructor.

__init__(inout self: Self)

Default constructor.

__init__(inout self: Self)

Default constructor.

__moveinit__(inout self: Self, owned existing: Self)

Moves constructor for the file handle.

Args:

​existing (Self): The existing file handle.

__del__(owned self: Self)

Closes the file handle.

close(inout self: Self)

Closes the file handle.

read(self: Self, size: SIMD[int64, 1] = -1) -> String

Reads data from a file and sets the file handle seek position. If size is left as the default of -1, it will read to the end of the file. Setting size to a number larger than what's in the file will set String.size to the total number of bytes, and read all the data.

Examples:

Read the entire file into a String:

Read the first 8 bytes, skip 2 bytes, and then read the next 8 bytes:

Read the last 8 bytes in the file, then the first 8 bytes

.

Args:

Returns:

The contents of the file.

Raises:

An error if this file handle is invalid, or if the file read returned a failure.

​size (SIMD[int64, 1]): Requested number of bytes to read (Default: -1 = EOF).

read_bytes(self: Self, size: SIMD[int64, 1] = -1) -> List[SIMD[uint8, 1]]

Reads data from a file and sets the file handle seek position. If size is left as default of -1, it will read to the end of the file. Setting size to a number larger than what's in the file will be handled and set the List.size to the total number of bytes in the file.

Examples:

Reading the entire file into a List[Int8]:

Reading the first 8 bytes, skipping 2 bytes, and then reading the next
8 bytes:

Reading the last 8 bytes in the file, then the first 8 bytes:

.

Args:

Returns:

The contents of the file.

Raises:

An error if this file handle is invalid, or if the file read returned a failure.

​size (SIMD[int64, 1]): Requested number of bytes to read (Default: -1 = EOF).

seek(self: Self, offset: SIMD[uint64, 1], whence: SIMD[uint8, 1] = 0) -> SIMD[uint64, 1]

Seeks to the given offset in the file.

Examples:

Skip 32 bytes from the current read position:

Start from 32 bytes from the end of the file:

.

Args:

Returns:

The resulting byte offset from the start of the file.

Raises:

An error if this file handle is invalid, or if file seek returned a failure.

​offset (SIMD[uint64, 1]): The byte offset to seek to.
​whence (SIMD[uint8, 1]): The reference point for the offset: os.SEEK_SET = 0: start of file (Default). os.SEEK_CUR = 1: current position. os.SEEK_END = 2: end of file.

write(self: Self, data: String)

Write the data to the file.

Args:

​data (String): The data to write to the file.





url:https://docs.modular.com/mojo/stdlib/builtin/file/open
function

open

open(path: String, mode: String) -> FileHandle

Opens the file specified by path using the mode provided, returning a FileHandle.

Args:

Returns:

A file handle.

​path (String): The path to the file to open.
​mode (String): The mode to open the file in.





url:https://docs.modular.com/mojo/stdlib/builtin/file_descriptor/
module

file_descriptor





url:https://docs.modular.com/mojo/stdlib/builtin/file_descriptor/FileDescriptor
struct

FileDescriptor

__init__(inout self: Self)

Default constructor to stdout.

__init__(inout self: Self)

Default constructor to stdout.

__init__(inout self: Self)

Default constructor to stdout.





url:https://docs.modular.com/mojo/stdlib/builtin/float_literal/
module

float_literal





url:https://docs.modular.com/mojo/stdlib/builtin/float_literal/FloatLiteral
struct

FloatLiteral

__init__(inout self: Self, value: !kgen.float_literal)

Create a FloatLiteral value from a kgen.float_literal value.

Args:

​value (!kgen.float_literal): The float value.

__init__(inout self: Self, value: !kgen.float_literal)

Create a FloatLiteral value from a kgen.float_literal value.

Args:

​value (!kgen.float_literal): The float value.

__init__(inout self: Self, value: !kgen.float_literal)

Create a FloatLiteral value from a kgen.float_literal value.

Args:

​value (!kgen.float_literal): The float value.

__bool__(self: Self) -> Bool

A FloatLiteral value is true if it is non-zero.

Returns:

True if non-zero.

__neg__(self: Self) -> Self

Return the negation of the FloatLiteral value.

Returns:

The negated FloatLiteral value.

__lt__(self: Self, rhs: Self) -> Bool

Less than comparison.

Args:

Returns:

True if this value is less than rhs.

​rhs (Self): The value to compare.

__le__(self: Self, rhs: Self) -> Bool

Less than or equal to comparison.

Args:

Returns:

True if this value is less than or equal to rhs.

​rhs (Self): The value to compare.

__eq__(self: Self, rhs: Self) -> Bool

Compare for equality.

Args:

Returns:

True if they are equal.

​rhs (Self): The value to compare.

__ne__(self: Self, rhs: Self) -> Bool

Compare for inequality.

Args:

Returns:

True if they are not equal.

​rhs (Self): The value to compare.

__gt__(self: Self, rhs: Self) -> Bool

Greater than comparison.

Args:

Returns:

True if this value is greater than rhs.

​rhs (Self): The value to compare.

__ge__(self: Self, rhs: Self) -> Bool

Greater than or equal to comparison.

Args:

Returns:

True if this value is greater than or equal to rhs.

​rhs (Self): The value to compare.

__add__(self: Self, rhs: Self) -> Self

Add two FloatLiterals.

Args:

Returns:

The sum of the two values.

​rhs (Self): The value to add.

__sub__(self: Self, rhs: Self) -> Self

Subtract two FloatLiterals.

Args:

Returns:

The difference of the two values.

​rhs (Self): The value to subtract.

__mul__(self: Self, rhs: Self) -> Self

Multiply two FloatLiterals.

Args:

Returns:

The product of the two values.

​rhs (Self): The value to multiply.

__truediv__(self: Self, rhs: Self) -> Self

Divide two FloatLiterals.

Args:

Returns:

The quotient of the two values.

​rhs (Self): The value to divide.

__floordiv__(self: Self, rhs: Self) -> Self

Returns self divided by rhs, rounded down to the nearest integer.

Args:

Returns:

floor(self / rhs) value.

​rhs (Self): The divisor value.

__mod__(self: Self, rhs: Self) -> Self

Return the remainder of self divided by rhs.

Args:

Returns:

The remainder of dividing self by rhs.

​rhs (Self): The value to divide on.

__radd__(self: Self, rhs: Self) -> Self

Reversed addition operator.

Args:

Returns:

The sum of this and the given value.

​rhs (Self): The value to add.

__rsub__(self: Self, rhs: Self) -> Self

Reversed subtraction operator.

Args:

Returns:

The result of subtracting this from the given value.

​rhs (Self): The value to subtract from.

__rmul__(self: Self, rhs: Self) -> Self

Reversed multiplication operator.

Args:

Returns:

The product of the given number and this.

​rhs (Self): The value to multiply.

__rtruediv__(self: Self, rhs: Self) -> Self

Reversed division.

Args:

Returns:

The result of dividing the given value by this.

​rhs (Self): The value to be divided by this.

__rfloordiv__(self: Self, rhs: Self) -> Self

Returns rhs divided by self, rounded down to the nearest integer.

Args:

Returns:

floor(rhs / self) value.

​rhs (Self): The value to be divided by self.

__iadd__(inout self: Self, rhs: Self)

In-place addition operator.

Args:

​rhs (Self): The value to add.

__isub__(inout self: Self, rhs: Self)

In-place subtraction operator.

Args:

​rhs (Self): The value to subtract.

__imul__(inout self: Self, rhs: Self)

In-place multiplication operator.

Args:

​rhs (Self): The value to multiply.

__itruediv__(inout self: Self, rhs: Self)

In-place division.

Args:

​rhs (Self): The value to divide.

is_nan(self: Self) -> Bool

Return whether the FloatLiteral is nan.

Since nan == nan is False, this provides a way to check for nan-ness.

Returns:

True, if the value is nan, False otherwise.

is_neg_zero(self: Self) -> Bool

Return whether the FloatLiteral is negative zero.

Since FloatLiteral.negative_zero == 0.0 is True, this provides a way
to check if the FloatLiteral is negative zero.

Returns:

True, if the value is negative zero, False otherwise.





url:https://docs.modular.com/mojo/stdlib/builtin/format_int/
module

format_int





url:https://docs.modular.com/mojo/stdlib/builtin/format_int/bin
function

bin

bin[type: DType](num: SIMD[type, 1], prefix: StringLiteral = "0b", /) -> String

Return the binary string representation an integral value.

Parameters:

Args:

Returns:

The binary string representation of num.

​type (DType): The data type of the integral scalar.

​num (SIMD[type, 1]): An integral scalar value.
​prefix (StringLiteral): The prefix of the formatted int.





url:https://docs.modular.com/mojo/stdlib/builtin/format_int/hex
function

hex

hex[type: DType](value: SIMD[type, 1], prefix: StringLiteral = "0x", /) -> String

Returns the hex string representation of the given integer.

The hexadecimal representation is a base-16 encoding of the integer value.

The returned string will be prefixed with "0x" to indicate that the
subsequent digits are hex.

Parameters:

Args:

Returns:

A string containing the hex representation of the given integer.

​type (DType): The type of the Scalar to represent in hexadecimal.

​value (SIMD[type, 1]): The integer value to format.
​prefix (StringLiteral): The prefix of the formatted int.





url:https://docs.modular.com/mojo/stdlib/builtin/hash/
module

hash





url:https://docs.modular.com/mojo/stdlib/builtin/hash/Hashable
trait

Hashable





url:https://docs.modular.com/mojo/stdlib/builtin/hash/hash
function

hash

hash[T: Hashable](hashable: T) -> Int

Hash a Hashable type using its underlying hash implementation.

Parameters:

Args:

Returns:

A 64-bit integer hash based on the underlying implementation.

​T (Hashable): Any Hashable type.

​hashable (T): The input data to hash.





url:https://docs.modular.com/mojo/stdlib/builtin/int/
module

int





url:https://docs.modular.com/mojo/stdlib/builtin/int/Indexer
trait

Indexer





url:https://docs.modular.com/mojo/stdlib/builtin/int/Int
struct

Int

__init__(inout self: Self)

Default constructor that produces zero.

__init__(inout self: Self)

Default constructor that produces zero.

__init__(inout self: Self)

Default constructor that produces zero.

__bool__(self: Self) -> Bool

Convert this Int to Bool.

Returns:

False Bool value if the value is equal to 0 and True otherwise.

__neg__(self: Self) -> Self

Return -self.

Returns:

The -self value.

__pos__(self: Self) -> Self

Return +self.

Returns:

The +self value.

__invert__(self: Self) -> Self

Return ~self.

Returns:

The ~self value.

__lt__(self: Self, rhs: Self) -> Bool

Compare this Int to the RHS using LT comparison.

Args:

Returns:

True if this Int is less-than the RHS Int and False otherwise.

​rhs (Self): The other Int to compare against.

__le__(self: Self, rhs: Self) -> Bool

Compare this Int to the RHS using LE comparison.

Args:

Returns:

True if this Int is less-or-equal than the RHS Int and False otherwise.

​rhs (Self): The other Int to compare against.

__eq__(self: Self, rhs: Self) -> Bool

Compare this Int to the RHS using EQ comparison.

Args:

Returns:

True if this Int is equal to the RHS Int and False otherwise.

​rhs (Self): The other Int to compare against.

__ne__(self: Self, rhs: Self) -> Bool

Compare this Int to the RHS using NE comparison.

Args:

Returns:

True if this Int is non-equal to the RHS Int and False otherwise.

​rhs (Self): The other Int to compare against.

__gt__(self: Self, rhs: Self) -> Bool

Compare this Int to the RHS using GT comparison.

Args:

Returns:

True if this Int is greater-than the RHS Int and False otherwise.

​rhs (Self): The other Int to compare against.

__ge__(self: Self, rhs: Self) -> Bool

Compare this Int to the RHS using GE comparison.

Args:

Returns:

True if this Int is greater-or-equal than the RHS Int and False otherwise.

​rhs (Self): The other Int to compare against.

__add__(self: Self, rhs: Self) -> Self

Return self + rhs.

Args:

Returns:

self + rhs value.

​rhs (Self): The value to add.

__sub__(self: Self, rhs: Self) -> Self

Return self - rhs.

Args:

Returns:

self - rhs value.

​rhs (Self): The value to subtract.

__mul__(self: Self, rhs: Self) -> Self

Return self * rhs.

Args:

Returns:

self * rhs value.

​rhs (Self): The value to multiply with.

__truediv__(self: Self, rhs: Self) -> SIMD[float64, 1]

Return the floating point division of self and rhs.

Args:

Returns:

float(self)/float(rhs) value.

​rhs (Self): The value to divide on.

__floordiv__(self: Self, rhs: Self) -> Self

Return the division of self and rhs rounded down to the nearest integer.

Args:

Returns:

floor(self/rhs) value.

​rhs (Self): The value to divide on.

__mod__(self: Self, rhs: Self) -> Self

Return the remainder of self divided by rhs.

Args:

Returns:

The remainder of dividing self by rhs.

​rhs (Self): The value to divide on.

__pow__(self: Self, exp: Self) -> Self

Return the value raised to the power of the given exponent.

Computes the power of an integer using the Russian Peasant Method.

Args:

Returns:

The value of self raised to the power of exp.

​exp (Self): The exponent value.

__lshift__(self: Self, rhs: Self) -> Self

Return self << rhs.

Args:

Returns:

self << rhs.

​rhs (Self): The value to shift with.

__rshift__(self: Self, rhs: Self) -> Self

Return self >> rhs.

Args:

Returns:

self >> rhs.

​rhs (Self): The value to shift with.

__and__(self: Self, rhs: Self) -> Self

Return self & rhs.

Args:

Returns:

self & rhs.

​rhs (Self): The RHS value.

__or__(self: Self, rhs: Self) -> Self

Return self | rhs.

Args:

Returns:

self | rhs.

​rhs (Self): The RHS value.

__xor__(self: Self, rhs: Self) -> Self

Return self ^ rhs.

Args:

Returns:

self ^ rhs.

​rhs (Self): The RHS value.

__radd__(self: Self, value: Self) -> Self

Return value + self.

Args:

Returns:

value + self.

​value (Self): The other value.

__rsub__(self: Self, value: Self) -> Self

Return value - self.

Args:

Returns:

value - self.

​value (Self): The other value.

__rmul__(self: Self, value: Self) -> Self

Return value * self.

Args:

Returns:

value * self.

​value (Self): The other value.

__rfloordiv__(self: Self, value: Self) -> Self

Return value // self.

Args:

Returns:

value // self.

​value (Self): The other value.

__rmod__(self: Self, value: Self) -> Self

Return value % self.

Args:

Returns:

value % self.

​value (Self): The other value.

__rpow__(self: Self, value: Self) -> Self

Return pow(value,self).

Args:

Returns:

pow(value,self).

​value (Self): The other value.

__rlshift__(self: Self, value: Self) -> Self

Return value << self.

Args:

Returns:

value << self.

​value (Self): The other value.

__rrshift__(self: Self, value: Self) -> Self

Return value >> self.

Args:

Returns:

value >> self.

​value (Self): The other value.

__rand__(self: Self, value: Self) -> Self

Return value & self.

Args:

Returns:

value & self.

​value (Self): The other value.

__ror__(self: Self, value: Self) -> Self

Return value | self.

Args:

Returns:

value | self.

​value (Self): The other value.

__rxor__(self: Self, value: Self) -> Self

Return value ^ self.

Args:

Returns:

value ^ self.

​value (Self): The other value.

__iadd__(inout self: Self, rhs: Self)

Compute self + rhs and save the result in self.

Args:

​rhs (Self): The RHS value.

__isub__(inout self: Self, rhs: Self)

Compute self - rhs and save the result in self.

Args:

​rhs (Self): The RHS value.

__imul__(inout self: Self, rhs: Self)

Compute self*rhs and save the result in self.

Args:

​rhs (Self): The RHS value.

__itruediv__(inout self: Self, rhs: Self)

Compute self / rhs, convert to int, and save the result in self.

Since floor(self / rhs) is equivalent to self // rhs, this yields
the same as __ifloordiv__.

Args:

​rhs (Self): The RHS value.

__ifloordiv__(inout self: Self, rhs: Self)

Compute self // rhs and save the result in self.

Args:

​rhs (Self): The RHS value.

__imod__(inout self: Self, rhs: Self)

Compute self % rhs and save the result in self.

Args:

​rhs (Self): The RHS value.

__ipow__(inout self: Self, rhs: Self)

Compute pow(self, rhs) and save the result in self.

Args:

​rhs (Self): The RHS value.

__ilshift__(inout self: Self, rhs: Self)

Compute self << rhs and save the result in self.

Args:

​rhs (Self): The RHS value.

__irshift__(inout self: Self, rhs: Self)

Compute self >> rhs and save the result in self.

Args:

​rhs (Self): The RHS value.

__iand__(inout self: Self, rhs: Self)

Compute self & rhs and save the result in self.

Args:

​rhs (Self): The RHS value.

__ixor__(inout self: Self, rhs: Self)

Compute self ^ rhs and save the result in self.

Args:

​rhs (Self): The RHS value.

__ior__(inout self: Self, rhs: Self)

Compute self|rhs and save the result in self.

Args:

​rhs (Self): The RHS value.

format_to(self: Self, inout writer: Formatter)

Formats this integer to the provided formatter.

Args:

​writer (Formatter): The formatter to write to.





url:https://docs.modular.com/mojo/stdlib/builtin/int/Intable
trait

Intable





url:https://docs.modular.com/mojo/stdlib/builtin/int/IntableRaising
trait

IntableRaising





url:https://docs.modular.com/mojo/stdlib/builtin/int/index-function
function

index

index[T: Indexer](idx: T, /) -> Int

Returns the value of __index__ for the given value.

Parameters:

Args:

Returns:

An Int respresenting the index value.

​T (Indexer): A type conforming to the Indexer trait.

​idx (T): The value.





url:https://docs.modular.com/mojo/stdlib/builtin/int/int-function
function

int

int[T: Intable](value: T) -> Int

Get the Int representation of the value.

Parameters:

Args:

Returns:

The integral representation of the value.

​T (Intable): The Intable type.

​value (T): The object to get the integral representation of.





url:https://docs.modular.com/mojo/stdlib/builtin/int_literal/
module

int_literal





url:https://docs.modular.com/mojo/stdlib/builtin/int_literal/IntLiteral
struct

IntLiteral

__init__(inout self: Self)

Default constructor.

__init__(inout self: Self)

Default constructor.

__init__(inout self: Self)

Default constructor.

__bool__(self: Self) -> Bool

Convert this IntLiteral to Bool.

Returns:

False Bool value if the value is equal to 0 and True otherwise.

__neg__(self: Self) -> Self

Return -self.

Returns:

The -self value.

__pos__(self: Self) -> Self

Return +self.

Returns:

The +self value.

__invert__(self: Self) -> Self

Return ~self.

Returns:

The ~self value.

__lt__(self: Self, rhs: Self) -> Bool

Compare this IntLiteral to the RHS using LT comparison.

Args:

Returns:

True if this IntLiteral is less-than the RHS IntLiteral and False otherwise.

​rhs (Self): The other IntLiteral to compare against.

__le__(self: Self, rhs: Self) -> Bool

Compare this IntLiteral to the RHS using LE comparison.

Args:

Returns:

True if this IntLiteral is less-or-equal than the RHS IntLiteral and False otherwise.

​rhs (Self): The other IntLiteral to compare against.

__eq__(self: Self, rhs: Self) -> Bool

Compare this IntLiteral to the RHS using EQ comparison.

Args:

Returns:

True if this IntLiteral is equal to the RHS IntLiteral and False otherwise.

​rhs (Self): The other IntLiteral to compare against.

__ne__(self: Self, rhs: Self) -> Bool

Compare this IntLiteral to the RHS using NE comparison.

Args:

Returns:

True if this IntLiteral is non-equal to the RHS IntLiteral and False otherwise.

​rhs (Self): The other IntLiteral to compare against.

__gt__(self: Self, rhs: Self) -> Bool

Compare this IntLiteral to the RHS using GT comparison.

Args:

Returns:

True if this IntLiteral is greater-than the RHS IntLiteral and False otherwise.

​rhs (Self): The other IntLiteral to compare against.

__ge__(self: Self, rhs: Self) -> Bool

Compare this IntLiteral to the RHS using GE comparison.

Args:

Returns:

True if this IntLiteral is greater-or-equal than the RHS IntLiteral and False otherwise.

​rhs (Self): The other IntLiteral to compare against.

__add__(self: Self, rhs: Self) -> Self

Return self + rhs.

Args:

Returns:

self + rhs value.

​rhs (Self): The value to add.

__sub__(self: Self, rhs: Self) -> Self

Return self - rhs.

Args:

Returns:

self - rhs value.

​rhs (Self): The value to subtract.

__mul__(self: Self, rhs: Self) -> Self

Return self * rhs.

Args:

Returns:

self * rhs value.

​rhs (Self): The value to multiply with.

__floordiv__(self: Self, rhs: Self) -> Self

Return self // rhs.

Args:

Returns:

self // rhs value.

​rhs (Self): The value to divide with.

__mod__(self: Self, rhs: Self) -> Self

Return the remainder of self divided by rhs.

Args:

Returns:

The remainder of dividing self by rhs.

​rhs (Self): The value to divide on.

__lshift__(self: Self, rhs: Self) -> Self

Return self << rhs.

Args:

Returns:

self << rhs.

​rhs (Self): The value to shift with.

__rshift__(self: Self, rhs: Self) -> Self

Return self >> rhs.

Args:

Returns:

self >> rhs.

​rhs (Self): The value to shift with.

__and__(self: Self, rhs: Self) -> Self

Return self & rhs.

Args:

Returns:

self & rhs.

​rhs (Self): The RHS value.

__or__(self: Self, rhs: Self) -> Self

Return self | rhs.

Args:

Returns:

self | rhs.

​rhs (Self): The RHS value.

__xor__(self: Self, rhs: Self) -> Self

Return self ^ rhs.

Args:

Returns:

self ^ rhs.

​rhs (Self): The RHS value.

__radd__(self: Self, value: Self) -> Self

Return value + self.

Args:

Returns:

value + self.

​value (Self): The other value.

__rsub__(self: Self, value: Self) -> Self

Return value - self.

Args:

Returns:

value - self.

​value (Self): The other value.

__rmul__(self: Self, value: Self) -> Self

Return value * self.

Args:

Returns:

value * self.

​value (Self): The other value.

__rfloordiv__(self: Self, value: Self) -> Self

Return value // self.

Args:

Returns:

value // self.

​value (Self): The other value.

__rlshift__(self: Self, value: Self) -> Self

Return value << self.

Args:

Returns:

value << self.

​value (Self): The other value.

__rrshift__(self: Self, value: Self) -> Self

Return value >> self.

Args:

Returns:

value >> self.

​value (Self): The other value.

__rand__(self: Self, value: Self) -> Self

Return value & self.

Args:

Returns:

value & self.

​value (Self): The other value.

__ror__(self: Self, value: Self) -> Self

Return value | self.

Args:

Returns:

value | self.

​value (Self): The other value.

__rxor__(self: Self, value: Self) -> Self

Return value ^ self.

Args:

Returns:

value ^ self.

​value (Self): The other value.

__iadd__(inout self: Self, rhs: Self)

Compute self + rhs and save the result in self.

Args:

​rhs (Self): The RHS value.

__isub__(inout self: Self, rhs: Self)

Compute self - rhs and save the result in self.

Args:

​rhs (Self): The RHS value.

__imul__(inout self: Self, rhs: Self)

Compute self*rhs and save the result in self.

Args:

​rhs (Self): The RHS value.

__ifloordiv__(inout self: Self, rhs: Self)

Compute self//rhs and save the result in self.

Args:

​rhs (Self): The RHS value.

__ilshift__(inout self: Self, rhs: Self)

Compute self << rhs and save the result in self.

Args:

​rhs (Self): The RHS value.

__irshift__(inout self: Self, rhs: Self)

Compute self >> rhs and save the result in self.

Args:

​rhs (Self): The RHS value.

__iand__(inout self: Self, rhs: Self)

Compute self & rhs and save the result in self.

Args:

​rhs (Self): The RHS value.

__ixor__(inout self: Self, rhs: Self)

Compute self ^ rhs and save the result in self.

Args:

​rhs (Self): The RHS value.

__ior__(inout self: Self, rhs: Self)

Compute self|rhs and save the result in self.

Args:

​rhs (Self): The RHS value.





url:https://docs.modular.com/mojo/stdlib/builtin/io/
module

io





url:https://docs.modular.com/mojo/stdlib/builtin/io/print
function

print

print[*Ts: Stringable](*values: *Ts, *, flush: Bool = 0, file: FileDescriptor = 1)

Prints elements to the text stream. Each element is separated by a whitespace and followed by a newline character.

Parameters:

Args:

​*Ts (Stringable): The elements types.

​*values (*Ts): The elements to print.
​flush (Bool): If set to true, then the stream is forcibly flushed.
​file (FileDescriptor): The output stream.





url:https://docs.modular.com/mojo/stdlib/builtin/len/
module

len





url:https://docs.modular.com/mojo/stdlib/builtin/len/Sized
trait

Sized





url:https://docs.modular.com/mojo/stdlib/builtin/len/SizedRaising
trait

SizedRaising





url:https://docs.modular.com/mojo/stdlib/builtin/len/len
function

len

len[T: Sized](value: T) -> Int

Get the length of a value.

Parameters:

Args:

Returns:

The length of the object.

​T (Sized): The Sized type.

​value (T): The object to get the length of.





url:https://docs.modular.com/mojo/stdlib/builtin/math/
module

math





url:https://docs.modular.com/mojo/stdlib/builtin/math/Absable
trait

Absable





url:https://docs.modular.com/mojo/stdlib/builtin/math/Powable
trait

Powable

__pow__(self: T, exp: T) -> T

Return the value raised to the power of the given exponent.

Args:

Returns:

The value of self raised to the power of exp.

​exp (T): The exponent value.

__pow__(self: T, exp: T) -> T

Return the value raised to the power of the given exponent.

Args:

Returns:

The value of self raised to the power of exp.

​exp (T): The exponent value.

__pow__(self: T, exp: T) -> T

Return the value raised to the power of the given exponent.

Args:

Returns:

The value of self raised to the power of exp.

​exp (T): The exponent value.





url:https://docs.modular.com/mojo/stdlib/builtin/math/Roundable
trait

Roundable





url:https://docs.modular.com/mojo/stdlib/builtin/math/abs
function

abs

abs[T: Absable](value: T) -> $0

Get the absolute value of the given object.

Parameters:

Args:

Returns:

The absolute value of the object.

​T (Absable): The type conforming to Absable.

​value (T): The object to get the absolute value of.





url:https://docs.modular.com/mojo/stdlib/builtin/math/divmod
function

divmod

divmod(numerator: Int, denominator: Int) -> Tuple[Int, Int]

Performs integer division and returns the quotient and the remainder.

Currently supported only for integers. Support for more standard library
types like Int8, Int16... is planned.

This method calls a.__divmod__(b), thus, the actual implementation of
divmod should go in the __divmod__ method of the struct of a.

Args:

Returns:

A Tuple containing the quotient and the remainder.

​numerator (Int): The dividend.
​denominator (Int): The divisor.





url:https://docs.modular.com/mojo/stdlib/builtin/math/max
function

max

max(x: Int, y: Int) -> Int

Gets the maximum of two integers.

Args:

Returns:

Maximum of x and y.

​x (Int): Integer input to max.
​y (Int): Integer input to max.





url:https://docs.modular.com/mojo/stdlib/builtin/math/min
function

min

min(x: Int, y: Int) -> Int

Gets the minimum of two integers.

Args:

Returns:

Minimum of x and y.

​x (Int): Integer input to max.
​y (Int): Integer input to max.





url:https://docs.modular.com/mojo/stdlib/builtin/math/pow
function

pow

pow[T: Powable](base: T, exp: T) -> $0

Computes the base raised to the power of the exp.

Parameters:

Args:

Returns:

The base raised to the power of the exp.

​T (Powable): A type conforming to the Powable trait.

​base (T): The base of the power operation.
​exp (T): The exponent of the power operation.





url:https://docs.modular.com/mojo/stdlib/builtin/math/round
function

round

round[T: Roundable](value: T) -> $0

Get the rounded value of the given object.

Parameters:

Args:

Returns:

The rounded value of the object.

​T (Roundable): The type conforming to Roundable.

​value (T): The object to get the rounded value of.





url:https://docs.modular.com/mojo/stdlib/builtin/object/
module

object





url:https://docs.modular.com/mojo/stdlib/builtin/object/Attr
struct

Attr

__init__(inout self: Self, key: StringLiteral, owned value: object)

Initializes the attribute with a key and value.

Args:

​key (StringLiteral): The string literal key.
​value (object): The object value of the attribute.

__init__(inout self: Self, key: StringLiteral, owned value: object)

Initializes the attribute with a key and value.

Args:

​key (StringLiteral): The string literal key.
​value (object): The object value of the attribute.

__init__(inout self: Self, key: StringLiteral, owned value: object)

Initializes the attribute with a key and value.

Args:

​key (StringLiteral): The string literal key.
​value (object): The object value of the attribute.





url:https://docs.modular.com/mojo/stdlib/builtin/object/object
struct

object

__init__(inout self: Self)

Initializes the object with a None value.

__init__(inout self: Self)

Initializes the object with a None value.

__init__(inout self: Self)

Initializes the object with a None value.

__copyinit__(inout self: Self, existing: Self)

Copies the object. This clones the underlying string value and increases the refcount of lists or dictionaries.

Args:

​existing (Self): The object to copy.

__moveinit__(inout self: Self, owned existing: Self)

Move the value of an object.

Args:

​existing (Self): The object to move.

__del__(owned self: Self)

Delete the object and release any owned memory.

__bool__(self: Self) -> Bool

Performs conversion to bool according to Python semantics. Integers and floats are true if they are non-zero, and strings and lists are true if they are non-empty.

Returns:

Whether the object is considered true.

__getitem__(self: Self, i: Self) -> Self

Gets the i-th item from the object. This is only valid for strings, lists, and dictionaries.

Args:

Returns:

The value at the index or key.

​i (Self): The string or list index, or dictionary key.

__setitem__(self: Self, i: Self, value: Self)

Sets the i-th item in the object. This is only valid for strings, lists, and dictionaries.

Args:

​i (Self): The string or list index, or dictionary key.
​value (Self): The value to set.

__neg__(self: Self) -> Self

Negation operator. Only valid for bool, int, and float types. Negation on any bool value converts it to an integer.

Returns:

The negative of the current value.

__invert__(self: Self) -> Self

Invert value operator. This is only valid for bool and int values.

Returns:

The inverted value.

__lt__(self: Self, rhs: Self) -> Self

Less-than comparator. This lexicographically compares strings and lists.

Args:

Returns:

True if the object is less than the right hard argument.

​rhs (Self): Right hand value.

__le__(self: Self, rhs: Self) -> Self

Less-than-or-equal to comparator. This lexicographically compares strings and lists.

Args:

Returns:

True if the object is less than or equal to the right hard argument.

​rhs (Self): Right hand value.

__eq__(self: Self, rhs: Self) -> Self

Equality comparator. This compares the elements of strings and lists.

Args:

Returns:

True if the objects are equal.

​rhs (Self): Right hand value.

__ne__(self: Self, rhs: Self) -> Self

Inequality comparator. This compares the elements of strings and lists.

Args:

Returns:

True if the objects are not equal.

​rhs (Self): Right hand value.

__gt__(self: Self, rhs: Self) -> Self

Greater-than comparator. This lexicographically compares the elements of strings and lists.

Args:

Returns:

True if the left hand value is greater.

​rhs (Self): Right hand value.

__ge__(self: Self, rhs: Self) -> Self

Greater-than-or-equal-to comparator. This lexicographically compares the elements of strings and lists.

Args:

Returns:

True if the left hand value is greater than or equal to the right hand value.

​rhs (Self): Right hand value.

__add__(self: Self, rhs: Self) -> Self

Addition and concatenation operator. For arithmetic types, this function will compute the sum of the left and right hand values. For strings and lists, this function will concat the objects.

Args:

Returns:

The sum or concatenated values.

​rhs (Self): Right hand value.

__sub__(self: Self, rhs: Self) -> Self

Subtraction operator. Valid only for arithmetic types.

Args:

Returns:

The difference.

​rhs (Self): Right hand value.

__mul__(self: Self, rhs: Self) -> Self

Multiplication operator. Valid only for arithmetic types.

Args:

Returns:

The product.

​rhs (Self): Right hand value.

__truediv__(self: Self, rhs: Self) -> Self

True division operator. Valid only for arithmetic types.

Args:

Returns:

The left hand value true divide the right hand value.

​rhs (Self): Right hand value.

__floordiv__(self: Self, rhs: Self) -> Self

Floor division operator. Valid only for arithmetic types.

Args:

Returns:

The left hand value floor divide the right hand value.

​rhs (Self): Right hand value.

__mod__(self: Self, rhs: Self) -> Self

Modulo operator. Valid only for arithmetic types.

Args:

Returns:

The left hand value mod the right hand value.

​rhs (Self): Right hand value.

__pow__(self: Self, exp: Self) -> Self

Exponentiation operator. Valid only for arithmetic types.

Args:

Returns:

The left hand value raised to the power of the right hand value.

​exp (Self): Exponent value.

__lshift__(self: Self, rhs: Self) -> Self

Left shift operator. Valid only for arithmetic types.

Args:

Returns:

The left hand value left shifted by the right hand value.

​rhs (Self): Right hand value.

__rshift__(self: Self, rhs: Self) -> Self

Right shift operator. Valid only for arithmetic types.

Args:

Returns:

The left hand value right shifted by the right hand value.

​rhs (Self): Right hand value.

__and__(self: Self, rhs: Self) -> Self

Bitwise AND operator.

Args:

Returns:

The current value if it is False.

​rhs (Self): Right hand value.

__or__(self: Self, rhs: Self) -> Self

Bitwise OR operator.

Args:

Returns:

The current value if it is True.

​rhs (Self): Right hand value.

__xor__(self: Self, rhs: Self) -> Self

Bitwise XOR operator.

Args:

Returns:

The current value if it is True.

​rhs (Self): Right hand value.

__radd__(self: Self, lhs: Self) -> Self

Reverse addition or concatenation operator.

Args:

Returns:

The sum or concatenated value.

​lhs (Self): Left hand value.

__rsub__(self: Self, lhs: Self) -> Self

Reverse subtraction operator.

Args:

Returns:

The result of subtracting this from the left-hand-side value.

​lhs (Self): Left hand value.

__rmul__(self: Self, lhs: Self) -> Self

Reverse multiplication operator.

Args:

Returns:

The product.

​lhs (Self): Left hand value.

__rtruediv__(self: Self, lhs: Self) -> Self

Reverse true division operator.

Args:

Returns:

The left hand value divide the right hand value.

​lhs (Self): Left hand value.

__rfloordiv__(self: Self, lhs: Self) -> Self

Reverse floor division operator.

Args:

Returns:

The left hand value floor divide the right hand value.

​lhs (Self): Left hand value.

__rmod__(self: Self, lhs: Self) -> Self

Reverse modulo operator.

Args:

Returns:

The left hand value mod the right hand value.

​lhs (Self): Left hand value.

__rpow__(self: Self, lhs: Self) -> Self

Reverse exponentiation operator.

Args:

Returns:

The left hand value raised to the power of the right hand value.

​lhs (Self): Left hand value.

__rlshift__(self: Self, lhs: Self) -> Self

Reverse left shift operator.

Args:

Returns:

The left hand value left shifted by the right hand value.

​lhs (Self): Left hand value.

__rrshift__(self: Self, lhs: Self) -> Self

Reverse right shift operator.

Args:

Returns:

The left hand value right shifted by the right hand value.

​lhs (Self): Left hand value.

__rand__(self: Self, lhs: Self) -> Self

Reverse AND operator.

Args:

Returns:

The bitwise AND of the left-hand-side value and this.

​lhs (Self): Left hand value.

__ror__(self: Self, lhs: Self) -> Self

Reverse OR operator.

Args:

Returns:

The bitwise OR of the left-hand-side value and this.

​lhs (Self): Left hand value.

__rxor__(self: Self, lhs: Self) -> Self

Reverse XOR operator.

Args:

Returns:

The bitwise XOR of the left-hand-side value and this.

​lhs (Self): Left hand value.

__iadd__(inout self: Self, rhs: Self)

In-place addition or concatenation operator.

Args:

​rhs (Self): Right hand value.

__isub__(inout self: Self, rhs: Self)

In-place subtraction operator.

Args:

​rhs (Self): Right hand value.

__imul__(inout self: Self, rhs: Self)

In-place multiplication operator.

Args:

​rhs (Self): Right hand value.

__itruediv__(inout self: Self, rhs: Self)

In-place true division operator.

Args:

​rhs (Self): Right hand value.

__ifloordiv__(inout self: Self, rhs: Self)

In-place floor division operator.

Args:

​rhs (Self): Right hand value.

__imod__(inout self: Self, rhs: Self)

In-place modulo operator.

Args:

​rhs (Self): Right hand value.

__ipow__(inout self: Self, rhs: Self)

In-place exponentiation operator.

Args:

​rhs (Self): Right hand value.

__ilshift__(inout self: Self, rhs: Self)

In-place left shift operator.

Args:

​rhs (Self): Right hand value.

__irshift__(inout self: Self, rhs: Self)

In-place right shift operator.

Args:

​rhs (Self): Right hand value.

__iand__(inout self: Self, rhs: Self)

In-place AND operator.

Args:

​rhs (Self): Right hand value.

__ixor__(inout self: Self, rhs: Self)

In-place XOR operator.

Args:

​rhs (Self): Right hand value.

__ior__(inout self: Self, rhs: Self)

In-place OR operator.

Args:

​rhs (Self): Right hand value.

append(self: Self, value: Self)

Appends a value to the list.

Args:

​value (Self): The value to append.





url:https://docs.modular.com/mojo/stdlib/builtin/range/
module

range





url:https://docs.modular.com/mojo/stdlib/builtin/range/range
function

range

range[type: Intable](end: type) -> _ZeroStartingRange

Constructs a [0; end) Range.

Parameters:

Args:

Returns:

The constructed range.

​type (Intable): The type of the end value.

​end (type): The end of the range.





url:https://docs.modular.com/mojo/stdlib/builtin/rebind/
module

rebind





url:https://docs.modular.com/mojo/stdlib/builtin/rebind/rebind
function

rebind

rebind[dest_type: AnyTrivialRegType, src_type: AnyTrivialRegType](val: src_type) -> $0

Statically assert that a parameter input type src_type resolves to the same type as a parameter result type dest_type after function instantiation and "rebind" the input to the result type.

This function is meant to be used in uncommon cases where a parametric type
depends on the value of a constrained parameter in order to manually refine
the type with the constrained parameter value.

Parameters:

Args:

Returns:

The rebound value of dest_type.

​dest_type (AnyTrivialRegType): The type to rebind to.
​src_type (AnyTrivialRegType): The original type.

​val (src_type): The value to rebind.





url:https://docs.modular.com/mojo/stdlib/builtin/repr/
module

repr





url:https://docs.modular.com/mojo/stdlib/builtin/repr/Representable
trait

Representable





url:https://docs.modular.com/mojo/stdlib/builtin/repr/repr
function

repr

repr[T: Representable](value: T) -> String

Returns the string representation of the given value.

Parameters:

Args:

Returns:

The string representation of the given value.

​T (Representable): The type of value. Must implement the Representable trait.

​value (T): The value to get the string representation of.





url:https://docs.modular.com/mojo/stdlib/builtin/reversed/
module

reversed





url:https://docs.modular.com/mojo/stdlib/builtin/reversed/ReversibleRange
trait

ReversibleRange





url:https://docs.modular.com/mojo/stdlib/builtin/reversed/reversed
function

reversed

reversed[T: ReversibleRange](value: T) -> _StridedRange

Get a reversed iterator of the input range.

Note: iterators are currently non-raising.

Parameters:

Args:

Returns:

The reversed iterator of the range.

​T (ReversibleRange): The type conforming to ReversibleRange.

​value (T): The range to get the reversed iterator of.





url:https://docs.modular.com/mojo/stdlib/builtin/simd/
module

simd





url:https://docs.modular.com/mojo/stdlib/builtin/simd/SIMD
struct

SIMD

__init__(inout self: Self)

Default initializer of the SIMD vector.

By default the SIMD vectors are initialized to all zeros.

__init__(inout self: Self)

Default initializer of the SIMD vector.

By default the SIMD vectors are initialized to all zeros.

__init__(inout self: Self)

Default initializer of the SIMD vector.

By default the SIMD vectors are initialized to all zeros.

__bool__(self: Self) -> Bool

Converts the SIMD scalar into a boolean value.

Constraints:

The size of the SIMD vector must be 1.

Returns:

True if the SIMD scalar is non-zero and False otherwise.

__getitem__(self: Self, idx: Int) -> SIMD[type, 1]

Gets an element from the vector.

Args:

Returns:

The value at position idx.

​idx (Int): The element index.

__setitem__(inout self: Self, idx: Int, val: SIMD[type, 1])

Sets an element in the vector.

Args:

​idx (Int): The index to set.
​val (SIMD[type, 1]): The value to set.

__neg__(self: Self) -> Self

Defines the unary - operation.

Returns:

The negation of this SIMD vector.

__pos__(self: Self) -> Self

Defines the unary + operation.

Returns:

This SIMD vector.

__invert__(self: Self) -> Self

Returns ~self.

Constraints:

The element type of the SIMD vector must be boolean or integral.

Returns:

The ~self value.

__lt__(self: Self, rhs: Self) -> SIMD[bool, size]

Compares two SIMD vectors using less-than comparison.

Args:

Returns:

A new bool SIMD vector of the same size whose element at position i is True or False depending on the expression self[i] < rhs[i].

​rhs (Self): The rhs of the operation.

__le__(self: Self, rhs: Self) -> SIMD[bool, size]

Compares two SIMD vectors using less-than-or-equal comparison.

Args:

Returns:

A new bool SIMD vector of the same size whose element at position i is True or False depending on the expression self[i] <= rhs[i].

​rhs (Self): The rhs of the operation.

__eq__(self: Self, rhs: Self) -> SIMD[bool, size]

Compares two SIMD vectors using equal-to comparison.

Args:

Returns:

A new bool SIMD vector of the same size whose element at position i is True or False depending on the expression self[i] == rhs[i].

​rhs (Self): The rhs of the operation.

__ne__(self: Self, rhs: Self) -> SIMD[bool, size]

Compares two SIMD vectors using not-equal comparison.

Args:

Returns:

A new bool SIMD vector of the same size whose element at position i is True or False depending on the expression self[i] != rhs[i].

​rhs (Self): The rhs of the operation.

__gt__(self: Self, rhs: Self) -> SIMD[bool, size]

Compares two SIMD vectors using greater-than comparison.

Args:

Returns:

A new bool SIMD vector of the same size whose element at position i is True or False depending on the expression self[i] > rhs[i].

​rhs (Self): The rhs of the operation.

__ge__(self: Self, rhs: Self) -> SIMD[bool, size]

Compares two SIMD vectors using greater-than-or-equal comparison.

Args:

Returns:

A new bool SIMD vector of the same size whose element at position i is True or False depending on the expression self[i] >= rhs[i].

​rhs (Self): The rhs of the operation.

__add__(self: Self, rhs: Self) -> Self

Computes self + rhs.

Args:

Returns:

A new vector whose element at position i is computed as self[i] + rhs[i].

​rhs (Self): The rhs value.

__sub__(self: Self, rhs: Self) -> Self

Computes self - rhs.

Args:

Returns:

A new vector whose element at position i is computed as self[i] - rhs[i].

​rhs (Self): The rhs value.

__mul__(self: Self, rhs: Self) -> Self

Computes self * rhs.

Args:

Returns:

A new vector whose element at position i is computed as self[i] * rhs[i].

​rhs (Self): The rhs value.

__truediv__(self: Self, rhs: Self) -> Self

Computes self / rhs.

Args:

Returns:

A new vector whose element at position i is computed as self[i] / rhs[i].

​rhs (Self): The rhs value.

__floordiv__(self: Self, rhs: Self) -> Self

Returns the division of self and rhs rounded down to the nearest integer.

Constraints:

The element type of the SIMD vector must be numeric.

Args:

Returns:

floor(self / rhs) value.

​rhs (Self): The value to divide with.

__mod__(self: Self, rhs: Self) -> Self

Returns the remainder of self divided by rhs.

Args:

Returns:

The remainder of dividing self by rhs.

​rhs (Self): The value to divide on.

__pow__(self: Self, exp: Int) -> Self

Computes the vector raised to the power of the input integer value.

Args:

Returns:

A SIMD vector where each element is raised to the power of the specified exponent value.

​exp (Int): The exponent value.

__lshift__(self: Self, rhs: Self) -> Self

Returns self << rhs.

Constraints:

The element type of the SIMD vector must be integral.

Args:

Returns:

self << rhs.

​rhs (Self): The RHS value.

__rshift__(self: Self, rhs: Self) -> Self

Returns self >> rhs.

Constraints:

The element type of the SIMD vector must be integral.

Args:

Returns:

self >> rhs.

​rhs (Self): The RHS value.

__and__(self: Self, rhs: Self) -> Self

Returns self & rhs.

Constraints:

The element type of the SIMD vector must be bool or integral.

Args:

Returns:

self & rhs.

​rhs (Self): The RHS value.

__or__(self: Self, rhs: Self) -> Self

Returns self | rhs.

Constraints:

The element type of the SIMD vector must be bool or integral.

Args:

Returns:

self | rhs.

​rhs (Self): The RHS value.

__xor__(self: Self, rhs: Self) -> Self

Returns self ^ rhs.

Constraints:

The element type of the SIMD vector must be bool or integral.

Args:

Returns:

self ^ rhs.

​rhs (Self): The RHS value.

__radd__(self: Self, value: Self) -> Self

Returns value + self.

Args:

Returns:

value + self.

​value (Self): The other value.

__rsub__(self: Self, value: Self) -> Self

Returns value - self.

Args:

Returns:

value - self.

​value (Self): The other value.

__rmul__(self: Self, value: Self) -> Self

Returns value * self.

Args:

Returns:

value * self.

​value (Self): The other value.

__rtruediv__(self: Self, value: Self) -> Self

Returns value / self.

Args:

Returns:

value / self.

​value (Self): The other value.

__rfloordiv__(self: Self, rhs: Self) -> Self

Returns the division of rhs and self rounded down to the nearest integer.

Constraints:

The element type of the SIMD vector must be numeric.

Args:

Returns:

floor(rhs / self) value.

​rhs (Self): The value to divide by self.

__rmod__(self: Self, value: Self) -> Self

Returns value mod self.

Args:

Returns:

value mod self.

​value (Self): The other value.

__rlshift__(self: Self, value: Self) -> Self

Returns value << self.

Constraints:

The element type of the SIMD vector must be integral.

Args:

Returns:

value << self.

​value (Self): The other value.

__rrshift__(self: Self, value: Self) -> Self

Returns value >> self.

Constraints:

The element type of the SIMD vector must be integral.

Args:

Returns:

value >> self.

​value (Self): The other value.

__rand__(self: Self, value: Self) -> Self

Returns value & self.

Constraints:

The element type of the SIMD vector must be bool or integral.

Args:

Returns:

value & self.

​value (Self): The other value.

__ror__(self: Self, value: Self) -> Self

Returns value | self.

Constraints:

The element type of the SIMD vector must be bool or integral.

Args:

Returns:

value | self.

​value (Self): The other value.

__rxor__(self: Self, value: Self) -> Self

Returns value ^ self.

Constraints:

The element type of the SIMD vector must be bool or integral.

Args:

Returns:

value ^ self.

​value (Self): The other value.

__iadd__(inout self: Self, rhs: Self)

Performs in-place addition.

The vector is mutated where each element at position i is computed as
self[i] + rhs[i].

Args:

​rhs (Self): The rhs of the addition operation.

__isub__(inout self: Self, rhs: Self)

Performs in-place subtraction.

The vector is mutated where each element at position i is computed as
self[i] - rhs[i].

Args:

​rhs (Self): The rhs of the operation.

__imul__(inout self: Self, rhs: Self)

Performs in-place multiplication.

The vector is mutated where each element at position i is computed as
self[i] * rhs[i].

Args:

​rhs (Self): The rhs of the operation.

__itruediv__(inout self: Self, rhs: Self)

In-place true divide operator.

The vector is mutated where each element at position i is computed as
self[i] / rhs[i].

Args:

​rhs (Self): The rhs of the operation.

__ifloordiv__(inout self: Self, rhs: Self)

In-place flood div operator.

The vector is mutated where each element at position i is computed as
self[i] // rhs[i].

Args:

​rhs (Self): The rhs of the operation.

__imod__(inout self: Self, rhs: Self)

In-place mod operator.

The vector is mutated where each element at position i is computed as
self[i] % rhs[i].

Args:

​rhs (Self): The rhs of the operation.

__ipow__(inout self: Self, rhs: Int)

In-place pow operator.

The vector is mutated where each element at position i is computed as
pow(self[i], rhs).

Args:

​rhs (Int): The rhs of the operation.

__ilshift__(inout self: Self, rhs: Self)

Computes self << rhs and save the result in self.

Constraints:

The element type of the SIMD vector must be integral.

Args:

​rhs (Self): The RHS value.

__irshift__(inout self: Self, rhs: Self)

Computes self >> rhs and save the result in self.

Constraints:

The element type of the SIMD vector must be integral.

Args:

​rhs (Self): The RHS value.

__iand__(inout self: Self, rhs: Self)

Computes self & rhs and save the result in self.

Constraints:

The element type of the SIMD vector must be bool or integral.

Args:

​rhs (Self): The RHS value.

__ixor__(inout self: Self, rhs: Self)

Computes self ^ rhs and save the result in self.

Constraints:

The element type of the SIMD vector must be bool or integral.

Args:

​rhs (Self): The RHS value.

__ior__(inout self: Self, rhs: Self)

Computes self | rhs and save the result in self.

Constraints:

The element type of the SIMD vector must be bool or integral.

Args:

​rhs (Self): The RHS value.

static splat(x: SIMD[type, 1]) -> Self

Splats (broadcasts) the element onto the vector.

Args:

Returns:

A new SIMD vector whose elements are the same as the input value.

​x (SIMD[type, 1]): The input scalar value.

cast[target: DType](self: Self) -> SIMD[$0, size]

Casts the elements of the SIMD vector to the target element type.

Parameters:

Returns:

A new SIMD vector whose elements have been casted to the target element type.

​target (DType): The target DType.

format_to(self: Self, inout writer: Formatter)

Formats this SIMD value to the provided formatter.

Args:

​writer (Formatter): The formatter to write to.

clamp(self: Self, lower_bound: Self, upper_bound: Self) -> Self

Clamps the values in a SIMD vector to be in a certain range.

Clamp cuts values in the input SIMD vector off at the upper bound and
lower bound values. For example,  SIMD vector [0, 1, 2, 3] clamped to
a lower bound of 1 and an upper bound of 2 would return [1, 1, 2, 2].

Args:

Returns:

A new SIMD vector containing x clamped to be within lower_bound and upper_bound.

​lower_bound (Self): Minimum of the range to clamp to.
​upper_bound (Self): Maximum of the range to clamp to.

roundeven(self: Self) -> Self

Performs elementwise banker's rounding on the elements of a SIMD vector.

This rounding goes to the nearest integer with ties toward the nearest
even integer.

Returns:

The elementwise banker's rounding of this SIMD vector.

add_with_overflow(self: Self, rhs: Self) -> Tuple[SIMD[type, size], SIMD[bool, size]]

Computes self + rhs and a mask of which indices overflowed.

Args:

Returns:

A tuple with the results of the operation and a mask for overflows. The first is a new vector whose element at position i is computed as self[i] + rhs[i]. The second item is a vector of booleans where a 1 at position i represents self[i] + rhs[i] overflowed.

​rhs (Self): The rhs value.

sub_with_overflow(self: Self, rhs: Self) -> Tuple[SIMD[type, size], SIMD[bool, size]]

Computes self - rhs and a mask of which indices overflowed.

Args:

Returns:

A tuple with the results of the operation and a mask for overflows. The first is a new vector whose element at position i is computed as self[i] - rhs[i]. The second item is a vector of booleans where a 1 at position i represents self[i] - rhs[i] overflowed.

​rhs (Self): The rhs value.

mul_with_overflow(self: Self, rhs: Self) -> Tuple[SIMD[type, size], SIMD[bool, size]]

Computes self * rhs and a mask of which indices overflowed.

Args:

Returns:

A tuple with the results of the operation and a mask for overflows. The first is a new vector whose element at position i is computed as self[i] * rhs[i]. The second item is a vector of booleans where a 1 at position i represents self[i] * rhs[i] overflowed.

​rhs (Self): The rhs value.

fma(self: Self, multiplier: Self, accumulator: Self) -> Self

Performs a fused multiply-add operation, i.e. self*multiplier + accumulator.

Args:

Returns:

A new vector whose element at position i is computed as self[i]*multiplier[i] + accumulator[i].

​multiplier (Self): The value to multiply.
​accumulator (Self): The value to accumulate.

shuffle[*mask: Int](self: Self) -> Self

Shuffles (also called blend) the values of the current vector with the other value using the specified mask (permutation). The mask values must be within 2 * len(self).

Parameters:

Returns:

A new vector with the same length as the mask where the value at position i is (self)[permutation[i]].

​*mask (Int): The permutation to use in the shuffle.

slice[output_width: Int, /, *, offset: Int = 0](self: Self) -> SIMD[type, $0]

Returns a slice of the vector of the specified width with the given offset.

Constraints:

output_width + offset must not exceed the size of this SIMD vector.

Parameters:

Returns:

A new vector whose elements map to self[offset:offset+output_width].

​output_width (Int): The output SIMD vector size.
​offset (Int): The given offset for the slice.

insert[*, offset: Int = 0](self: Self, value: SIMD[type, size]) -> Self

Returns a the vector where the elements between offset and offset + input_width have been replaced with the elements in value.

Parameters:

Args:

Returns:

A new vector whose elements at self[offset:offset+input_width] contain the values of value.

​offset (Int): The offset to insert at.

​value (SIMD[type, size]): The value to be inserted.

join(self: Self, other: Self) -> SIMD[type, __mul__(2, size)]

Concatenates the two vectors together.

Args:

Returns:

A new vector self_0, self_1, ..., self_n, other_0, ..., other_n.

​other (Self): The other SIMD vector.

interleave(self: Self, other: Self) -> SIMD[type, __mul__(2, size)]

Constructs a vector by interleaving two input vectors.

Args:

Returns:

A new vector self_0, other_0, ..., self_n, other_n.

​other (Self): The other SIMD vector.

deinterleave(self: Self) -> Tuple[SIMD[type, __floordiv__(size, 2)], SIMD[type, __floordiv__(size, 2)]]

Constructs two vectors by deinterleaving the even and odd lanes of the vector.

Constraints:

The vector size must be greater than 1.

Returns:

Two vectors the first of the form self_0, self_2, ..., self_{n-2} and the other being self_1, self_3, ..., self_{n-1}.

min(self: Self, other: Self) -> Self

Computes the elementwise minimum between the two vectors.

Args:

Returns:

A new SIMD vector where each element at position i is min(self[i], other[i]).

​other (Self): The other SIMD vector.

max(self: Self, other: Self) -> Self

Computes the elementwise maximum between the two vectors.

Args:

Returns:

A new SIMD vector where each element at position i is max(self[i], other[i]).

​other (Self): The other SIMD vector.

reduce[func: fn[DType, Int](SIMD[$0, $1], SIMD[$0, $1]) capturing -> SIMD[$0, $1], size_out: Int = 1](self: Self) -> SIMD[type, $1]

Reduces the vector using a provided reduce operator.

Constraints:

size_out must not exceed width of the vector.

Parameters:

Returns:

A new scalar which is the reduction of all vector elements.

​func (fn[DType, Int](SIMD[$0, $1], SIMD[$0, $1]) capturing -> SIMD[$0, $1]): The reduce function to apply to elements in this SIMD.
​size_out (Int): The width of the reduction.

reduce_max[size_out: Int = 1](self: Self) -> SIMD[type, $0]

Reduces the vector using the max operator.

Constraints:

size_out must not exceed width of the vector. The element type of the vector must be integer or FP.

Parameters:

Returns:

The maximum element of the vector.

​size_out (Int): The width of the reduction.

reduce_min[size_out: Int = 1](self: Self) -> SIMD[type, $0]

Reduces the vector using the min operator.

Constraints:

size_out must not exceed width of the vector. The element type of the vector must be integer or FP.

Parameters:

Returns:

The minimum element of the vector.

​size_out (Int): The width of the reduction.

reduce_add[size_out: Int = 1](self: Self) -> SIMD[type, $0]

Reduces the vector using the add operator.

Constraints:

size_out must not exceed width of the vector.

Parameters:

Returns:

The sum of all vector elements.

​size_out (Int): The width of the reduction.

reduce_mul[size_out: Int = 1](self: Self) -> SIMD[type, $0]

Reduces the vector using the mul operator.

Constraints:

size_out must not exceed width of the vector. The element type of the vector must be integer or FP.

Parameters:

Returns:

The product of all vector elements.

​size_out (Int): The width of the reduction.

reduce_and[size_out: Int = 1](self: Self) -> SIMD[type, $0]

Reduces the vector using the bitwise & operator.

Constraints:

size_out must not exceed width of the vector. The element type of the vector must be integer or boolean.

Parameters:

Returns:

The reduced vector.

​size_out (Int): The width of the reduction.

reduce_or[size_out: Int = 1](self: Self) -> SIMD[type, $0]

Reduces the vector using the bitwise | operator.

Constraints:

size_out must not exceed width of the vector. The element type of the vector must be integer or boolean.

Parameters:

Returns:

The reduced vector.

​size_out (Int): The width of the reduction.

reduce_bit_count(self: Self) -> Int

Returns the total number of bits set in the SIMD vector.

Constraints:

Must be either an integral or a boolean type.

Returns:

Count of set bits across all elements of the vector.

select[result_type: DType](self: Self, true_case: SIMD[result_type, size], false_case: SIMD[result_type, size]) -> SIMD[$0, size]

Selects the values of the true_case or the false_case based on the current boolean values of the SIMD vector.

Constraints:

The element type of the vector must be boolean.

Parameters:

Args:

Returns:

A new vector of the form [true_case[i] if elem else false_case[i] for i, elem in enumerate(self)].

​result_type (DType): The element type of the input and output SIMD vectors.

​true_case (SIMD[result_type, size]): The values selected if the positional value is True.
​false_case (SIMD[result_type, size]): The values selected if the positional value is False.

rotate_left[shift: Int](self: Self) -> Self

Shifts the elements of a SIMD vector to the left by shift elements (with wrap-around).

Constraints:

-size <= shift < size

Parameters:

Returns:

The SIMD vector rotated to the left by shift elements (with wrap-around).

​shift (Int): The number of positions by which to rotate the elements of SIMD vector to the left (with wrap-around).

rotate_right[shift: Int](self: Self) -> Self

Shifts the elements of a SIMD vector to the right by shift elements (with wrap-around).

Constraints:

-size < shift <= size

Parameters:

Returns:

The SIMD vector rotated to the right by shift elements (with wrap-around).

​shift (Int): The number of positions by which to rotate the elements of SIMD vector to the right (with wrap-around).

shift_left[shift: Int](self: Self) -> Self

Shifts the elements of a SIMD vector to the left by shift elements (no wrap-around, fill with zero).

Constraints:

0 <= shift <= size

Parameters:

Returns:

The SIMD vector rotated to the left by shift elements (no wrap-around, fill with zero).

​shift (Int): The number of positions by which to rotate the elements of SIMD vector to the left (no wrap-around, fill with zero).

shift_right[shift: Int](self: Self) -> Self

Shifts the elements of a SIMD vector to the right by shift elements (no wrap-around, fill with zero).

Constraints:

0 <= shift <= size

Parameters:

Returns:

The SIMD vector rotated to the right by shift elements (no wrap-around, fill with zero).

​shift (Int): The number of positions by which to rotate the elements of SIMD vector to the right (no wrap-around, fill with zero).





url:https://docs.modular.com/mojo/stdlib/builtin/sort/
module

sort





url:https://docs.modular.com/mojo/stdlib/builtin/sort/insertion_sort
function

insertion_sort

insertion_sort[type: ComparableCollectionElement](inout list: List[type])

Sort list of the order comparable elements in-place with insertion sort algorithm.

Parameters:

Args:

​type (ComparableCollectionElement): The order comparable collection element type.

​list (List[type]): The list of the order comparable elements which will be sorted in-place.





url:https://docs.modular.com/mojo/stdlib/builtin/sort/partition
function

partition

partition[type: AnyTrivialRegType, cmp_fn: fn[AnyTrivialRegType]($0, $0) capturing -> Bool](buff: LegacyPointer[type, 0], k: Int, size: Int)

Partition the input vector inplace such that first k elements are the largest (or smallest if cmp_fn is <= operator) elements. The ordering of the first k elements is undefined.

Parameters:

Args:

​type (AnyTrivialRegType): DType of the underlying data.
​cmp_fn (fn[AnyTrivialRegType]($0, $0) capturing -> Bool): Comparison functor of type, type) capturing -> Bool type.

​buff (LegacyPointer[type, 0]): Input buffer.
​k (Int): Index of the partition element.
​size (Int): The length of the buffer.





url:https://docs.modular.com/mojo/stdlib/builtin/sort/quick_sort
function

quick_sort

quick_sort[type: ComparableCollectionElement](inout list: List[type])

Sort list of the order comparable elements in-place with quick sort algorithm.

Parameters:

Args:

​type (ComparableCollectionElement): The order comparable collection element type.

​list (List[type]): The list of the order comparable elements which will be sorted in-place.





url:https://docs.modular.com/mojo/stdlib/builtin/sort/sort
function

sort

sort(inout buff: LegacyPointer[Int, 0], len: Int)

Sort the vector inplace. The function doesn't return anything, the vector is updated inplace.

Args:

​buff (LegacyPointer[Int, 0]): Input buffer.
​len (Int): The length of the buffer.





url:https://docs.modular.com/mojo/stdlib/builtin/str/
module

str





url:https://docs.modular.com/mojo/stdlib/builtin/str/Stringable
trait

Stringable





url:https://docs.modular.com/mojo/stdlib/builtin/str/StringableRaising
trait

StringableRaising





url:https://docs.modular.com/mojo/stdlib/builtin/str/str
function

str

str[T: Stringable](value: T) -> String

Get the string representation of a value.

Parameters:

Args:

Returns:

The string representation of the object.

​T (Stringable): The type conforming to Stringable.

​value (T): The object to get the string representation of.





url:https://docs.modular.com/mojo/stdlib/builtin/string/
module

string





url:https://docs.modular.com/mojo/stdlib/builtin/string/String
struct

String

__init__(inout self: Self, owned impl: List[SIMD[uint8, 1]])

Construct a string from a buffer of bytes.

The buffer must be terminated with a null byte:

Args:

​impl (List[SIMD[uint8, 1]]): The buffer.

__init__(inout self: Self, owned impl: List[SIMD[uint8, 1]])

Construct a string from a buffer of bytes.

The buffer must be terminated with a null byte:

Args:

​impl (List[SIMD[uint8, 1]]): The buffer.

__init__(inout self: Self, owned impl: List[SIMD[uint8, 1]])

Construct a string from a buffer of bytes.

The buffer must be terminated with a null byte:

Args:

​impl (List[SIMD[uint8, 1]]): The buffer.

__copyinit__(inout self: Self, existing: Self)

Creates a deep copy of an existing string.

Args:

​existing (Self): The string to copy.

__moveinit__(inout self: Self, owned existing: Self)

Move the value of a string.

Args:

​existing (Self): The string to move.

__bool__(self: Self) -> Bool

Checks if the string is not empty.

Returns:

True if the string length is greater than zero, and False otherwise.

__getitem__(self: Self, idx: Int) -> Self

Gets the character at the specified position.

Args:

Returns:

A new string containing the character at the specified position.

​idx (Int): The index value.

__lt__(self: Self, rhs: Self) -> Bool

Compare this String to the RHS using LT comparison.

Args:

Returns:

True if this String is strictly less than the RHS String and False otherwise.

​rhs (Self): The other String to compare against.

__le__(self: Self, rhs: Self) -> Bool

Compare this String to the RHS using LE comparison.

Args:

Returns:

True iff this String is less than or equal to the RHS String.

​rhs (Self): The other String to compare against.

__eq__(self: Self, other: Self) -> Bool

Compares two Strings if they have the same values.

Args:

Returns:

True if the Strings are equal and False otherwise.

​other (Self): The rhs of the operation.

__ne__(self: Self, other: Self) -> Bool

Compares two Strings if they do not have the same values.

Args:

Returns:

True if the Strings are not equal and False otherwise.

​other (Self): The rhs of the operation.

__gt__(self: Self, rhs: Self) -> Bool

Compare this String to the RHS using GT comparison.

Args:

Returns:

True iff this String is strictly greater than the RHS String.

​rhs (Self): The other String to compare against.

__ge__(self: Self, rhs: Self) -> Bool

Compare this String to the RHS using GE comparison.

Args:

Returns:

True iff this String is greater than or equal to the RHS String.

​rhs (Self): The other String to compare against.

__contains__(self: Self, substr: Self) -> Bool

Returns True if the substring is contained within the current string.

Args:

Returns:

True if the string contains the substring.

​substr (Self): The substring to check.

__add__(self: Self, other: Self) -> Self

Creates a string by appending another string at the end.

Args:

Returns:

The new constructed string.

​other (Self): The string to append.

__mul__(self: Self, n: Int) -> Self

Concatenates the string n times.

Args:

Returns:

The string concatenated n times.

​n (Int): The number of times to concatenate the string.

__radd__(self: Self, other: Self) -> Self

Creates a string by prepending another string to the start.

Args:

Returns:

The new constructed string.

​other (Self): The string to prepend.

__iadd__(inout self: Self, other: Self)

Appends another string to this string.

Args:

​other (Self): The string to append.

static format_sequence[*Ts: Formattable](*args: *Ts) -> Self

Construct a string by concatenating a sequence of formattable arguments.

Parameters:

Args:

Returns:

A string formed by formatting the argument sequence.

​*Ts (Formattable): The types of the arguments to format. Each type must be satisfy Formattable.

​*args (*Ts): A sequence of formattable arguments.

format_to(self: Self, inout writer: Formatter)

Formats this string to the provided formatter.

Args:

​writer (Formatter): The formatter to write to.

join(self: Self, *elems: Int) -> Self

Joins the elements from the tuple using the current string as a delimiter.

Args:

Returns:

The joined string.

​*elems (Int): The input tuple.

unsafe_ptr(self: Self) -> UnsafePointer[SIMD[int8, 1], 0]

Retrieves a pointer to the underlying memory.

Note that you should use unsafe_uint8_ptr() if you need to access the
pointer as we are now storing the bytes as UInt8.

See https://github.com/modularml/mojo/issues/2317 for more information.

Returns:

The pointer to the underlying memory.

unsafe_uint8_ptr(self: Self) -> UnsafePointer[SIMD[uint8, 1], 0]

Retrieves a pointer to the underlying memory.

Returns:

The pointer to the underlying memory.

as_bytes(self: Self) -> List[SIMD[uint8, 1]]

Retrieves the underlying byte sequence encoding the characters in this string.

This does not include the trailing null terminator.

Returns:

A sequence containing the encoded characters stored in this string.

as_bytes_slice(self: Reference[String, is_mutable, lifetime, 0]) -> Span[SIMD[uint8, 1], $0, $1]

Returns a contiguous slice of the bytes owned by this string.

This does not include the trailing null terminator.

Returns:

A contiguous slice pointing to the bytes owned by this string.

as_string_slice(self: Reference[String, is_mutable, lifetime, 0]) -> StringSlice[$0, $1]

Returns a string slice of the data owned by this string.

Returns:

A string slice pointing to the data owned by this string.

count(self: Self, substr: Self) -> Int

Return the number of non-overlapping occurrences of substring substr in the string.

If sub is empty, returns the number of empty strings between characters
which is the length of the string plus one.

Args:

Returns:

The number of occurrences of substr.

​substr (Self): The substring to count.

find(self: Self, substr: Self, start: Int = 0) -> Int

Finds the offset of the first occurrence of substr starting at start. If not found, returns -1.

Args:

Returns:

The offset of substr relative to the beginning of the string.

​substr (Self): The substring to find.
​start (Int): The offset from which to find.

rfind(self: Self, substr: Self, start: Int = 0) -> Int

Finds the offset of the last occurrence of substr starting at start. If not found, returns -1.

Args:

Returns:

The offset of substr relative to the beginning of the string.

​substr (Self): The substring to find.
​start (Int): The offset from which to find.

isspace(self: Self) -> Bool

Determines whether the given String is a python whitespace String. This corresponds to Python's universal separators " \t\n\r\f\v\x1c\x1e\x85\u2028\u2029".

Returns:

True if the String is one of the whitespace characters listed above, otherwise False.

split(self: Self, sep: Self, maxsplit: Int = -1) -> List[String]

Split the string by a separator.

Examples:

.

Args:

Returns:

A List of Strings containing the input split by the separator.

​sep (Self): The string to split on.
​maxsplit (Int): The maximum amount of items to split from String. Defaults to unlimited.

splitlines(self: Self, keepends: Bool = 0) -> List[String]

Split the string at line boundaries.

Args:

Returns:

A List of Strings containing the input split by line boundaries.

​keepends (Bool): If True, line breaks are kept in the resulting strings.

replace(self: Self, old: Self, new: Self) -> Self

Return a copy of the string with all occurrences of substring old if replaced by new.

Args:

Returns:

The string where all occurrences of old are replaced with new.

​old (Self): The substring to replace.
​new (Self): The substring to replace with.

strip(self: Self, chars: Self) -> Self

Return a copy of the string with leading and trailing characters removed.

Args:

Returns:

A copy of the string with no leading or trailing characters.

​chars (Self): A set of characters to be removed. Defaults to whitespace.

rstrip(self: Self, chars: Self) -> Self

Return a copy of the string with trailing characters removed.

Args:

Returns:

A copy of the string with no trailing characters.

​chars (Self): A set of characters to be removed. Defaults to whitespace.

lstrip(self: Self, chars: Self) -> Self

Return a copy of the string with leading characters removed.

Args:

Returns:

A copy of the string with no leading characters.

​chars (Self): A set of characters to be removed. Defaults to whitespace.

lower(self: Self) -> Self

Returns a copy of the string with all ASCII cased characters converted to lowercase.

Returns:

A new string where cased letters have been converted to lowercase.

upper(self: Self) -> Self

Returns a copy of the string with all ASCII cased characters converted to uppercase.

Returns:

A new string where cased letters have been converted to uppercase.

startswith(self: Self, prefix: Self, start: Int = 0, end: Int = -1) -> Bool

Checks if the string starts with the specified prefix between start and end positions. Returns True if found and False otherwise.

Args:

Returns:

True if the self[start:end] is prefixed by the input prefix.

​prefix (Self): The prefix to check.
​start (Int): The start offset from which to check.
​end (Int): The end offset from which to check.

endswith(self: Self, suffix: Self, start: Int = 0, end: Int = -1) -> Bool

Checks if the string end with the specified suffix between start and end positions. Returns True if found and False otherwise.

Args:

Returns:

True if the self[start:end] is suffixed by the input suffix.

​suffix (Self): The suffix to check.
​start (Int): The start offset from which to check.
​end (Int): The end offset from which to check.

removeprefix(self: Self, prefix: Self, /) -> Self

Returns a new string with the prefix removed if it was present.

For example:

Args:

Returns:

string[len(prefix):] if the string starts with the prefix string, or a copy of the original string otherwise.

​prefix (Self): The prefix to remove from the string.

removesuffix(self: Self, suffix: Self, /) -> Self

Returns a new string with the suffix removed if it was present.

For example:

Args:

Returns:

string[:-len(suffix)] if the string ends with the suffix string, or a copy of the original string otherwise.

​suffix (Self): The suffix to remove from the string.





url:https://docs.modular.com/mojo/stdlib/builtin/string/ascii
function

ascii

ascii(value: String) -> String

Get the ASCII representation of the object.

Args:

Returns:

A string containing the ASCII representation of the object.

​value (String): The object to get the ASCII representation of.





url:https://docs.modular.com/mojo/stdlib/builtin/string/atof
function

atof

atof(str: String) -> SIMD[float64, 1]

Parses the given string as a floating point and returns that value.

For example, atof("2.25") returns 2.25.

Args:

Returns:

An floating point value that represents the string, or otherwise raises.

Raises:

If the given string cannot be parsed as an floating point value, for example in atof("hi").

​str (String): A string to be parsed as a floating point.





url:https://docs.modular.com/mojo/stdlib/builtin/string/atol
function

atol

atol(str: String, base: Int = 10) -> Int

Parses and returns the given string as an integer in the given base.

For example, atol("19") returns 19. If base is 0 the the string is
parsed as an Integer literal, see: https://docs.python.org/3/reference/lexical_analysis.html#integers.

Args:

Returns:

An integer value that represents the string, or otherwise raises.

Raises:

If the given string cannot be parsed as an integer value. For example in atol("hi").

​str (String): A string to be parsed as an integer in the given base.
​base (Int): Base used for conversion, value must be between 2 and 36, or 0.





url:https://docs.modular.com/mojo/stdlib/builtin/string/chr
function

chr

chr(c: Int) -> String

Returns a string based on the given Unicode code point.

Returns the string representing a character whose code point is the integer
c. For example, chr(97) returns the string "a". This is the inverse of
the ord() function.

Args:

Returns:

A string containing a single character based on the given code point.

​c (Int): An integer that represents a code point.





url:https://docs.modular.com/mojo/stdlib/builtin/string/isdigit
function

isdigit

isdigit(c: SIMD[uint8, 1]) -> Bool

Determines whether the given character is a digit [0-9].

Args:

Returns:

True if the character is a digit.

​c (SIMD[uint8, 1]): The character to check.





url:https://docs.modular.com/mojo/stdlib/builtin/string/islower
function

islower

islower(c: SIMD[uint8, 1]) -> Bool

Determines whether the given character is an lowercase character.

This currently only respects the default "C" locale, i.e. returns True iff
the character specified is one of "abcdefghijklmnopqrstuvwxyz".

Args:

Returns:

True if the character is lowercase.

​c (SIMD[uint8, 1]): The character to check.





url:https://docs.modular.com/mojo/stdlib/builtin/string/isprintable
function

isprintable

isprintable(c: SIMD[uint8, 1]) -> Bool

Determines whether the given character is a printable character.

Args:

Returns:

True if the character is a printable character, otherwise False.

​c (SIMD[uint8, 1]): The character to check.





url:https://docs.modular.com/mojo/stdlib/builtin/string/isupper
function

isupper

isupper(c: SIMD[uint8, 1]) -> Bool

Determines whether the given character is an uppercase character.

This currently only respects the default "C" locale, i.e. returns True iff
the character specified is one of "ABCDEFGHIJKLMNOPQRSTUVWXYZ".

Args:

Returns:

True if the character is uppercase.

​c (SIMD[uint8, 1]): The character to check.





url:https://docs.modular.com/mojo/stdlib/builtin/string/ord
function

ord

ord(s: String) -> Int

Returns an integer that represents the given one-character string.

Given a string representing one character, return an integer
representing the code point of that character. For example, ord("a")
returns the integer 97. This is the inverse of the chr() function.

Args:

Returns:

An integer representing the code point of the given character.

​s (String): The input string, which must contain only a single character.





url:https://docs.modular.com/mojo/stdlib/builtin/string_literal/
module

string_literal





url:https://docs.modular.com/mojo/stdlib/builtin/string_literal/StringLiteral
struct

StringLiteral

__init__(inout self: Self, value: string)

Create a string literal from a builtin string type.

Args:

​value (string): The string value.

__init__(inout self: Self, value: string)

Create a string literal from a builtin string type.

Args:

​value (string): The string value.

__init__(inout self: Self, value: string)

Create a string literal from a builtin string type.

Args:

​value (string): The string value.

__bool__(self: Self) -> Bool

Convert the string to a bool value.

Returns:

True if the string is not empty.

__lt__(self: Self, rhs: Self) -> Bool

Compare this StringLiteral to the RHS using LT comparison.

Args:

Returns:

True if this StringLiteral is strictly less than the RHS StringLiteral and False otherwise.

​rhs (Self): The other StringLiteral to compare against.

__le__(self: Self, rhs: Self) -> Bool

Compare this StringLiteral to the RHS using LE comparison.

Args:

Returns:

True if this StringLiteral is less than or equal to the RHS StringLiteral and False otherwise.

​rhs (Self): The other StringLiteral to compare against.

__eq__(self: Self, rhs: Self) -> Bool

Compare two string literals for equality.

Args:

Returns:

True if they are equal.

​rhs (Self): The string to compare.

__ne__(self: Self, rhs: Self) -> Bool

Compare two string literals for inequality.

Args:

Returns:

True if they are not equal.

​rhs (Self): The string to compare.

__gt__(self: Self, rhs: Self) -> Bool

Compare this StringLiteral to the RHS using GT comparison.

Args:

Returns:

True if this StringLiteral is strictly greater than the RHS StringLiteral and False otherwise.

​rhs (Self): The other StringLiteral to compare against.

__ge__(self: Self, rhs: Self) -> Bool

Compare this StringLiteral to the RHS using GE comparison.

Args:

Returns:

True if this StringLiteral is greater than or equal to the RHS StringLiteral and False otherwise.

​rhs (Self): The other StringLiteral to compare against.

__contains__(self: Self, substr: Self) -> Bool

Returns True if the substring is contained within the current string.

Args:

Returns:

True if the string contains the substring.

​substr (Self): The substring to check.

__add__(self: Self, rhs: Self) -> Self

Concatenate two string literals.

Args:

Returns:

The concatenated string.

​rhs (Self): The string to concat.

unsafe_ptr(self: Self) -> UnsafePointer[SIMD[int8, 1], 0]

Get raw pointer to the underlying data.

Returns:

The raw pointer to the data.

unsafe_uint8_ptr(self: Self) -> UnsafePointer[SIMD[uint8, 1], 0]

Get raw pointer to the underlying data.

Returns:

The raw pointer to the data.

as_uint8_ptr(self: Self) -> DTypePointer[uint8, 0]

Get raw pointer to the underlying data.

Returns:

The raw pointer to the data.

as_string_slice(self: Self) -> StringSlice[0, #lit.lifetime]

Returns a string slice of this static string literal.

Returns:

A string slice pointing to this static string literal.

as_bytes_slice(self: Self) -> Span[SIMD[uint8, 1], 0, #lit.lifetime]

Returns a contiguous slice of the bytes owned by this string.

Returns:

A contiguous slice pointing to the bytes owned by this string.

format_to(self: Self, inout writer: Formatter)

Formats this string literal to the provided formatter.

Args:

​writer (Formatter): The formatter to write to.

find(self: Self, substr: Self, start: Int = 0) -> Int

Finds the offset of the first occurrence of substr starting at start. If not found, returns -1.

Args:

Returns:

The offset of substr relative to the beginning of the string.

​substr (Self): The substring to find.
​start (Int): The offset from which to find.

rfind(self: Self, substr: Self, start: Int = 0) -> Int

Finds the offset of the last occurrence of substr starting at start. If not found, returns -1.

Args:

Returns:

The offset of substr relative to the beginning of the string.

​substr (Self): The substring to find.
​start (Int): The offset from which to find.





url:https://docs.modular.com/mojo/stdlib/builtin/swap/
module

swap





url:https://docs.modular.com/mojo/stdlib/builtin/swap/swap
function

swap

swap[T: Movable](inout lhs: T, inout rhs: T)

Swaps the two given arguments.

Parameters:

Args:

​T (Movable): Constrained to Copyable types.

​lhs (T): Argument value swapped with rhs.
​rhs (T): Argument value swapped with lhs.





url:https://docs.modular.com/mojo/stdlib/builtin/tuple/
module

tuple





url:https://docs.modular.com/mojo/stdlib/builtin/tuple/Tuple
struct

Tuple

__init__(inout self: Self, owned *args: *element_types)

Construct the tuple.

Args:

​*args (*element_types): Initial values.

__init__(inout self: Self, owned *args: *element_types)

Construct the tuple.

Args:

​*args (*element_types): Initial values.

__init__(inout self: Self, owned *args: *element_types)

Construct the tuple.

Args:

​*args (*element_types): Initial values.

__moveinit__(inout self: Self, owned existing: Self)

Move construct the tuple.

Args:

​existing (Self): The value to move from.

__del__(owned self: Self)

Destructor that destroys all of the elements.

__getitem__[idx: Int](self: Reference[Tuple[element_types], is_mutable, lifetime, 0]) -> ref [$2] element_types[$0.value]

Get a reference to an element in the tuple.

Parameters:

Returns:

A referece to the specified element.

​idx (Int): The element to return.

__contains__[T: EqualityComparable](self: Self, value: T) -> Bool

Verify if a given value is present in the tuple.

Parameters:

Args:

Returns:

True if the value is contained in the tuple, False otherwise.

​T (EqualityComparable): The type of the value argument. Must implement the trait EqualityComparable.

​value (T): The value to find.

get[i: Int, T: Movable](self: Self) -> ref [*[0,0]] $1

Get a tuple element and rebind to the specified type.

Parameters:

Returns:

The tuple element at the requested index.

​i (Int): The element index.
​T (Movable): The element type.





url:https://docs.modular.com/mojo/stdlib/builtin/type_aliases/
module

type_aliases





url:https://docs.modular.com/mojo/stdlib/builtin/type_aliases/AnyLifetime
struct

AnyLifetime





url:https://docs.modular.com/mojo/stdlib/builtin/value/
module

value





url:https://docs.modular.com/mojo/stdlib/builtin/value/BoolableCollectionElement
trait

BoolableCollectionElement

__copyinit__(inout self: T, existing: T, /)

Create a new instance of the value by copying an existing one.

Args:

​existing (T): The value to copy.

__copyinit__(inout self: T, existing: T, /)

Create a new instance of the value by copying an existing one.

Args:

​existing (T): The value to copy.

__copyinit__(inout self: T, existing: T, /)

Create a new instance of the value by copying an existing one.

Args:

​existing (T): The value to copy.

__moveinit__(inout self: T, owned existing: T, /)

Create a new instance of the value by moving the value of another.

Args:

​existing (T): The value to move.

__bool__(self: T) -> Bool

Get the boolean representation of the value.

Returns:

The boolean representation of the value.





url:https://docs.modular.com/mojo/stdlib/builtin/value/BoolableKeyElement
trait

BoolableKeyElement

__copyinit__(inout self: T, existing: T, /)

Create a new instance of the value by copying an existing one.

Args:

​existing (T): The value to copy.

__copyinit__(inout self: T, existing: T, /)

Create a new instance of the value by copying an existing one.

Args:

​existing (T): The value to copy.

__copyinit__(inout self: T, existing: T, /)

Create a new instance of the value by copying an existing one.

Args:

​existing (T): The value to copy.

__moveinit__(inout self: T, owned existing: T, /)

Create a new instance of the value by moving the value of another.

Args:

​existing (T): The value to move.

__bool__(self: T) -> Bool

Get the boolean representation of the value.

Returns:

The boolean representation of the value.

__eq__(self: T, other: T) -> Bool

Define whether two instances of the object are equal to each other.

Args:

Returns:

True if the instances are equal according to the type's definition of equality, False otherwise.

​other (T): Another instance of the same type.

__ne__(self: T, other: T) -> Bool

Define whether two instances of the object are not equal to each other.

Args:

Returns:

True if the instances are not equal according to the type's definition of equality, False otherwise.

​other (T): Another instance of the same type.





url:https://docs.modular.com/mojo/stdlib/builtin/value/CollectionElement
trait

CollectionElement

__copyinit__(inout self: T, existing: T, /)

Create a new instance of the value by copying an existing one.

Args:

​existing (T): The value to copy.

__copyinit__(inout self: T, existing: T, /)

Create a new instance of the value by copying an existing one.

Args:

​existing (T): The value to copy.

__copyinit__(inout self: T, existing: T, /)

Create a new instance of the value by copying an existing one.

Args:

​existing (T): The value to copy.

__moveinit__(inout self: T, owned existing: T, /)

Create a new instance of the value by moving the value of another.

Args:

​existing (T): The value to move.





url:https://docs.modular.com/mojo/stdlib/builtin/value/ComparableCollectionElement
trait

ComparableCollectionElement

__copyinit__(inout self: T, existing: T, /)

Create a new instance of the value by copying an existing one.

Args:

​existing (T): The value to copy.

__copyinit__(inout self: T, existing: T, /)

Create a new instance of the value by copying an existing one.

Args:

​existing (T): The value to copy.

__copyinit__(inout self: T, existing: T, /)

Create a new instance of the value by copying an existing one.

Args:

​existing (T): The value to copy.

__moveinit__(inout self: T, owned existing: T, /)

Create a new instance of the value by moving the value of another.

Args:

​existing (T): The value to move.

__lt__(self: T, rhs: T) -> Bool

Define whether self is less than rhs.

Args:

Returns:

True if self is less than rhs.

​rhs (T): The right hand side of the comparison.

__le__(self: T, rhs: T) -> Bool

Define whether self is less than or equal to rhs.

Args:

Returns:

True if self is less than or equal to rhs.

​rhs (T): The right hand side of the comparison.

__eq__(self: T, other: T) -> Bool

Define whether two instances of the object are equal to each other.

Args:

Returns:

True if the instances are equal according to the type's definition of equality, False otherwise.

​other (T): Another instance of the same type.

__ne__(self: T, other: T) -> Bool

Define whether two instances of the object are not equal to each other.

Args:

Returns:

True if the instances are not equal according to the type's definition of equality, False otherwise.

​other (T): Another instance of the same type.

__gt__(self: T, rhs: T) -> Bool

Define whether self is greater than rhs.

Args:

Returns:

True if self is greater than rhs.

​rhs (T): The right hand side of the comparison.

__ge__(self: T, rhs: T) -> Bool

Define whether self is greater than or equal to rhs.

Args:

Returns:

True if self is greater than or equal to rhs.

​rhs (T): The right hand side of the comparison.





url:https://docs.modular.com/mojo/stdlib/builtin/value/Copyable
trait

Copyable

__copyinit__(inout self: T, existing: T, /)

Create a new instance of the value by copying an existing one.

Args:

​existing (T): The value to copy.

__copyinit__(inout self: T, existing: T, /)

Create a new instance of the value by copying an existing one.

Args:

​existing (T): The value to copy.

__copyinit__(inout self: T, existing: T, /)

Create a new instance of the value by copying an existing one.

Args:

​existing (T): The value to copy.





url:https://docs.modular.com/mojo/stdlib/builtin/value/Defaultable
trait

Defaultable

__init__(inout self: T, /)

Create a default instance of the value.

__init__(inout self: T, /)

Create a default instance of the value.

__init__(inout self: T, /)

Create a default instance of the value.





url:https://docs.modular.com/mojo/stdlib/builtin/value/ExplicitlyCopyable
trait

ExplicitlyCopyable

__init__(inout self: T, /, other: T)

Construct a deep copy of the provided value.

Args:

​other (T): The value to copy.

__init__(inout self: T, /, other: T)

Construct a deep copy of the provided value.

Args:

​other (T): The value to copy.

__init__(inout self: T, /, other: T)

Construct a deep copy of the provided value.

Args:

​other (T): The value to copy.





url:https://docs.modular.com/mojo/stdlib/builtin/value/Movable
trait

Movable

__moveinit__(inout self: T, owned existing: T, /)

Create a new instance of the value by moving the value of another.

Args:

​existing (T): The value to move.

__moveinit__(inout self: T, owned existing: T, /)

Create a new instance of the value by moving the value of another.

Args:

​existing (T): The value to move.

__moveinit__(inout self: T, owned existing: T, /)

Create a new instance of the value by moving the value of another.

Args:

​existing (T): The value to move.





url:https://docs.modular.com/mojo/stdlib/builtin/value/RepresentableCollectionElement
trait

RepresentableCollectionElement

__copyinit__(inout self: T, existing: T, /)

Create a new instance of the value by copying an existing one.

Args:

​existing (T): The value to copy.

__copyinit__(inout self: T, existing: T, /)

Create a new instance of the value by copying an existing one.

Args:

​existing (T): The value to copy.

__copyinit__(inout self: T, existing: T, /)

Create a new instance of the value by copying an existing one.

Args:

​existing (T): The value to copy.

__moveinit__(inout self: T, owned existing: T, /)

Create a new instance of the value by moving the value of another.

Args:

​existing (T): The value to move.





url:https://docs.modular.com/mojo/stdlib/builtin/value/StringableCollectionElement
trait

StringableCollectionElement

__copyinit__(inout self: T, existing: T, /)

Create a new instance of the value by copying an existing one.

Args:

​existing (T): The value to copy.

__copyinit__(inout self: T, existing: T, /)

Create a new instance of the value by copying an existing one.

Args:

​existing (T): The value to copy.

__copyinit__(inout self: T, existing: T, /)

Create a new instance of the value by copying an existing one.

Args:

​existing (T): The value to copy.

__moveinit__(inout self: T, owned existing: T, /)

Create a new instance of the value by moving the value of another.

Args:

​existing (T): The value to move.





url:https://docs.modular.com/mojo/stdlib/collections/
package

collections





url:https://docs.modular.com/mojo/stdlib/collections/dict/
module

dict





url:https://docs.modular.com/mojo/stdlib/collections/dict/Dict
struct

Dict

__init__(inout self: Self)

Initialize an empty dictiontary.

__init__(inout self: Self)

Initialize an empty dictiontary.

__init__(inout self: Self)

Initialize an empty dictiontary.

__copyinit__(inout self: Self, existing: Self)

Copy an existing dictiontary.

Args:

​existing (Self): The existing dict.

__moveinit__(inout self: Self, owned existing: Self)

Move data of an existing dict into a new one.

Args:

​existing (Self): The existing dict.

__bool__(self: Self) -> Bool

Check if the dictionary is empty or not.

Returns:

False if the dictionary is empty, True if there is at least one element.

__getitem__(self: Self, key: K) -> V

Retrieve a value out of the dictionary.

Args:

Returns:

The value associated with the key, if it's present.

Raises:

"KeyError" if the key isn't present.

​key (K): The key to retrieve.

__setitem__(inout self: Self, owned key: K, owned value: V)

Set a value in the dictionary by key.

Args:

​key (K): The key to associate with the specified value.
​value (V): The data to store in the dictionary.

__contains__(self: Self, key: K) -> Bool

Check if a given key is in the dictionary or not.

Args:

Returns:

True if there key exists in the dictionary, False otherwise.

​key (K): The key to check.

__or__(self: Self, other: Self) -> Self

Merge self with other and return the result as a new dict.

Args:

Returns:

The result of the merge.

​other (Self): The dictionary to merge with.

__ior__(inout self: Self, other: Self)

Merge self with other in place.

Args:

​other (Self): The dictionary to merge with.

static fromkeys(keys: List[K], value: V) -> Self

Create a new dictionary with keys from list and values set to value.

Args:

Returns:

The new dictionary.

​keys (List[K]): The keys to set.
​value (V): The value to set.

find(self: Self, key: K) -> Optional[V]

Find a value in the dictionary by key.

Args:

Returns:

An optional value containing a copy of the value if it was present, otherwise an empty Optional.

​key (K): The key to search for in the dictionary.

get(self: Self, key: K) -> Optional[V]

Get a value from the dictionary by key.

Args:

Returns:

An optional value containing a copy of the value if it was present, otherwise an empty Optional.

​key (K): The key to search for in the dictionary.

pop(inout self: Self, key: K, owned default: Optional[V] = #kgen.none) -> V

Remove a value from the dictionary by key.

Args:

Returns:

The value associated with the key, if it was in the dictionary. If it wasn't, return the provided default value instead.

Raises:

"KeyError" if the key was not present in the dictionary and no default value was provided.

​key (K): The key to remove from the dictionary.
​default (Optional[V]): Optionally provide a default value to return if the key was not found instead of raising.

keys(self: Reference[Dict[K, V], is_mutable, lifetime, 0]) -> _DictKeyIter[K, V, $0, $1, 1]

Iterate over the dict's keys as immutable references.

Returns:

An iterator of immutable references to the dictionary keys.

values(self: Reference[Dict[K, V], is_mutable, lifetime, 0]) -> _DictValueIter[K, V, $0, $1, 1]

Iterate over the dict's values as references.

Returns:

An iterator of references to the dictionary values.

items(self: Reference[Dict[K, V], is_mutable, lifetime, 0]) -> _DictEntryIter[K, V, $0, $1, 1]

Iterate over the dict's entries as immutable references.

These can't yet be unpacked like Python dict items, but you can
access the key and value as attributes ie.

Returns:

An iterator of immutable references to the dictionary entries.

update(inout self: Self, other: Self, /)

Update the dictionary with the key/value pairs from other, overwriting existing keys. The argument must be positional only.

Args:

​other (Self): The dictionary to update from.

clear(inout self: Self)

Remove all elements from the dictionary.





url:https://docs.modular.com/mojo/stdlib/collections/dict/DictEntry
struct

DictEntry

__init__(inout self: Self, owned key: K, owned value: V)

Create an entry from a key and value, computing the hash.

Args:

​key (K): The key of the entry.
​value (V): The value of the entry.

__init__(inout self: Self, owned key: K, owned value: V)

Create an entry from a key and value, computing the hash.

Args:

​key (K): The key of the entry.
​value (V): The value of the entry.

__init__(inout self: Self, owned key: K, owned value: V)

Create an entry from a key and value, computing the hash.

Args:

​key (K): The key of the entry.
​value (V): The value of the entry.





url:https://docs.modular.com/mojo/stdlib/collections/dict/KeyElement
trait

KeyElement

__copyinit__(inout self: T, existing: T, /)

Create a new instance of the value by copying an existing one.

Args:

​existing (T): The value to copy.

__copyinit__(inout self: T, existing: T, /)

Create a new instance of the value by copying an existing one.

Args:

​existing (T): The value to copy.

__copyinit__(inout self: T, existing: T, /)

Create a new instance of the value by copying an existing one.

Args:

​existing (T): The value to copy.

__moveinit__(inout self: T, owned existing: T, /)

Create a new instance of the value by moving the value of another.

Args:

​existing (T): The value to move.

__eq__(self: T, other: T) -> Bool

Define whether two instances of the object are equal to each other.

Args:

Returns:

True if the instances are equal according to the type's definition of equality, False otherwise.

​other (T): Another instance of the same type.

__ne__(self: T, other: T) -> Bool

Define whether two instances of the object are not equal to each other.

Args:

Returns:

True if the instances are not equal according to the type's definition of equality, False otherwise.

​other (T): Another instance of the same type.





url:https://docs.modular.com/mojo/stdlib/collections/dict/OwnedKwargsDict
struct

OwnedKwargsDict

__init__(inout self: Self)

Initialize an empty keyword dictionary.

__init__(inout self: Self)

Initialize an empty keyword dictionary.

__init__(inout self: Self)

Initialize an empty keyword dictionary.

__copyinit__(inout self: Self, existing: Self)

Copy an existing keyword dictionary.

Args:

​existing (Self): The existing keyword dictionary.

__moveinit__(inout self: Self, owned existing: Self)

Move data of an existing keyword dictionary into a new one.

Args:

​existing (Self): The existing keyword dictionary.

__getitem__(self: Self, key: String) -> V

Retrieve a value out of the keyword dictionary.

Args:

Returns:

The value associated with the key, if it's present.

Raises:

"KeyError" if the key isn't present.

​key (String): The key to retrieve.

__setitem__(inout self: Self, key: String, value: V)

Set a value in the keyword dictionary by key.

Args:

​key (String): The key to associate with the specified value.
​value (V): The data to store in the dictionary.

__contains__(self: Self, key: String) -> Bool

Check if a given key is in the keyword dictionary or not.

Args:

Returns:

True if there key exists in the keyword dictionary, False otherwise.

​key (String): The key to check.

find(self: Self, key: String) -> Optional[V]

Find a value in the keyword dictionary by key.

Args:

Returns:

An optional value containing a copy of the value if it was present, otherwise an empty Optional.

​key (String): The key to search for in the dictionary.

pop(inout self: Self, key: String, owned default: Optional[V] = #kgen.none) -> V

Remove a value from the keyword dictionary by key.

Args:

Returns:

The value associated with the key, if it was in the dictionary. If it wasn't, return the provided default value instead.

Raises:

"KeyError" if the key was not present in the dictionary and no default value was provided.

​key (String): The key to remove from the dictionary.
​default (Optional[V]): Optionally provide a default value to return if the key was not found instead of raising.

keys(self: Reference[OwnedKwargsDict[V], is_mutable, lifetime, 0]) -> _DictKeyIter[String, V, $0, $1, 1]

Iterate over the keyword dict's keys as immutable references.

Returns:

An iterator of immutable references to the dictionary keys.

values(self: Reference[OwnedKwargsDict[V], is_mutable, lifetime, 0]) -> _DictValueIter[String, V, $0, $1, 1]

Iterate over the keyword dict's values as references.

Returns:

An iterator of references to the dictionary values.

items(self: Reference[OwnedKwargsDict[V], is_mutable, lifetime, 0]) -> _DictEntryIter[String, V, $0, $1, 1]

Iterate over the keyword dictionary's entries as immutable references.

These can't yet be unpacked like Python dict items, but you can
access the key and value as attributes ie.

Returns:

An iterator of immutable references to the dictionary entries.





url:https://docs.modular.com/mojo/stdlib/collections/dict/RepresentableKeyElement
trait

RepresentableKeyElement

__copyinit__(inout self: T, existing: T, /)

Create a new instance of the value by copying an existing one.

Args:

​existing (T): The value to copy.

__copyinit__(inout self: T, existing: T, /)

Create a new instance of the value by copying an existing one.

Args:

​existing (T): The value to copy.

__copyinit__(inout self: T, existing: T, /)

Create a new instance of the value by copying an existing one.

Args:

​existing (T): The value to copy.

__moveinit__(inout self: T, owned existing: T, /)

Create a new instance of the value by moving the value of another.

Args:

​existing (T): The value to move.

__eq__(self: T, other: T) -> Bool

Define whether two instances of the object are equal to each other.

Args:

Returns:

True if the instances are equal according to the type's definition of equality, False otherwise.

​other (T): Another instance of the same type.

__ne__(self: T, other: T) -> Bool

Define whether two instances of the object are not equal to each other.

Args:

Returns:

True if the instances are not equal according to the type's definition of equality, False otherwise.

​other (T): Another instance of the same type.





url:https://docs.modular.com/mojo/stdlib/collections/inline_list/
module

inline_list





url:https://docs.modular.com/mojo/stdlib/collections/inline_list/InlineList
struct

InlineList

__init__(inout self: Self)

This constructor creates an empty InlineList.

__init__(inout self: Self)

This constructor creates an empty InlineList.

__init__(inout self: Self)

This constructor creates an empty InlineList.

__del__(owned self: Self)

Destroy all the elements in the list and free the memory.

__bool__(self: Self) -> Bool

Checks whether the list has any elements or not.

Returns:

False if the list is empty, True if there is at least one element.

__getitem__(self: Reference[InlineList[ElementType, capacity], is_mutable, lifetime, 0], owned idx: Int) -> ref [$1] ElementType

Get a Reference to the element at the given index.

Args:

Returns:

A reference to the item at the given index.

​idx (Int): The index of the item.

__contains__[C: ComparableCollectionElement](self: Self, value: C) -> Bool

Verify if a given value is present in the list.

Parameters:

Args:

Returns:

True if the value is contained in the list, False otherwise.

​C (ComparableCollectionElement): The type of the elements in the list. Must implement the traits EqualityComparable and CollectionElement.

​value (C): The value to find.

append(inout self: Self, owned value: ElementType)

Appends a value to the list.

Args:

​value (ElementType): The value to append.

count[C: ComparableCollectionElement](self: Self, value: C) -> Int

Counts the number of occurrences of a value in the list.

Parameters:

Args:

Returns:

The number of occurrences of the value in the list.

​C (ComparableCollectionElement): The type of the elements in the list. Must implement the traits EqualityComparable and CollectionElement.

​value (C): The value to count.





url:https://docs.modular.com/mojo/stdlib/collections/list/
module

list





url:https://docs.modular.com/mojo/stdlib/collections/list/List
struct

List

__init__(inout self: Self)

Constructs an empty list.

__init__(inout self: Self)

Constructs an empty list.

__init__(inout self: Self)

Constructs an empty list.

__copyinit__(inout self: Self, existing: Self)

Creates a deepcopy of the given list.

Args:

​existing (Self): The list to copy.

__moveinit__(inout self: Self, owned existing: Self)

Move data of an existing list into a new one.

Args:

​existing (Self): The existing list.

__del__(owned self: Self)

Destroy all elements in the list and free its memory.

__bool__(self: Self) -> Bool

Checks whether the list has any elements or not.

Returns:

False if the list is empty, True if there is at least one element.

__getitem__(self: Self, span: Slice) -> Self

Gets the sequence of elements at the specified positions.

Args:

Returns:

A new list containing the list at the specified span.

​span (Slice): A slice that specifies positions of the new list.

__setitem__(inout self: Self, idx: Int, owned value: T)

Sets a list element at the given index.

Args:

​idx (Int): The index of the element.
​value (T): The value to assign.

__contains__[T2: ComparableCollectionElement](self: Self, value: T2) -> Bool

Verify if a given value is present in the list.

Parameters:

Args:

Returns:

True if the value is contained in the list, False otherwise.

​T2 (ComparableCollectionElement): The type of the elements in the list. Must implement the traits EqualityComparable and CollectionElement.

​value (T2): The value to find.

__add__(self: Self, owned other: Self) -> Self

Concatenates self with other and returns the result as a new list.

Args:

Returns:

The newly created list.

​other (Self): List whose elements will be combined with the elements of self.

__mul__(self: Self, x: Int) -> Self

Multiplies the list by x and returns a new list.

Args:

Returns:

The new list.

​x (Int): The multiplier number.

__iadd__(inout self: Self, owned other: Self)

Appends the elements of other into self.

Args:

​other (Self): List whose elements will be appended to self.

__imul__(inout self: Self, x: Int)

Multiplies the list by x in place.

Args:

​x (Int): The multiplier number.

append(inout self: Self, owned value: T)

Appends a value to this list.

Args:

​value (T): The value to append.

insert(inout self: Self, i: Int, owned value: T)

Inserts a value to the list at the given index. a.insert(len(a), value) is equivalent to a.append(value).

Args:

​i (Int): The index for the value.
​value (T): The value to insert.

extend(inout self: Self, owned other: Self)

Extends this list by consuming the elements of other.

Args:

​other (Self): List whose elements will be added in order at the end of this list.

pop(inout self: Self, i: Int = -1) -> T

Pops a value from the list at the given index.

Args:

Returns:

The popped value.

​i (Int): The index of the value to pop.

reserve(inout self: Self, new_capacity: Int)

Reserves the requested capacity.

If the current capacity is greater or equal, this is a no-op.
Otherwise, the storage is reallocated and the date is moved.

Args:

​new_capacity (Int): The new capacity.

resize(inout self: Self, new_size: Int, value: T)

Resizes the list to the given new size.

If the new size is smaller than the current one, elements at the end
are discarded. If the new size is larger than the current one, the
list is appended with new values elements up to the requested size.

Args:

​new_size (Int): The new size.
​value (T): The value to use to populate new elements.

reverse(inout self: Self)

Reverses the elements of the list.

index[C: ComparableCollectionElement](self: Reference[List[C], is_mutable, lifetime, 0], value: C, start: Int = 0, stop: Optional[Int] = #kgen.none) -> Int

Returns the index of the first occurrence of a value in a list restricted by the range given the start and stop bounds.

Parameters:

Args:

Returns:

The index of the first occurrence of the value in the list.

Raises:

ValueError: If the value is not found in the list.

​C (ComparableCollectionElement): The type of the elements in the list. Must implement the ComparableCollectionElement trait.

​value (C): The value to search for.
​start (Int): The starting index of the search, treated as a slice index (defaults to 0).
​stop (Optional[Int]): The ending index of the search, treated as a slice index (defaults to None, which means the end of the list).

clear(inout self: Self)

Clears the elements in the list.

steal_data(inout self: Self) -> UnsafePointer[T, 0]

Take ownership of the underlying pointer from the list.

Returns:

The underlying data.

unsafe_get(self: Reference[List[T], is_mutable, lifetime, 0], idx: Int) -> Reference[T, $0, $1, 0]

Get a reference to an element of self without checking index bounds.

Users should consider using __getitem__ instead of this method as it
is unsafe. If an index is out of bounds, this method will not abort, it
will be considered undefined behavior.

Note that there is no wraparound for negative indices, caution is
advised. Using negative indices is considered undefined behavior. Never
use my_list.unsafe_get(-1) to get the last element of the list.
Instead, do my_list.unsafe_get(len(my_list) - 1).

Args:

Returns:

A reference to the element at the given index.

​idx (Int): The index of the element to get.

count[T: ComparableCollectionElement](self: List[T], value: T) -> Int

Counts the number of occurrences of a value in the list. Note that since we can't condition methods on a trait yet, the way to call this method is a bit special. Here is an example below.

When the compiler supports conditional methods, then a simple my_list.count(1) will
be enough.

Parameters:

Args:

Returns:

The number of occurrences of the value in the list.

​T (ComparableCollectionElement): The type of the elements in the list. Must implement the traits EqualityComparable and CollectionElement.

​value (T): The value to count.

unsafe_ptr(self: Self) -> UnsafePointer[T, 0]

Retrieves a pointer to the underlying memory.

Returns:

The UnsafePointer to the underlying memory.





url:https://docs.modular.com/mojo/stdlib/collections/optional/
module

optional





url:https://docs.modular.com/mojo/stdlib/collections/optional/Optional
struct

Optional

__init__(inout self: Self)

Construct an empty Optional.

__init__(inout self: Self)

Construct an empty Optional.

__init__(inout self: Self)

Construct an empty Optional.

__bool__(self: Self) -> Bool

Return true if the Optional has a value.

Returns:

True if the optional has a value and False otherwise.

__invert__(self: Self) -> Bool

Return False if the optional has a value.

Returns:

False if the optional has a value and True otherwise.

__is__(self: Self, other: None) -> Bool

Return True if the Optional has no value.

It allows you to use the following syntax: if my_optional is None:

Args:

Returns:

True if the Optional has no value and False otherwise.

​other (None): The value to compare to (None).

__isnot__(self: Self, other: None) -> Bool

Return True if the Optional has a value.

It allows you to use the following syntax: if my_optional is not None:.

Args:

Returns:

True if the Optional has a value and False otherwise.

​other (None): The value to compare to (None).

value(self: Reference[Optional[T], is_mutable, lifetime, 0]) -> Reference[T, $0, $1, 0]

Retrieve a reference to the value of the Optional.

This check to see if the optional contains a value.
If you call this without first verifying the optional with bool()
eg. by if my_option: or without otherwise knowing that it contains a
value (for instance with or_else), the program will abort

Returns:

A reference to the contained data of the option as a Reference[T].

unsafe_value(self: Reference[Optional[T], is_mutable, lifetime, 0]) -> Reference[T, $0, $1, 0]

Unsafely retrieve a reference to the value of the Optional.

This doesn't check to see if the optional contains a value.
If you call this without first verifying the optional with bool()
eg. by if my_option: or without otherwise knowing that it contains a
value (for instance with or_else), you'll get garbage unsafe data out.

Returns:

A reference to the contained data of the option as a Reference[T].

take(inout self: Self) -> T

Move the value out of the Optional.

The caller takes ownership over the new value, which is moved
out of the Optional, and the Optional is left in an empty state.

This check to see if the optional contains a value.
If you call this without first verifying the optional with bool()
eg. by if my_option: or without otherwise knowing that it contains a
value (for instance with or_else), you'll get garbage unsafe data out.

Returns:

The contained data of the option as an owned T value.

unsafe_take(inout self: Self) -> T

Unsafely move the value out of the Optional.

The caller takes ownership over the new value, which is moved
out of the Optional, and the Optional is left in an empty state.

This check to see if the optional contains a value.
If you call this without first verifying the optional with bool()
eg. by if my_option: or without otherwise knowing that it contains a
value (for instance with or_else), the program will abort!

Returns:

The contained data of the option as an owned T value.

or_else(self: Self, default: T) -> T

Return the underlying value contained in the Optional or a default value if the Optional's underlying value is not present.

Args:

Returns:

The underlying value contained in the Optional or a default value.

​default (T): The new value to use if no value was present.





url:https://docs.modular.com/mojo/stdlib/collections/optional/OptionalReg
struct

OptionalReg

__init__(inout self: Self)

Create an optional with a value of None.

__init__(inout self: Self)

Create an optional with a value of None.

__init__(inout self: Self)

Create an optional with a value of None.

__bool__(self: Self) -> Bool

Return true if the optional has a value.

Returns:

True if the optional has a value and False otherwise.

__is__(self: Self, other: None) -> Bool

Return True if the Optional has no value.

It allows you to use the following syntax: if my_optional is None:

Args:

Returns:

True if the Optional has no value and False otherwise.

​other (None): The value to compare to (None).

__isnot__(self: Self, other: None) -> Bool

Return True if the Optional has a value.

It allows you to use the following syntax: if my_optional is not None:

Args:

Returns:

True if the Optional has a value and False otherwise.

​other (None): The value to compare to (None).

value(self: Self) -> T

Get the optional value.

Returns:

The contained value.





url:https://docs.modular.com/mojo/stdlib/collections/set/
module

set





url:https://docs.modular.com/mojo/stdlib/collections/set/Set
struct

Set

__init__(inout self: Self, *ts: T)

Construct a set from initial elements.

Args:

​*ts (T): Variadic of elements to add to the set.

__init__(inout self: Self, *ts: T)

Construct a set from initial elements.

Args:

​*ts (T): Variadic of elements to add to the set.

__init__(inout self: Self, *ts: T)

Construct a set from initial elements.

Args:

​*ts (T): Variadic of elements to add to the set.

__moveinit__(inout self: Self, owned other: Self)

Move constructor.

Args:

​other (Self): The existing Set instance to move from.

__bool__(self: Self) -> Bool

Whether the set is non-empty or not.

Returns:

True if the set is non-empty, False if it is empty.

__lt__(self: Self, other: Self) -> Bool

Overloads the < operator for strict subset comparison of sets.

Args:

Returns:

True if the set is a strict subset of the other set, False otherwise.

​other (Self): The set to compare against for the strict subset relationship.

__le__(self: Self, other: Self) -> Bool

Overloads the <= operator for sets. Works like as issubset method.

Args:

Returns:

True if this set is a subset of the other set, False otherwise.

​other (Self): Another Set instance to check against.

__eq__(self: Self, other: Self) -> Bool

Set equality.

Args:

Returns:

True if the sets contain the same elements and False otherwise.

​other (Self): Another Set instance to check equality against.

__ne__(self: Self, other: Self) -> Bool

Set inequality.

Args:

Returns:

True if the sets are different and False otherwise.

​other (Self): Another Set instance to check equality against.

__gt__(self: Self, other: Self) -> Bool

Overloads the > operator for strict superset comparison of sets.

Args:

Returns:

True if the set is a strict superset of the other set, False otherwise.

​other (Self): The set to compare against for the strict superset relationship.

__ge__(self: Self, other: Self) -> Bool

Overloads the >= operator for sets. Works like as issuperset method.

Args:

Returns:

True if this set is a superset of the other set, False otherwise.

​other (Self): Another Set instance to check against.

__contains__(self: Self, t: T) -> Bool

Whether or not the set contains an element.

Args:

Returns:

Whether or not the set contains the element.

​t (T): The element to check membership in the set.

__sub__(self: Self, other: Self) -> Self

Set subtraction.

Args:

Returns:

A new set containing elements of this set, but not containing any elements which were in the other set.

​other (Self): Another Set instance to subtract from this one.

__and__(self: Self, other: Self) -> Self

The set intersection operator.

Args:

Returns:

A new set containing only the elements which appear in both this set and the other set.

​other (Self): Another Set instance to intersect with this one.

__or__(self: Self, other: Self) -> Self

The set union operator.

Args:

Returns:

A new set containing any elements which appear in either this set or the other set.

​other (Self): Another Set instance to union with this one.

__xor__(self: Self, other: Self) -> Self

Overloads the ^ operator for sets. Works like as symmetric_difference method.

Args:

Returns:

A new set containing the symmetric difference of the two sets.

​other (Self): The set to find the symmetric difference with.

__isub__(inout self: Self, other: Self)

In-place set subtraction.

Updates the set to remove any elements from the other set.

Args:

​other (Self): Another Set instance to subtract from this one.

__iand__(inout self: Self, other: Self)

In-place set intersection.

Updates the set to contain only the elements which are already in
the set and are also contained in the other set.

Args:

​other (Self): Another Set instance to intersect with this one.

__ixor__(inout self: Self, other: Self)

Overloads the ^= operator. Works like as symmetric_difference_update method.

Updates the set with the symmetric difference of itself and another set.

Args:

​other (Self): The set to find the symmetric difference with.

__ior__(inout self: Self, other: Self)

In-place set union.

Updates the set to contain all elements in the other set
as well as keeping all elements it already contained.

Args:

​other (Self): Another Set instance to union with this one.

add(inout self: Self, t: T)

Add an element to the set.

Args:

​t (T): The element to add to the set.

remove(inout self: Self, t: T)

Remove an element from the set.

Args:

Raises:

If the element isn't in the set to remove.

​t (T): The element to remove from the set.

pop(inout self: Self) -> T

Remove any one item from the set, and return it.

As an implementation detail this will remove the first item
according to insertion order. This is practically useful
for breadth-first search implementations.

Returns:

The element which was removed from the set.

Raises:

If the set is empty.

union(self: Self, other: Self) -> Self

Set union.

Args:

Returns:

A new set containing any elements which appear in either this set or the other set.

​other (Self): Another Set instance to union with this one.

intersection(self: Self, other: Self) -> Self

Set intersection.

Args:

Returns:

A new set containing only the elements which appear in both this set and the other set.

​other (Self): Another Set instance to intersect with this one.

difference(self: Self, other: Self) -> Self

Set difference.

Args:

Returns:

A new set containing elements that are in this set but not in the other set.

​other (Self): Another Set instance to find the difference with this one.

update(inout self: Self, other: Self)

In-place set update.

Updates the set to contain all elements in the other set
as well as keeping all elements it already contained.

Args:

​other (Self): Another Set instance to union with this one.

intersection_update(inout self: Self, other: Self)

In-place set intersection update.

Updates the set by retaining only elements found in both this set and the other set,
removing all other elements. The result is the intersection of this set with other.

Args:

​other (Self): Another Set instance to intersect with this one.

difference_update(inout self: Self, other: Self)

In-place set subtraction.

Updates the set by removing all elements found in the other set,
effectively keeping only elements that are unique to this set.

Args:

​other (Self): Another Set instance to subtract from this one.

issubset(self: Self, other: Self) -> Bool

Check if this set is a subset of another set.

Args:

Returns:

True if this set is a subset of the other set, False otherwise.

​other (Self): Another Set instance to check against.

isdisjoint(self: Self, other: Self) -> Bool

Check if this set is disjoint with another set.

Args:

Returns:

True if this set is disjoint with the other set, False otherwise.

​other (Self): Another Set instance to check against.

issuperset(self: Self, other: Self) -> Bool

Check if this set is a superset of another set.

Args:

Returns:

True if this set is a superset of the other set, False otherwise.

​other (Self): Another Set instance to check against.

symmetric_difference(self: Self, other: Self) -> Self

Returns the symmetric difference of two sets.

Args:

Returns:

A new set containing the symmetric difference of the two sets.

​other (Self): The set to find the symmetric difference with.

symmetric_difference_update(inout self: Self, other: Self)

Updates the set with the symmetric difference of itself and another set.

Args:

​other (Self): The set to find the symmetric difference with.

discard(inout self: Self, value: T)

Remove a value from the set if it exists. Pass otherwise.

Args:

​value (T): The element to remove from the set.

clear(inout self: Self)

Removes all elements from the set.

This method modifies the set in-place, removing all of its elements.
After calling this method, the set will be empty.





url:https://docs.modular.com/mojo/stdlib/collections/vector/
module

vector





url:https://docs.modular.com/mojo/stdlib/collections/vector/InlinedFixedVector
struct

InlinedFixedVector

__init__(inout self: Self, capacity: Int)

Constructs InlinedFixedVector with the given capacity.

The dynamically allocated portion is capacity - size.

Args:

​capacity (Int): The requested maximum capacity of the vector.

__init__(inout self: Self, capacity: Int)

Constructs InlinedFixedVector with the given capacity.

The dynamically allocated portion is capacity - size.

Args:

​capacity (Int): The requested maximum capacity of the vector.

__init__(inout self: Self, capacity: Int)

Constructs InlinedFixedVector with the given capacity.

The dynamically allocated portion is capacity - size.

Args:

​capacity (Int): The requested maximum capacity of the vector.

__copyinit__(inout self: Self, existing: Self)

Creates a shallow copy (doesn't copy the underlying elements).

Args:

​existing (Self): The InlinedFixedVector to copy.

__getitem__(self: Self, idx: Int) -> type

Gets a vector element at the given index.

Args:

Returns:

The element at the given index.

​idx (Int): The index of the element.

__setitem__(inout self: Self, idx: Int, value: type)

Sets a vector element at the given index.

Args:

​idx (Int): The index of the element.
​value (type): The value to assign.

deepcopy(self: Self) -> Self

Creates a deep copy of this vector.

Returns:

The created copy of this vector.

append(inout self: Self, value: type)

Appends a value to this vector.

Args:

​value (type): The value to append.

clear(inout self: Self)

Clears the elements in the vector.





url:https://docs.modular.com/mojo/stdlib/complex/
package

complex





url:https://docs.modular.com/mojo/stdlib/complex/complex/
module

complex





url:https://docs.modular.com/mojo/stdlib/complex/complex/ComplexSIMD
struct

ComplexSIMD

__neg__(self: Self) -> Self

Negates the complex value.

Returns:

The negative of the complex value.

__neg__(self: Self) -> Self

Negates the complex value.

Returns:

The negative of the complex value.

__neg__(self: Self) -> Self

Negates the complex value.

Returns:

The negative of the complex value.

__add__(self: Self, rhs: Self) -> Self

Adds two complex values.

Args:

Returns:

A sum of this and RHS complex values.

​rhs (Self): Complex value to add.

__mul__(self: Self, rhs: Self) -> Self

Multiplies two complex values.

Args:

Returns:

A product of this and RHS complex values.

​rhs (Self): Complex value to multiply with.

norm(self: Self) -> SIMD[type, size]

Returns the magnitude of the complex value.

Returns:

Value of sqrt(re*re + im*im).

squared_norm(self: Self) -> SIMD[type, size]

Returns the squared magnitude of the complex value.

Returns:

Value of re*re + im*im.

fma(self: Self, b: Self, c: Self) -> Self

Computes FMA operation.

Compute fused multiple-add with two other complex values:
result = self * b + c

Args:

Returns:

Computed Self * B + C complex value.

​b (Self): Multiplier complex value.
​c (Self): Complex value to add.

squared_add(self: Self, c: Self) -> Self

Computes Square-Add operation.

Compute Self * Self + C.

Args:

Returns:

Computed Self * Self + C complex value.

​c (Self): Complex value to add.





url:https://docs.modular.com/mojo/stdlib/complex/complex/abs
function

abs

abs(x: ComplexSIMD[type, size]) -> SIMD[$0, $1]

Performs elementwise abs (norm) on each element of the complex value.

Args:

Returns:

The elementwise abs of x.

​x (ComplexSIMD[type, size]): The complex vector to perform absolute value on.





url:https://docs.modular.com/mojo/stdlib/math/
package

math





url:https://docs.modular.com/mojo/stdlib/math/math/
module

math





url:https://docs.modular.com/mojo/stdlib/math/math/acos
function

acos

acos[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[$0, $1]

Computes the acos of the inputs.

Parameters:

Args:

Returns:

The acos of the input.

​type (DType): The dtype of the input and output SIMD vector. Constraints: must be a floating-point type.
​simd_width (Int): The width of the input and output SIMD vector.

​arg (SIMD[type, simd_width]): The input argument.





url:https://docs.modular.com/mojo/stdlib/math/math/acosh
function

acosh

acosh[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[$0, $1]

Computes the acosh of the inputs.

Parameters:

Args:

Returns:

The acosh of the input.

​type (DType): The dtype of the input and output SIMD vector. Constraints: must be a floating-point type.
​simd_width (Int): The width of the input and output SIMD vector.

​arg (SIMD[type, simd_width]): The input argument.





url:https://docs.modular.com/mojo/stdlib/math/math/align_down
function

align_down

align_down(value: Int, alignment: Int) -> Int

Returns the closest multiple of alignment that is less than or equal to value.

Args:

Returns:

Closest multiple of the alignment that is less than or equal to the input value. In other words, floor(value / alignment) * alignment.

​value (Int): The value to align.
​alignment (Int): Value to align to.





url:https://docs.modular.com/mojo/stdlib/math/math/align_up
function

align_up

align_up(value: Int, alignment: Int) -> Int

Returns the closest multiple of alignment that is greater than or equal to value.

Args:

Returns:

Closest multiple of the alignment that is greater than or equal to the input value. In other words, ceiling(value / alignment) * alignment.

​value (Int): The value to align.
​alignment (Int): Value to align to.





url:https://docs.modular.com/mojo/stdlib/math/math/asin
function

asin

asin[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[$0, $1]

Computes the asin of the inputs.

Parameters:

Args:

Returns:

The asin of the input.

​type (DType): The dtype of the input and output SIMD vector. Constraints: must be a floating-point type.
​simd_width (Int): The width of the input and output SIMD vector.

​arg (SIMD[type, simd_width]): The input argument.





url:https://docs.modular.com/mojo/stdlib/math/math/asinh
function

asinh

asinh[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[$0, $1]

Computes the asinh of the inputs.

Parameters:

Args:

Returns:

The asinh of the input.

​type (DType): The dtype of the input and output SIMD vector. Constraints: must be a floating-point type.
​simd_width (Int): The width of the input and output SIMD vector.

​arg (SIMD[type, simd_width]): The input argument.





url:https://docs.modular.com/mojo/stdlib/math/math/atan
function

atan

atan[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[$0, $1]

Computes the atan of the inputs.

Parameters:

Args:

Returns:

The atan of the input.

​type (DType): The dtype of the input and output SIMD vector. Constraints: must be a floating-point type.
​simd_width (Int): The width of the input and output SIMD vector.

​arg (SIMD[type, simd_width]): The input argument.





url:https://docs.modular.com/mojo/stdlib/math/math/atan2
function

atan2

atan2[type: DType, simd_width: Int](arg0: SIMD[type, simd_width], arg1: SIMD[type, simd_width]) -> SIMD[$0, $1]

Computes the atan2 of the inputs.

Parameters:

Args:

Returns:

The atan2 of the inputs.

​type (DType): The dtype of the input and output SIMD vector. Constraints: must be a floating-point type.
​simd_width (Int): The width of the input and output SIMD vector.

​arg0 (SIMD[type, simd_width]): The first input argument.
​arg1 (SIMD[type, simd_width]): The second input argument.





url:https://docs.modular.com/mojo/stdlib/math/math/atanh
function

atanh

atanh[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[$0, $1]

Computes the atanh of the inputs.

Parameters:

Args:

Returns:

The atanh of the input.

​type (DType): The dtype of the input and output SIMD vector. Constraints: must be a floating-point type.
​simd_width (Int): The width of the input and output SIMD vector.

​arg (SIMD[type, simd_width]): The input argument.





url:https://docs.modular.com/mojo/stdlib/math/math/cbrt
function

cbrt

cbrt[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[$0, $1]

Computes the cbrt of the inputs.

Parameters:

Args:

Returns:

The cbrt of the input.

​type (DType): The dtype of the input and output SIMD vector. Constraints: must be a floating-point type.
​simd_width (Int): The width of the input and output SIMD vector.

​arg (SIMD[type, simd_width]): The input argument.





url:https://docs.modular.com/mojo/stdlib/math/math/ceil
function

ceil

ceil[T: Ceilable](value: T) -> $0

Get the ceiling value of the given object.

Parameters:

Args:

Returns:

The ceiling value of the object.

​T (Ceilable): The type conforming to Ceilable.

​value (T): The object to get the ceiling value of.





url:https://docs.modular.com/mojo/stdlib/math/math/ceildiv
function

ceildiv

ceildiv[T: CeilDivable](numerator: T, denominator: T) -> $0

Return the rounded-up result of dividing x by y.

Parameters:

Args:

Returns:

The ceiling of dividing x by y.

​T (CeilDivable): A type that support floor division.

​numerator (T): The numerator.
​denominator (T): The denominator.





url:https://docs.modular.com/mojo/stdlib/math/math/copysign
function

copysign

copysign[type: DType, simd_width: Int](magnitude: SIMD[type, simd_width], sign: SIMD[type, simd_width]) -> SIMD[$0, $1]

Returns a value with the magnitude of the first operand and the sign of the second operand.

Parameters:

Args:

Returns:

Copies the sign from sign to magnitude.

​type (DType): The dtype of the input and output SIMD vector.
​simd_width (Int): The width of the input and output SIMD vector.

​magnitude (SIMD[type, simd_width]): The magnitude to use.
​sign (SIMD[type, simd_width]): The sign to copy.





url:https://docs.modular.com/mojo/stdlib/math/math/cos
function

cos

cos[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[$0, $1]

Computes the cos of the inputs.

Parameters:

Args:

Returns:

The cos of the input.

​type (DType): The dtype of the input and output SIMD vector. Constraints: must be a floating-point type.
​simd_width (Int): The width of the input and output SIMD vector.

​arg (SIMD[type, simd_width]): The input argument.





url:https://docs.modular.com/mojo/stdlib/math/math/cosh
function

cosh

cosh[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[$0, $1]

Computes the cosh of the inputs.

Parameters:

Args:

Returns:

The cosh of the input.

​type (DType): The dtype of the input and output SIMD vector. Constraints: must be a floating-point type.
​simd_width (Int): The width of the input and output SIMD vector.

​arg (SIMD[type, simd_width]): The input argument.





url:https://docs.modular.com/mojo/stdlib/math/math/erf
function

erf

erf[type: DType, simd_width: Int](x: SIMD[type, simd_width]) -> SIMD[$0, $1]

Performs the elementwise Erf on a SIMD vector.

Parameters:

Args:

Returns:

The result of the elementwise Erf operation.

​type (DType): The dtype of the input and output SIMD vector. Constraints: must be a floating-point type.
​simd_width (Int): The width of the input and output SIMD vector.

​x (SIMD[type, simd_width]): SIMD vector to perform elementwise Erf on.





url:https://docs.modular.com/mojo/stdlib/math/math/erfc
function

erfc

erfc[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[$0, $1]

Computes the erfc of the inputs.

Parameters:

Args:

Returns:

The erfc of the input.

​type (DType): The dtype of the input and output SIMD vector. Constraints: must be a floating-point type.
​simd_width (Int): The width of the input and output SIMD vector.

​arg (SIMD[type, simd_width]): The input argument.





url:https://docs.modular.com/mojo/stdlib/math/math/exp
function

exp

exp[type: DType, simd_width: Int](x: SIMD[type, simd_width]) -> SIMD[$0, $1]

Calculates elementwise exponential of the input vector.

Given an input vector XXX and an output vector YYY, sets Yi=eXiY_i = e^{X_i}Yi​=eXi​ for
each position iii in the input vector (where eee is the mathmatical constant
eee).

Parameters:

Args:

Returns:

A SIMD vector containing eee raised to the power XiX_iXi​ where XiX_iXi​ is an element in the input SIMD vector.

​type (DType): The dtype of the input and output SIMD vector. Constraints: must be a floating-point type.
​simd_width (Int): The width of the input and output SIMD vector.

​x (SIMD[type, simd_width]): The input SIMD vector.





url:https://docs.modular.com/mojo/stdlib/math/math/exp2
function

exp2

exp2[type: DType, simd_width: Int](x: SIMD[type, simd_width]) -> SIMD[$0, $1]

Computes elementwise 2 raised to the power of n, where n is an element of the input SIMD vector.

Parameters:

Args:

Returns:

Vector containing 2n2^n2n computed elementwise, where n is an element in the input SIMD vector.

​type (DType): The dtype of the input and output SIMD vector.
​simd_width (Int): The width of the input and output SIMD vector.

​x (SIMD[type, simd_width]): SIMD vector to perform exp2 on.





url:https://docs.modular.com/mojo/stdlib/math/math/expm1
function

expm1

expm1[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[$0, $1]

Computes the expm1 of the inputs.

Parameters:

Args:

Returns:

The expm1 of the input.

​type (DType): The dtype of the input and output SIMD vector. Constraints: must be a floating-point type.
​simd_width (Int): The width of the input and output SIMD vector.

​arg (SIMD[type, simd_width]): The input argument.





url:https://docs.modular.com/mojo/stdlib/math/math/factorial
function

factorial

factorial(n: Int) -> Int

Computes the factorial of the integer.

Args:

Returns:

The factorial of the input. Results are undefined if the input is negative.

​n (Int): The input value. Must be non-negative.





url:https://docs.modular.com/mojo/stdlib/math/math/floor
function

floor

floor[T: Floorable](value: T) -> $0

Get the floor value of the given object.

Parameters:

Args:

Returns:

The floor value of the object.

​T (Floorable): The type conforming to Floorable.

​value (T): The object to get the floor value of.





url:https://docs.modular.com/mojo/stdlib/math/math/fma
function

fma

fma(a: Int, b: Int, c: Int) -> Int

Performs fma (fused multiply-add) on the inputs.

The result is (a * b) + c.

Args:

Returns:

(a * b) + c.

​a (Int): The first input.
​b (Int): The second input.
​c (Int): The third input.





url:https://docs.modular.com/mojo/stdlib/math/math/frexp
function

frexp

frexp[type: DType, simd_width: Int](x: SIMD[type, simd_width]) -> StaticTuple[SIMD[$0, $1], 2]

Breaks floating point values into a fractional part and an exponent part.

Parameters:

Args:

Returns:

A tuple of two SIMD vectors containing the fractional and exponent parts of the input floating point values.

​type (DType): The dtype of the input and output SIMD vector. Constraints: must be a floating-point type.
​simd_width (Int): The width of the input and output SIMD vector.

​x (SIMD[type, simd_width]): The input values.





url:https://docs.modular.com/mojo/stdlib/math/math/gamma
function

gamma

gamma(x: SIMD[type, size]) -> SIMD[$0, $1]

Computes the Gamma of the input.

For details, see https://en.wikipedia.org/wiki/Gamma_function.

Constraints:

The input must be a floating-point type.

Args:

Returns:

The Gamma function evaluated at the input.

​x (SIMD[type, size]): The input argument.





url:https://docs.modular.com/mojo/stdlib/math/math/gcd
function

gcd

gcd(m: Int, n: Int, /) -> Int

Compute the greatest common divisor of two integers.

Args:

Returns:

The greatest common divisor of the two integers.

​m (Int): The first integer.
​n (Int): The second integrer.





url:https://docs.modular.com/mojo/stdlib/math/math/hypot
function

hypot

hypot[type: DType, simd_width: Int](arg0: SIMD[type, simd_width], arg1: SIMD[type, simd_width]) -> SIMD[$0, $1]

Computes the hypot of the inputs.

Parameters:

Args:

Returns:

The hypot of the inputs.

​type (DType): The dtype of the input and output SIMD vector. Constraints: must be a floating-point type.
​simd_width (Int): The width of the input and output SIMD vector.

​arg0 (SIMD[type, simd_width]): The first input argument.
​arg1 (SIMD[type, simd_width]): The second input argument.





url:https://docs.modular.com/mojo/stdlib/math/math/iota
function

iota

iota[type: DType, simd_width: Int]() -> SIMD[$0, $1]

Creates a SIMD vector containing an increasing sequence, starting from 0.

Parameters:

Returns:

An increasing sequence of values, starting from 0.

​type (DType): The dtype of the input and output SIMD vector.
​simd_width (Int): The width of the input and output SIMD vector.





url:https://docs.modular.com/mojo/stdlib/math/math/isclose
function

isclose

isclose[type: DType, simd_width: Int](a: SIMD[type, simd_width], b: SIMD[type, simd_width], *, atol: SIMD[type, 1] = #kgen.float_literal<1|100000000>, rtol: SIMD[type, 1] = #kgen.float_literal<1|100000>, equal_nan: Bool = 0) -> SIMD[bool, $1]

Checks if the two input values are numerically within a tolerance.

When the type is integral, then equality is checked. When the type is
floating point, then this checks if the two input values are numerically the
close using the abs(a−b)<=max(rtol∗max(abs(a),abs(b)),atol)abs(a - b) <= max(rtol * max(abs(a), abs(b)), atol)abs(a−b)<=max(rtol∗max(abs(a),abs(b)),atol)
formula.

Unlike Pythons's math.isclose, this implementation is symmetric. I.e.
isclose(a,b) == isclose(b,a).

Parameters:

Args:

Returns:

A boolean vector where a and b are equal within the specified tolerance.

​type (DType): The dtype of the input and output SIMD vector.
​simd_width (Int): The width of the input and output SIMD vector.

​a (SIMD[type, simd_width]): The first value to compare.
​b (SIMD[type, simd_width]): The second value to compare.
​atol (SIMD[type, 1]): The absolute tolerance.
​rtol (SIMD[type, 1]): The relative tolerance.
​equal_nan (Bool): Whether to treat nans as equal.





url:https://docs.modular.com/mojo/stdlib/math/math/j0
function

j0

j0[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[$0, $1]

Computes the Bessel function of the first kind of order 0 for each input value.

Parameters:

Args:

Returns:

A vector containing the computed value for each value in the input vector.

​type (DType): The dtype of the input and output SIMD vector. Constraints: must be a floating-point type.
​simd_width (Int): The width of the input and output SIMD vector.

​arg (SIMD[type, simd_width]): The input vector.





url:https://docs.modular.com/mojo/stdlib/math/math/j1
function

j1

j1[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[$0, $1]

Computes the Bessel function of the first kind of order 1 for each input value.

Parameters:

Args:

Returns:

A vector containing the computed value for each value in the input vector.

​type (DType): The dtype of the input and output SIMD vector. Constraints: must be a floating-point type.
​simd_width (Int): The width of the input and output SIMD vector.

​arg (SIMD[type, simd_width]): The input vector.





url:https://docs.modular.com/mojo/stdlib/math/math/lcm
function

lcm

lcm(a: Int, b: Int) -> Int

Computes the least common multiple of two integers.

Args:

Returns:

The least common multiple of the inputs. Results are undefined if either input is negative.

​a (Int): The first input argument. Must be non-negative.
​b (Int): The second input argument. Must be non-negative.





url:https://docs.modular.com/mojo/stdlib/math/math/ldexp
function

ldexp

ldexp[type: DType, simd_width: Int](x: SIMD[type, simd_width], exp: SIMD[int32, simd_width]) -> SIMD[$0, $1]

Computes elementwise ldexp function.

The ldexp function multiplies a floating point value x by the number 2
raised to the exp power. I.e. ldexp(x,exp)ldexp(x,exp)ldexp(x,exp) calculate the value of x∗2expx * 2^{exp}x∗2exp and is used within the erferferf function.

Parameters:

Args:

Returns:

Vector containing elementwise result of ldexp on x and exp.

​type (DType): The dtype of the input and output SIMD vector.
​simd_width (Int): The width of the input and output SIMD vector.

​x (SIMD[type, simd_width]): SIMD vector of floating point values.
​exp (SIMD[int32, simd_width]): SIMD vector containing the exponents.





url:https://docs.modular.com/mojo/stdlib/math/math/lgamma
function

lgamma

lgamma[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[$0, $1]

Computes the lgamma of the inputs.

Parameters:

Args:

Returns:

The lgamma of the input.

​type (DType): The dtype of the input and output SIMD vector. Constraints: must be a floating-point type.
​simd_width (Int): The width of the input and output SIMD vector.

​arg (SIMD[type, simd_width]): The input argument.





url:https://docs.modular.com/mojo/stdlib/math/math/log
function

log

log[type: DType, simd_width: Int](x: SIMD[type, simd_width]) -> SIMD[$0, $1]

Performs elementwise natural log (base E) of a SIMD vector.

Parameters:

Args:

Returns:

Vector containing result of performing natural log base E on x.

​type (DType): The dtype of the input and output SIMD vector.
​simd_width (Int): The width of the input and output SIMD vector.

​x (SIMD[type, simd_width]): Vector to perform logarithm operation on.





url:https://docs.modular.com/mojo/stdlib/math/math/log10
function

log10

log10[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[$0, $1]

Computes the log10 of the inputs.

Parameters:

Args:

Returns:

The log10 of the input.

​type (DType): The dtype of the input and output SIMD vector. Constraints: must be a floating-point type.
​simd_width (Int): The width of the input and output SIMD vector.

​arg (SIMD[type, simd_width]): The input argument.





url:https://docs.modular.com/mojo/stdlib/math/math/log1p
function

log1p

log1p[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[$0, $1]

Computes the log1p of the inputs.

Parameters:

Args:

Returns:

The log1p of the input.

​type (DType): The dtype of the input and output SIMD vector. Constraints: must be a floating-point type.
​simd_width (Int): The width of the input and output SIMD vector.

​arg (SIMD[type, simd_width]): The input argument.





url:https://docs.modular.com/mojo/stdlib/math/math/log2
function

log2

log2[type: DType, simd_width: Int](x: SIMD[type, simd_width]) -> SIMD[$0, $1]

Performs elementwise log (base 2) of a SIMD vector.

Parameters:

Args:

Returns:

Vector containing result of performing log base 2 on x.

​type (DType): The dtype of the input and output SIMD vector.
​simd_width (Int): The width of the input and output SIMD vector.

​x (SIMD[type, simd_width]): Vector to perform logarithm operation on.





url:https://docs.modular.com/mojo/stdlib/math/math/logb
function

logb

logb[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[$0, $1]

Computes the logb of the inputs.

Parameters:

Args:

Returns:

The logb of the input.

​type (DType): The dtype of the input and output SIMD vector. Constraints: must be a floating-point type.
​simd_width (Int): The width of the input and output SIMD vector.

​arg (SIMD[type, simd_width]): The input argument.





url:https://docs.modular.com/mojo/stdlib/math/math/remainder
function

remainder

remainder[type: DType, simd_width: Int](arg0: SIMD[type, simd_width], arg1: SIMD[type, simd_width]) -> SIMD[$0, $1]

Computes the remainder of the inputs.

Parameters:

Args:

Returns:

The remainder of the inputs.

​type (DType): The dtype of the input and output SIMD vector. Constraints: must be a floating-point type.
​simd_width (Int): The width of the input and output SIMD vector.

​arg0 (SIMD[type, simd_width]): The first input argument.
​arg1 (SIMD[type, simd_width]): The second input argument.





url:https://docs.modular.com/mojo/stdlib/math/math/rsqrt
function

rsqrt

rsqrt[type: DType, simd_width: Int](x: SIMD[type, simd_width]) -> SIMD[$0, $1]

Performs elementwise reciprocal square root on the elements of a SIMD vector.

Parameters:

Args:

Returns:

The elementwise reciprocal square root of x.

​type (DType): The dtype of the input and output SIMD vector.
​simd_width (Int): The width of the input and output SIMD vector.

​x (SIMD[type, simd_width]): SIMD vector to perform reciprocal square root on.





url:https://docs.modular.com/mojo/stdlib/math/math/scalb
function

scalb

scalb[type: DType, simd_width: Int](arg0: SIMD[type, simd_width], arg1: SIMD[type, simd_width]) -> SIMD[$0, $1]

Computes the scalb of the inputs.

Parameters:

Args:

Returns:

The scalb of the inputs.

​type (DType): The dtype of the input and output SIMD vector. Constraints: must be a floating-point type.
​simd_width (Int): The width of the input and output SIMD vector.

​arg0 (SIMD[type, simd_width]): The first input argument.
​arg1 (SIMD[type, simd_width]): The second input argument.





url:https://docs.modular.com/mojo/stdlib/math/math/sin
function

sin

sin[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[$0, $1]

Computes the sin of the inputs.

Parameters:

Args:

Returns:

The sin of the input.

​type (DType): The dtype of the input and output SIMD vector. Constraints: must be a floating-point type.
​simd_width (Int): The width of the input and output SIMD vector.

​arg (SIMD[type, simd_width]): The input argument.





url:https://docs.modular.com/mojo/stdlib/math/math/sinh
function

sinh

sinh[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[$0, $1]

Computes the sinh of the inputs.

Parameters:

Args:

Returns:

The sinh of the input.

​type (DType): The dtype of the input and output SIMD vector. Constraints: must be a floating-point type.
​simd_width (Int): The width of the input and output SIMD vector.

​arg (SIMD[type, simd_width]): The input argument.





url:https://docs.modular.com/mojo/stdlib/math/math/sqrt
function

sqrt

sqrt(x: Int) -> Int

Performs square root on an integer.

Args:

Returns:

The square root of x.

​x (Int): The integer value to perform square root on.





url:https://docs.modular.com/mojo/stdlib/math/math/tan
function

tan

tan[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[$0, $1]

Computes the tan of the inputs.

Parameters:

Args:

Returns:

The tan of the input.

​type (DType): The dtype of the input and output SIMD vector. Constraints: must be a floating-point type.
​simd_width (Int): The width of the input and output SIMD vector.

​arg (SIMD[type, simd_width]): The input argument.





url:https://docs.modular.com/mojo/stdlib/math/math/tanh
function

tanh

tanh[type: DType, simd_width: Int](x: SIMD[type, simd_width]) -> SIMD[$0, $1]

Performs elementwise evaluation of the tanh function.

Parameters:

Args:

Returns:

The result of the elementwise tanh operation.

​type (DType): The dtype of the input and output SIMD vector.
​simd_width (Int): The width of the input and output SIMD vector.

​x (SIMD[type, simd_width]): The vector to perform the elementwise tanh on.





url:https://docs.modular.com/mojo/stdlib/math/math/trunc
function

trunc

trunc[T: Truncable](value: T) -> $0

Get the truncated value of the given object.

Parameters:

Args:

Returns:

The truncated value of the object.

​T (Truncable): The type conforming to Truncable.

​value (T): The object to get the truncated value of.





url:https://docs.modular.com/mojo/stdlib/math/math/y0
function

y0

y0[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[$0, $1]

Computes the Bessel function of the second kind of order 0 for each input value.

Parameters:

Args:

Returns:

A vector containing the computed value for each value in the input vector.

​type (DType): The dtype of the input and output SIMD vector. Constraints: must be a floating-point type.
​simd_width (Int): The width of the input and output SIMD vector.

​arg (SIMD[type, simd_width]): The input vector.





url:https://docs.modular.com/mojo/stdlib/math/math/y1
function

y1

y1[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[$0, $1]

Computes the Bessel function of the second kind of order 1 for each input value.

Parameters:

Args:

Returns:

A vector containing the computed value for each value in the input vector.

​type (DType): The dtype of the input and output SIMD vector. Constraints: must be a floating-point type.
​simd_width (Int): The width of the input and output SIMD vector.

​arg (SIMD[type, simd_width]): The input vector.





url:https://docs.modular.com/mojo/stdlib/math/polynomial/
module

polynomial





url:https://docs.modular.com/mojo/stdlib/math/polynomial/polynomial_evaluate
function

polynomial_evaluate

polynomial_evaluate[dtype: DType, simd_width: Int, +, coefficients: List[SIMD[$0, $1]]](x: SIMD[dtype, simd_width]) -> SIMD[$0, $1]

Evaluates the polynomial.

Parameters:

Args:

Returns:

The polynomial evaluation results using the specified value and the constant coefficients.

​dtype (DType): The dtype of the value.
​simd_width (Int): The simd_width of the computed value.
​coefficients (List[SIMD[$0, $1]]): The coefficients.

​x (SIMD[dtype, simd_width]): The value to compute the polynomial with.





url:https://docs.modular.com/mojo/stdlib/memory/
package

memory





url:https://docs.modular.com/mojo/stdlib/memory/arc/
module

arc





url:https://docs.modular.com/mojo/stdlib/memory/arc/Arc
struct

Arc

__init__(inout self: Self, owned value: T)

Construct a new thread-safe, reference-counted smart pointer, and move the value into heap memory managed by the new pointer.

Args:

​value (T): The value to manage.

__init__(inout self: Self, owned value: T)

Construct a new thread-safe, reference-counted smart pointer, and move the value into heap memory managed by the new pointer.

Args:

​value (T): The value to manage.

__init__(inout self: Self, owned value: T)

Construct a new thread-safe, reference-counted smart pointer, and move the value into heap memory managed by the new pointer.

Args:

​value (T): The value to manage.

__copyinit__(inout self: Self, existing: Self)

Copy an existing reference. Increment the refcount to the object.

Args:

​existing (Self): The existing reference.

__del__(owned self: Self)

Delete the smart pointer reference.

Decrement the ref count for the reference. If there are no more
references, delete the object and free its memory.

__getitem__(self: Reference[Arc[T], is_mutable, lifetime, 0]) -> ref [$1] T

Returns a Reference to the managed value.

Returns:

A Reference to the managed value.

as_ptr(self: Self) -> UnsafePointer[T, 0]

Retrieves a pointer to the underlying memory.

Returns:

The UnsafePointer to the underlying memory.





url:https://docs.modular.com/mojo/stdlib/memory/memory/
module

memory





url:https://docs.modular.com/mojo/stdlib/memory/memory/memcmp
function

memcmp

memcmp(s1: DTypePointer[type, address_space], s2: DTypePointer[type, address_space], count: Int) -> Int

Compares two buffers. Both strings are assumed to be of the same length.

Args:

Returns:

Returns 0 if the bytes buffers are identical, 1 if s1 > s2, and -1 if s1 < s2. The comparison is performed by the first different byte in the buffer.

​s1 (DTypePointer[type, address_space]): The first buffer address.
​s2 (DTypePointer[type, address_space]): The second buffer address.
​count (Int): The number of elements in the buffers.





url:https://docs.modular.com/mojo/stdlib/memory/memory/memcpy
function

memcpy

memcpy[count: Int](dest: LegacyPointer[type, address_space], src: LegacyPointer[type, address_space])

Copies a memory area.

Parameters:

Args:

​count (Int): The number of elements to copy (not bytes!).

​dest (LegacyPointer[type, address_space]): The destination pointer.
​src (LegacyPointer[type, address_space]): The source pointer.





url:https://docs.modular.com/mojo/stdlib/memory/memory/memset
function

memset

memset[type: DType, address_space: AddressSpace](ptr: DTypePointer[type, address_space], value: SIMD[uint8, 1], count: Int)

Fills memory with the given value.

Parameters:

Args:

​type (DType): The element dtype.
​address_space (AddressSpace): The address space of the pointer.

​ptr (DTypePointer[type, address_space]): Pointer to the beginning of the memory block to fill.
​value (SIMD[uint8, 1]): The value to fill with.
​count (Int): Number of elements to fill (in elements, not bytes).





url:https://docs.modular.com/mojo/stdlib/memory/memory/memset_zero
function

memset_zero

memset_zero[type: DType, address_space: AddressSpace](ptr: DTypePointer[type, address_space], count: Int)

Fills memory with zeros.

Parameters:

Args:

​type (DType): The element dtype.
​address_space (AddressSpace): The address space of the pointer.

​ptr (DTypePointer[type, address_space]): Pointer to the beginning of the memory block to fill.
​count (Int): Number of elements to set (in elements, not bytes).





url:https://docs.modular.com/mojo/stdlib/memory/memory/stack_allocation
function

stack_allocation

stack_allocation[count: Int, type: DType, /, alignment: Int = 1, address_space: AddressSpace = 0]() -> DTypePointer[$1, $3]

Allocates data buffer space on the stack given a data type and number of elements.

Parameters:

Returns:

A data pointer of the given type pointing to the allocated space.

​count (Int): Number of elements to allocate memory for.
​type (DType): The data type of each element.
​alignment (Int): Address alignment of the allocated data.
​address_space (AddressSpace): The address space of the pointer.





url:https://docs.modular.com/mojo/stdlib/memory/reference/
module

reference





url:https://docs.modular.com/mojo/stdlib/memory/reference/AddressSpace
struct

AddressSpace

__init__(inout self: Self, value: Int)

Initializes the address space from the underlying integral value.

Args:

​value (Int): The address space value.

__init__(inout self: Self, value: Int)

Initializes the address space from the underlying integral value.

Args:

​value (Int): The address space value.

__init__(inout self: Self, value: Int)

Initializes the address space from the underlying integral value.

Args:

​value (Int): The address space value.

__eq__(self: Self, other: Self) -> Bool

True if the two address spaces are equal and False otherwise.

Args:

Returns:

True if the two address spaces are equal and False otherwise.

​other (Self): The other address space value.

__ne__(self: Self, other: Self) -> Bool

True if the two address spaces are inequal and False otherwise.

Args:

Returns:

True if the two address spaces are inequal and False otherwise.

​other (Self): The other address space value.

value(self: Self) -> Int

The integral value of the address space.

Returns:

The integral value of the address space.





url:https://docs.modular.com/mojo/stdlib/memory/reference/Reference
struct

Reference

__init__(inout self: Self, value: !lit.ref<:trait<_stdlib::_builtin::_anytype::_AnyType> *"type", mut=#lit.struct.extract<:_stdlib::_builtin::_bool::_Bool is_mutable, "value">, lifetime, #lit.struct.extract<:_stdlib::_builtin::_int::_Int #lit.struct.extract<:_stdlib::_memory::_reference::_AddressSpace address_space, "_value">, "value">>)

Constructs a Reference from the MLIR reference.

Args:

​value (!lit.ref<:trait<_stdlib::_builtin::_anytype::_AnyType> *"type", mut=#lit.struct.extract<:_stdlib::_builtin::_bool::_Bool is_mutable, "value">, lifetime, #lit.struct.extract<:_stdlib::_builtin::_int::_Int #lit.struct.extract<:_stdlib::_memory::_reference::_AddressSpace address_space, "_value">, "value">>): The MLIR reference.

__init__(inout self: Self, value: !lit.ref<:trait<_stdlib::_builtin::_anytype::_AnyType> *"type", mut=#lit.struct.extract<:_stdlib::_builtin::_bool::_Bool is_mutable, "value">, lifetime, #lit.struct.extract<:_stdlib::_builtin::_int::_Int #lit.struct.extract<:_stdlib::_memory::_reference::_AddressSpace address_space, "_value">, "value">>)

Constructs a Reference from the MLIR reference.

Args:

​value (!lit.ref<:trait<_stdlib::_builtin::_anytype::_AnyType> *"type", mut=#lit.struct.extract<:_stdlib::_builtin::_bool::_Bool is_mutable, "value">, lifetime, #lit.struct.extract<:_stdlib::_builtin::_int::_Int #lit.struct.extract<:_stdlib::_memory::_reference::_AddressSpace address_space, "_value">, "value">>): The MLIR reference.

__init__(inout self: Self, value: !lit.ref<:trait<_stdlib::_builtin::_anytype::_AnyType> *"type", mut=#lit.struct.extract<:_stdlib::_builtin::_bool::_Bool is_mutable, "value">, lifetime, #lit.struct.extract<:_stdlib::_builtin::_int::_Int #lit.struct.extract<:_stdlib::_memory::_reference::_AddressSpace address_space, "_value">, "value">>)

Constructs a Reference from the MLIR reference.

Args:

​value (!lit.ref<:trait<_stdlib::_builtin::_anytype::_AnyType> *"type", mut=#lit.struct.extract<:_stdlib::_builtin::_bool::_Bool is_mutable, "value">, lifetime, #lit.struct.extract<:_stdlib::_builtin::_int::_Int #lit.struct.extract<:_stdlib::_memory::_reference::_AddressSpace address_space, "_value">, "value">>): The MLIR reference.

__getitem__(self: Self) -> ref [lifetime] type

Enable subscript syntax ref[] to access the element.

Returns:

The MLIR reference for the Mojo compiler to use.





url:https://docs.modular.com/mojo/stdlib/memory/unsafe/
module

unsafe





url:https://docs.modular.com/mojo/stdlib/memory/unsafe/DTypePointer
struct

DTypePointer

__init__(inout self: Self)

Constructs a null DTypePointer from the given type.

__init__(inout self: Self)

Constructs a null DTypePointer from the given type.

__init__(inout self: Self)

Constructs a null DTypePointer from the given type.

__bool__(self: Self) -> Bool

Checks if the DTypePointer is null.

Returns:

Returns False if the DTypePointer is null and True otherwise.

__getitem__(self: Self, offset: Int) -> SIMD[type, 1]

Loads a single element (SIMD of size 1) from the pointer at the specified index.

Args:

Returns:

The loaded value.

​offset (Int): The offset to load from.

__setitem__(self: Self, offset: Int, val: SIMD[type, 1])

Stores a single element value at the given offset.

Args:

​offset (Int): The offset to store to.
​val (SIMD[type, 1]): The value to store.

__lt__(self: Self, rhs: Self) -> Bool

Returns True if this pointer represents a lower address than rhs.

Args:

Returns:

True if this pointer represents a lower address and False otherwise.

​rhs (Self): The value of the other pointer.

__eq__(self: Self, rhs: Self) -> Bool

Returns True if the two pointers are equal.

Args:

Returns:

True if the two pointers are equal and False otherwise.

​rhs (Self): The value of the other pointer.

__ne__(self: Self, rhs: Self) -> Bool

Returns True if the two pointers are not equal.

Args:

Returns:

True if the two pointers are not equal and False otherwise.

​rhs (Self): The value of the other pointer.

__add__[T: Intable](self: Self, rhs: T) -> Self

Returns a new pointer shifted by the specified offset.

Parameters:

Args:

Returns:

The new DTypePointer shifted by the offset.

​T (Intable): The Intable type of the offset.

​rhs (T): The offset.

__sub__[T: Intable](self: Self, rhs: T) -> Self

Returns a new pointer shifted back by the specified offset.

Parameters:

Args:

Returns:

The new DTypePointer shifted by the offset.

​T (Intable): The Intable type of the offset.

​rhs (T): The offset.

__iadd__[T: Intable](inout self: Self, rhs: T)

Shifts the current pointer by the specified offset.

Parameters:

Args:

​T (Intable): The Intable type of the offset.

​rhs (T): The offset.

__isub__[T: Intable](inout self: Self, rhs: T)

Shifts back the current pointer by the specified offset.

Parameters:

Args:

​T (Intable): The Intable type of the offset.

​rhs (T): The offset.

static address_of(arg: Reference[SIMD[type, 1], is_mutable, lifetime, address_space]) -> Self

Gets the address of the argument.

Args:

Returns:

A DTypePointer struct which contains the address of the argument.

​arg (Reference[SIMD[type, 1], is_mutable, lifetime, address_space]): The value to get the address of.

static alloc(count: Int, /, *, alignment: Int = alignof[stdlib::builtin::dtype::DType,__mlir_type.!kgen.target]()) -> Self

Heap-allocates a number of element of the specified type using the specified alignment.

Args:

Returns:

A new DTypePointer object which has been allocated on the heap.

​count (Int): The number of elements to allocate (note that this is not the bytecount).
​alignment (Int): The alignment used for the allocation.

free(self: Self)

Frees the heap allocates memory.

bitcast[new_type: DType = type, /, address_space: AddressSpace = address_space](self: Self) -> DTypePointer[$0, $1]

Bitcasts DTypePointer to a different dtype.

Parameters:

Returns:

A new DTypePointer object with the specified dtype and the same address, as the original DTypePointer.

​new_type (DType): The target dtype.
​address_space (AddressSpace): The address space of the result.

prefetch[params: PrefetchOptions](self: Self)

Prefetches memory at the underlying address.

Parameters:

​params (PrefetchOptions): Prefetch options (see PrefetchOptions for details).

load[*, width: Int = 1, alignment: Int = alignof[stdlib::builtin::anytype::AnyType,__mlir_type.!kgen.target]() if triple_is_nvidia_cuda() else 1](self: Self) -> SIMD[type, $0]

Loads the value the Pointer object points to.

Constraints:

The width and alignment must be positive integer values.

Parameters:

Returns:

The loaded value.

​width (Int): The SIMD width.
​alignment (Int): The minimal alignment of the address.

store[T: Intable, /, *, width: Int = 1, alignment: Int = alignof[stdlib::builtin::anytype::AnyType,__mlir_type.!kgen.target]() if triple_is_nvidia_cuda() else 1](self: Self, offset: T, val: SIMD[type, width])

Stores a single element value at the given offset.

Constraints:

The width and alignment must be positive integer values.

Parameters:

Args:

​T (Intable): The Intable type of the offset.
​width (Int): The SIMD width.
​alignment (Int): The minimal alignment of the address.

​offset (T): The offset to store to.
​val (SIMD[type, width]): The value to store.

simd_nt_store[width: Int, T: Intable](self: Self, offset: T, val: SIMD[type, width])

Stores a SIMD vector using non-temporal store.

Parameters:

Args:

​width (Int): The SIMD width.
​T (Intable): The Intable type of the offset.

​offset (T): The offset to store to.
​val (SIMD[type, width]): The SIMD value to store.

simd_strided_load[width: Int, T: Intable](self: Self, stride: T) -> SIMD[type, $0]

Performs a strided load of the SIMD vector.

Parameters:

Args:

Returns:

A vector which is stride loaded.

​width (Int): The SIMD width.
​T (Intable): The Intable type of the stride.

​stride (T): The stride between loads.

simd_strided_store[width: Int, T: Intable](self: Self, val: SIMD[type, width], stride: T)

Performs a strided store of the SIMD vector.

Parameters:

Args:

​width (Int): The SIMD width.
​T (Intable): The Intable type of the stride.

​val (SIMD[type, width]): The SIMD value to store.
​stride (T): The stride between stores.

gather[*, width: Int = 1, alignment: Int = alignof[stdlib::builtin::anytype::AnyType,__mlir_type.!kgen.target]() if triple_is_nvidia_cuda() else 1](self: Self, offset: SIMD[type, width]) -> SIMD[type, $0]

Gathers a SIMD vector from offsets of the current pointer.

This method loads from memory addresses calculated by appropriately
shifting the current pointer according to the offset SIMD vector.

Constraints:

The offset type must be an integral type. The alignment must be a power of two integer value.

Parameters:

Args:

Returns:

The SIMD vector containing the gathered values.

​width (Int): The SIMD width.
​alignment (Int): The minimal alignment of the address.

​offset (SIMD[type, width]): The SIMD vector of offsets to gather from.

scatter[*, width: Int = 1, alignment: Int = alignof[stdlib::builtin::anytype::AnyType,__mlir_type.!kgen.target]() if triple_is_nvidia_cuda() else 1](self: Self, offset: SIMD[type, width], val: SIMD[type, width])

Scatters a SIMD vector into offsets of the current pointer.

This method stores at memory addresses calculated by appropriately
shifting the current pointer according to the offset SIMD vector.

If the same offset is targeted multiple times, the values are stored
in the order they appear in the val SIMD vector, from the first to
the last element.

Constraints:

The offset type must be an integral type. The alignment must be a power of two integer value.

Parameters:

Args:

​width (Int): The SIMD width.
​alignment (Int): The minimal alignment of the address.

​offset (SIMD[type, width]): The SIMD vector of offsets to scatter into.
​val (SIMD[type, width]): The SIMD vector containing the values to be scattered.

is_aligned[alignment: Int](self: Self) -> Bool

Checks if the pointer is aligned.

Parameters:

Returns:

True if the pointer is at least alignment-aligned or False otherwise.

​alignment (Int): The minimal desired alignment.

offset[T: Intable](self: Self, idx: T) -> Self

Returns a new pointer shifted by the specified offset.

Parameters:

Args:

Returns:

The new constructed DTypePointer.

​T (Intable): The Intable type of the offset.

​idx (T): The offset of the new pointer.





url:https://docs.modular.com/mojo/stdlib/memory/unsafe/LegacyPointer
struct

LegacyPointer

__init__() -> Self

Constructs a null LegacyPointer from the value of pop.pointer type.

Returns:

Constructed LegacyPointer object.

__init__() -> Self

Constructs a null LegacyPointer from the value of pop.pointer type.

Returns:

Constructed LegacyPointer object.

__init__() -> Self

Constructs a null LegacyPointer from the value of pop.pointer type.

Returns:

Constructed LegacyPointer object.

__bool__(self: Self) -> Bool

Checks if the LegacyPointer is null.

Returns:

Returns False if the LegacyPointer is null and True otherwise.

__getitem__(self: Self) -> ref [#lit.lifetime] type

Enable subscript syntax ptr[] to access the element.

Returns:

The reference for the Mojo compiler to use.

__lt__(self: Self, rhs: Self) -> Bool

Returns True if this pointer represents a lower address than rhs.

Args:

Returns:

True if this pointer represents a lower address and False otherwise.

​rhs (Self): The value of the other pointer.

__eq__(self: Self, rhs: Self) -> Bool

Returns True if the two pointers are equal.

Args:

Returns:

True if the two pointers are equal and False otherwise.

​rhs (Self): The value of the other pointer.

__ne__(self: Self, rhs: Self) -> Bool

Returns True if the two pointers are not equal.

Args:

Returns:

True if the two pointers are not equal and False otherwise.

​rhs (Self): The value of the other pointer.

__add__[T: Intable](self: Self, rhs: T) -> Self

Returns a new pointer shifted by the specified offset.

Parameters:

Args:

Returns:

The new LegacyPointer shifted by the offset.

​T (Intable): The Intable type of the offset.

​rhs (T): The offset.

__sub__[T: Intable](self: Self, rhs: T) -> Self

Returns a new pointer shifted back by the specified offset.

Parameters:

Args:

Returns:

The new LegacyPointer shifted back by the offset.

​T (Intable): The Intable type of the offset.

​rhs (T): The offset.

__iadd__[T: Intable](inout self: Self, rhs: T)

Shifts the current pointer by the specified offset.

Parameters:

Args:

​T (Intable): The Intable type of the offset.

​rhs (T): The offset.

__isub__[T: Intable](inout self: Self, rhs: T)

Shifts back the current pointer by the specified offset.

Parameters:

Args:

​T (Intable): The Intable type of the offset.

​rhs (T): The offset.

static address_of(arg: Reference[type, is_mutable, lifetime, address_space]) -> Self

Gets the address of the argument.

Args:

Returns:

A LegacyPointer struct which contains the address of the argument.

​arg (Reference[type, is_mutable, lifetime, address_space]): The value to get the address of.

load[*, alignment: Int = alignof[stdlib::builtin::anytype::AnyType,__mlir_type.!kgen.target]() if triple_is_nvidia_cuda() else 1](self: Self) -> type

Loads the value the LegacyPointer object points to.

Constraints:

The alignment must be a positive integer value.

Parameters:

Returns:

The loaded value.

​alignment (Int): The minimal alignment of the address.

store[T: Intable, /, *, alignment: Int = alignof[stdlib::builtin::anytype::AnyType,__mlir_type.!kgen.target]() if triple_is_nvidia_cuda() else 1](self: Self, offset: T, value: type)

Stores the specified value to the location the LegacyPointer object points to with the given offset.

Constraints:

The alignment must be a positive integer value.

Parameters:

Args:

​T (Intable): The Intable type of the offset.
​alignment (Int): The minimal alignment of the address.

​offset (T): The offset to store to.
​value (type): The value to store.

nt_store(self: Self, value: type)

Stores a value using non-temporal store.

The address must be properly aligned, 64B for avx512, 32B for avx2, and
16B for avx.

Args:

​value (type): The value to store.

static alloc(count: Int, /, *, alignment: Int = alignof[stdlib::builtin::anytype::AnyType,__mlir_type.!kgen.target]()) -> Self

Heap-allocates a number of element of the specified type using the specified alignment.

Args:

Returns:

A new LegacyPointer object which has been allocated on the heap.

​count (Int): The number of elements to allocate (note that this is not the bytecount).
​alignment (Int): The alignment used for the allocation.

free(self: Self)

Frees the heap allocated memory.

bitcast[new_type: AnyTrivialRegType = type, /, address_space: AddressSpace = address_space](self: Self) -> LegacyPointer[$0, $1]

Bitcasts a LegacyPointer to a different type.

Parameters:

Returns:

A new LegacyPointer object with the specified type and the same address, as the original LegacyPointer.

​new_type (AnyTrivialRegType): The target type.
​address_space (AddressSpace): The address space of the result.

offset[T: Intable](self: Self, idx: T) -> Self

Returns a new pointer shifted by the specified offset.

Parameters:

Args:

Returns:

The new LegacyPointer shifted by the offset.

​T (Intable): The Intable type of the offset.

​idx (T): The offset.





url:https://docs.modular.com/mojo/stdlib/memory/unsafe/bitcast
function

bitcast

bitcast[new_type: DType, new_width: Int, src_type: DType, src_width: Int](val: SIMD[src_type, src_width]) -> SIMD[$0, $1]

Bitcasts a SIMD value to another SIMD value.

Constraints:

The bitwidth of the two types must be the same.

Parameters:

Args:

Returns:

A new SIMD value with the specified type and width with a bitcopy of the source SIMD value.

​new_type (DType): The target type.
​new_width (Int): The target width.
​src_type (DType): The source type.
​src_width (Int): The source width.

​val (SIMD[src_type, src_width]): The source value.





url:https://docs.modular.com/mojo/stdlib/memory/unsafe_pointer/
module

unsafe_pointer





url:https://docs.modular.com/mojo/stdlib/memory/unsafe_pointer/UnsafePointer
struct

UnsafePointer

__init__() -> Self

Create a null pointer.

Returns:

A null pointer.

__init__() -> Self

Create a null pointer.

Returns:

A null pointer.

__init__() -> Self

Create a null pointer.

Returns:

A null pointer.

__bool__(self: Self) -> Bool

Return true if the pointer is non-null.

Returns:

Whether the pointer is null.

__getitem__(self: Self) -> ref [#lit.lifetime] T

Return a reference to the underlying data.

Returns:

A reference to the value.

__lt__(self: Self, rhs: Self) -> Bool

Returns True if this pointer represents a lower address than rhs.

Args:

Returns:

True if this pointer represents a lower address and False otherwise.

​rhs (Self): The value of the other pointer.

__le__(self: Self, rhs: Self) -> Bool

Returns True if this pointer represents a lower than or equal    address than rhs.

Args:

Returns:

True if this pointer represents a lower address and False otherwise.

​rhs (Self): The value of the other pointer.

__eq__(self: Self, rhs: Self) -> Bool

Returns True if the two pointers are equal.

Args:

Returns:

True if the two pointers are equal and False otherwise.

​rhs (Self): The value of the other pointer.

__ne__(self: Self, rhs: Self) -> Bool

Returns True if the two pointers are not equal.

Args:

Returns:

True if the two pointers are not equal and False otherwise.

​rhs (Self): The value of the other pointer.

__gt__(self: Self, rhs: Self) -> Bool

Returns True if this pointer represents a higher address than rhs.

Args:

Returns:

True if this pointer represents a higher than or equal address and False otherwise.

​rhs (Self): The value of the other pointer.

__ge__(self: Self, rhs: Self) -> Bool

Returns True if this pointer represents a higher than or equal    address than rhs.

Args:

Returns:

True if this pointer represents a higher than or equal address and False otherwise.

​rhs (Self): The value of the other pointer.

__add__(self: Self, offset: Int) -> Self

Return a pointer at an offset from the current one.

Args:

Returns:

An offset pointer.

​offset (Int): The offset index.

__sub__(self: Self, offset: Int) -> Self

Return a pointer at an offset from the current one.

Args:

Returns:

An offset pointer.

​offset (Int): The offset index.

__iadd__(inout self: Self, offset: Int)

Add an offset to this pointer.

Args:

​offset (Int): The offset index.

__isub__(inout self: Self, offset: Int)

Subtract an offset from this pointer.

Args:

​offset (Int): The offset index.

static alloc(count: Int) -> Self

Allocate an array with default alignment.

Args:

Returns:

The pointer to the newly allocated array.

​count (Int): The number of elements in the array.

static address_of(arg: Reference[T, is_mutable, lifetime, address_space]) -> Self

Gets the address of the argument.

Args:

Returns:

An UnsafePointer which contains the address of the argument.

​arg (Reference[T, is_mutable, lifetime, address_space]): The value to get the address of.

free(self: Self)

Free the memory referenced by the pointer.

bitcast[new_type: AnyType = T, /, address_space: AddressSpace = address_space](self: Self) -> UnsafePointer[$0, $1]

Bitcasts a UnsafePointer to a different type.

Parameters:

Returns:

A new UnsafePointer object with the specified type and the same address, as the original UnsafePointer.

​new_type (AnyType): The target type.
​address_space (AddressSpace): The address space of the result.

offset(self: Self, offset: Int) -> Self

Return a pointer at an offset from the current one.

Args:

Returns:

An offset pointer.

​offset (Int): The offset index.





url:https://docs.modular.com/mojo/stdlib/memory/unsafe_pointer/destroy_pointee
function

destroy_pointee

destroy_pointee(ptr: UnsafePointer[T, 0])

Destroy the pointed-to value.

The pointer must not be null, and the pointer memory location is assumed
to contain a valid initialized instance of T.  This is equivalent to
_ = move_from_pointee(ptr) but doesn't require Movable and is more
efficient becase it doesn't invoke __moveinit__.

Args:

​ptr (UnsafePointer[T, 0]): The pointer whose pointee this destroys.





url:https://docs.modular.com/mojo/stdlib/memory/unsafe_pointer/initialize_pointee_copy
function

initialize_pointee_copy

initialize_pointee_copy[T: Copyable](ptr: UnsafePointer[T, 0], value: T)

Emplace a copy of value into the pointer location.

The pointer memory location is assumed to contain uninitialized data,
and consequently the current contents of this pointer are not destructed
before writing value. Similarly, ownership of value is logically
transferred into the pointer location.

When compared to initialize_pointee_move, this avoids an extra move on
the callee side when the value must be copied.

Parameters:

Args:

​T (Copyable): The type the pointer points to, which must be Copyable.

​ptr (UnsafePointer[T, 0]): The pointer to initialize through.
​value (T): The value to emplace.





url:https://docs.modular.com/mojo/stdlib/memory/unsafe_pointer/initialize_pointee_move
function

initialize_pointee_move

initialize_pointee_move[T: Movable](ptr: UnsafePointer[T, 0], owned value: T)

Emplace a new value into the pointer location, moving from value.

The pointer memory location is assumed to contain uninitialized data,
and consequently the current contents of this pointer are not destructed
before writing value. Similarly, ownership of value is logically
transferred into the pointer location.

When compared to initialize_pointee_copy, this avoids an extra copy on
the caller side when the value is an owned rvalue.

Parameters:

Args:

​T (Movable): The type the pointer points to, which must be Movable.

​ptr (UnsafePointer[T, 0]): The pointer to initialize through.
​value (T): The value to emplace.





url:https://docs.modular.com/mojo/stdlib/memory/unsafe_pointer/move_from_pointee
function

move_from_pointee

move_from_pointee[T: Movable](ptr: UnsafePointer[T, 0]) -> $0

Move the value at the pointer out.

The pointer must not be null, and the pointer memory location is assumed
to contain a valid initialized instance of T.

This performs a consuming move, ending the lifetime of the value stored
in this pointer memory location. Subsequent reads of this pointer are
not valid. If a new valid value is stored using initialize_pointee_move(), then
reading from this pointer becomes valid again.

Parameters:

Args:

Returns:

The value at the pointer.

​T (Movable): The type the pointer points to, which must be Movable.

​ptr (UnsafePointer[T, 0]): The pointer whose pointee this moves from.





url:https://docs.modular.com/mojo/stdlib/memory/unsafe_pointer/move_pointee
function

move_pointee

move_pointee[T: Movable](*, src: UnsafePointer[T, 0], dst: UnsafePointer[T, 0])

Moves the value src points to into the memory location pointed to by dest.

This performs a consuming move (using __moveinit__()) out of the
memory location pointed to by src. Subsequent reads of this
pointer are not valid unless and until a new, valid value has been
moved into this pointer's memory location using initialize_pointee_move().

This transfers the value out of self and into dest using at most one
__moveinit__() call.

Safety:
* src must not be null
* src must contain a valid, initialized instance of T
* dst must not be null
* The contents of dst should be uninitialized. If dst was
previously written with a valid value, that value will be be
overwritten and its destructor will NOT be run.

Parameters:

Args:

​T (Movable): The type the pointer points to, which must be Movable.

​src (UnsafePointer[T, 0]): Source pointer that the value will be moved from.
​dst (UnsafePointer[T, 0]): Destination pointer that the value will be moved into.





url:https://docs.modular.com/mojo/stdlib/os/
package

os





url:https://docs.modular.com/mojo/stdlib/os/atomic/
module

atomic





url:https://docs.modular.com/mojo/stdlib/os/atomic/Atomic
struct

Atomic

__init__(inout self: Self, value: SIMD[type, 1])

Constructs a new atomic value.

Args:

​value (SIMD[type, 1]): Initial value represented as Scalar[type] type.

__init__(inout self: Self, value: SIMD[type, 1])

Constructs a new atomic value.

Args:

​value (SIMD[type, 1]): Initial value represented as Scalar[type] type.

__init__(inout self: Self, value: SIMD[type, 1])

Constructs a new atomic value.

Args:

​value (SIMD[type, 1]): Initial value represented as Scalar[type] type.

__iadd__(inout self: Self, rhs: SIMD[type, 1])

Performs atomic in-place add.

Atomically replaces the current value with the result of arithmetic
addition of the value and arg. That is, it performs atomic
post-increment. The operation is a read-modify-write operation. Memory
is affected according to the value of order which is sequentially
consistent.

Args:

​rhs (SIMD[type, 1]): Value to add.

__isub__(inout self: Self, rhs: SIMD[type, 1])

Performs atomic in-place sub.

Atomically replaces the current value with the result of arithmetic
subtraction of the value and arg. That is, it performs atomic
post-decrement. The operation is a read-modify-write operation. Memory
is affected according to the value of order which is sequentially
consistent.

Args:

​rhs (SIMD[type, 1]): Value to subtract.

load(inout self: Self) -> SIMD[type, 1]

Loads the current value from the atomic.

Returns:

The current value of the atomic.

fetch_add(inout self: Self, rhs: SIMD[type, 1]) -> SIMD[type, 1]

Performs atomic in-place add.

Atomically replaces the current value with the result of arithmetic
addition of the value and arg. That is, it performs atomic
post-increment. The operation is a read-modify-write operation. Memory
is affected according to the value of order which is sequentially
consistent.

Args:

Returns:

The original value before addition.

​rhs (SIMD[type, 1]): Value to add.

fetch_sub(inout self: Self, rhs: SIMD[type, 1]) -> SIMD[type, 1]

Performs atomic in-place sub.

Atomically replaces the current value with the result of arithmetic
subtraction of the value and arg. That is, it performs atomic
post-decrement. The operation is a read-modify-write operation. Memory
is affected according to the value of order which is sequentially
consistent.

Args:

Returns:

The original value before subtraction.

​rhs (SIMD[type, 1]): Value to subtract.

compare_exchange_weak(inout self: Self, inout expected: SIMD[type, 1], desired: SIMD[type, 1]) -> Bool

Atomically compares the self value with that of the expected value. If the values are equal, then the self value is replaced with the desired value and True is returned. Otherwise, False is returned the the expected value is rewritten with the self value.

Args:

Returns:

True if self == expected and False otherwise.

​expected (SIMD[type, 1]): The expected value.
​desired (SIMD[type, 1]): The desired value.

max(inout self: Self, rhs: SIMD[type, 1])

Performs atomic in-place max.

Atomically replaces the current value with the result of max of the
value and arg. The operation is a read-modify-write operation perform
according to sequential consistency semantics.

Constraints:

The input type must be either integral or floating-point type.

Args:

​rhs (SIMD[type, 1]): Value to max.

min(inout self: Self, rhs: SIMD[type, 1])

Performs atomic in-place min.

Atomically replaces the current value with the result of min of the
value and arg. The operation is a read-modify-write operation. The
operation is a read-modify-write operation perform according to
sequential consistency semantics.

Constraints:

The input type must be either integral or floating-point type.

Args:

​rhs (SIMD[type, 1]): Value to min.





url:https://docs.modular.com/mojo/stdlib/os/env/
module

env





url:https://docs.modular.com/mojo/stdlib/os/env/getenv
function

getenv

getenv(name: String, default: String = "") -> String

Returns the value of the given environment variable.

Constraints:

The function only works on macOS or Linux and returns an empty string otherwise.

Args:

Returns:

The value of the environment variable.

​name (String): The name of the environment variable.
​default (String): The default value to return if the environment variable doesn't exist.





url:https://docs.modular.com/mojo/stdlib/os/env/setenv
function

setenv

setenv(name: String, value: String, overwrite: Bool = 1) -> Bool

Changes or adds an environment variable.

Constraints:

The function only works on macOS or Linux and returns False otherwise.

Args:

Returns:

False if the name is empty or contains an = character. In any other case, True is returned.

​name (String): The name of the environment variable.
​value (String): The value of the environment variable.
​overwrite (Bool): If an environment variable with the given name already exists, its value is not changed unless overwrite is True.





url:https://docs.modular.com/mojo/stdlib/os/fstat/
module

fstat





url:https://docs.modular.com/mojo/stdlib/os/fstat/lstat
function

lstat

lstat(path: String) -> stat_result

Get the status of a file or a file descriptor (similar to stat, but does not follow symlinks).

Args:

Returns:

Returns the stat_result on the path.

​path (String): The path to the directory.





url:https://docs.modular.com/mojo/stdlib/os/fstat/stat
function

stat

stat(path: String) -> stat_result

Get the status of a file or a file descriptor.

Args:

Returns:

Returns the stat_result on the path.

​path (String): The path to the directory.





url:https://docs.modular.com/mojo/stdlib/os/fstat/stat_result
struct

stat_result

__init__(inout self: Self, *, st_mode: Int, st_ino: Int, st_dev: Int, st_nlink: Int, st_uid: Int, st_gid: Int, st_size: Int, st_atimespec: _CTimeSpec, st_mtimespec: _CTimeSpec, st_ctimespec: _CTimeSpec, st_birthtimespec: _CTimeSpec, st_blocks: Int, st_blksize: Int, st_rdev: Int, st_flags: Int)

Initialize the stat_result structure.

Args:

​st_mode (Int): File mode: file type and file mode bits (permissions).
​st_ino (Int): Uniquely identifier for a file.
​st_dev (Int): Identifier of the device on which this file resides.
​st_nlink (Int): Number of hard links.
​st_uid (Int): User identifier of the file owner.
​st_gid (Int): Group identifier of the file owner.
​st_size (Int): Size of the file (bytes), if it is a file or a symlink.
​st_atimespec (_CTimeSpec): Time of file most recent access.
​st_mtimespec (_CTimeSpec): Time of file most recent modification.
​st_ctimespec (_CTimeSpec): Time of file most recent change.
​st_birthtimespec (_CTimeSpec): Time of file creation.
​st_blocks (Int): Number of 512-byte blocks allocated for file.
​st_blksize (Int): Preferred blocksize for efficient file system I/O.
​st_rdev (Int): Type of device if an inode device.
​st_flags (Int): User defined flags for file.

__init__(inout self: Self, *, st_mode: Int, st_ino: Int, st_dev: Int, st_nlink: Int, st_uid: Int, st_gid: Int, st_size: Int, st_atimespec: _CTimeSpec, st_mtimespec: _CTimeSpec, st_ctimespec: _CTimeSpec, st_birthtimespec: _CTimeSpec, st_blocks: Int, st_blksize: Int, st_rdev: Int, st_flags: Int)

Initialize the stat_result structure.

Args:

​st_mode (Int): File mode: file type and file mode bits (permissions).
​st_ino (Int): Uniquely identifier for a file.
​st_dev (Int): Identifier of the device on which this file resides.
​st_nlink (Int): Number of hard links.
​st_uid (Int): User identifier of the file owner.
​st_gid (Int): Group identifier of the file owner.
​st_size (Int): Size of the file (bytes), if it is a file or a symlink.
​st_atimespec (_CTimeSpec): Time of file most recent access.
​st_mtimespec (_CTimeSpec): Time of file most recent modification.
​st_ctimespec (_CTimeSpec): Time of file most recent change.
​st_birthtimespec (_CTimeSpec): Time of file creation.
​st_blocks (Int): Number of 512-byte blocks allocated for file.
​st_blksize (Int): Preferred blocksize for efficient file system I/O.
​st_rdev (Int): Type of device if an inode device.
​st_flags (Int): User defined flags for file.

__init__(inout self: Self, *, st_mode: Int, st_ino: Int, st_dev: Int, st_nlink: Int, st_uid: Int, st_gid: Int, st_size: Int, st_atimespec: _CTimeSpec, st_mtimespec: _CTimeSpec, st_ctimespec: _CTimeSpec, st_birthtimespec: _CTimeSpec, st_blocks: Int, st_blksize: Int, st_rdev: Int, st_flags: Int)

Initialize the stat_result structure.

Args:

​st_mode (Int): File mode: file type and file mode bits (permissions).
​st_ino (Int): Uniquely identifier for a file.
​st_dev (Int): Identifier of the device on which this file resides.
​st_nlink (Int): Number of hard links.
​st_uid (Int): User identifier of the file owner.
​st_gid (Int): Group identifier of the file owner.
​st_size (Int): Size of the file (bytes), if it is a file or a symlink.
​st_atimespec (_CTimeSpec): Time of file most recent access.
​st_mtimespec (_CTimeSpec): Time of file most recent modification.
​st_ctimespec (_CTimeSpec): Time of file most recent change.
​st_birthtimespec (_CTimeSpec): Time of file creation.
​st_blocks (Int): Number of 512-byte blocks allocated for file.
​st_blksize (Int): Preferred blocksize for efficient file system I/O.
​st_rdev (Int): Type of device if an inode device.
​st_flags (Int): User defined flags for file.





url:https://docs.modular.com/mojo/stdlib/os/os/
module

os





url:https://docs.modular.com/mojo/stdlib/os/os/abort
function

abort

abort[result: AnyType = None]() -> $0

Calls a target dependent trap instruction if available.

Parameters:

Returns:

A null result type.

​result (AnyType): The result type.





url:https://docs.modular.com/mojo/stdlib/os/os/listdir
function

listdir

listdir(path: String = "") -> List[String]

Gets the list of entries contained in the path provided.

Args:

Returns:

Returns the list of entries in the path provided.

​path (String): The path to the directory.





url:https://docs.modular.com/mojo/stdlib/os/os/mkdir
function

mkdir

mkdir(path: String, mode: Int = 511)

Creates a directory at the specified path. If the directory can not be created an error is raised. Absolute and relative paths are allowed, relative paths are resolved from cwd.

Args:

​path (String): The path to the directory.
​mode (Int): The mode to create the directory with.





url:https://docs.modular.com/mojo/stdlib/os/os/remove
function

remove

remove(path: String)

Removes the specified file. If the path is a directory or it can not be deleted, an error is raised. Absolute and relative paths are allowed, relative paths are resolved from cwd.

Args:

​path (String): The path to the file.





url:https://docs.modular.com/mojo/stdlib/os/os/rmdir
function

rmdir

rmdir(path: String)

Removes the specified directory. If the path is not a directory or it can not be deleted, an error is raised. Absolute and relative paths are allowed, relative paths are resolved from cwd.

Args:

​path (String): The path to the directory.





url:https://docs.modular.com/mojo/stdlib/os/os/unlink
function

unlink

unlink(path: String)

Removes the specified file. If the path is a directory or it can not be deleted, an error is raised. Absolute and relative paths are allowed, relative paths are resolved from cwd.

Args:

​path (String): The path to the file.





url:https://docs.modular.com/mojo/stdlib/os/path/
package

path





url:https://docs.modular.com/mojo/stdlib/os/path/path/
module

path





url:https://docs.modular.com/mojo/stdlib/os/path/path/exists
function

exists

exists(path: String) -> Bool

Return True if path exists.

Args:

Returns:

Returns True if the path exists and is not a broken symbolic link.

​path (String): The path to the directory.





url:https://docs.modular.com/mojo/stdlib/os/path/path/getsize
function

getsize

getsize(path: String) -> Int

Return the size, in bytes, of the specified path.

Args:

Returns:

The size of the path in bytes.

​path (String): The path to the file.





url:https://docs.modular.com/mojo/stdlib/os/path/path/isdir
function

isdir

isdir(path: String) -> Bool

Return True if path is an existing directory. This follows symbolic links, so both islink() and isdir() can be true for the same path.

Args:

Returns:

True if the path is a directory or a link to a directory and False otherwise.

​path (String): The path to the directory.





url:https://docs.modular.com/mojo/stdlib/os/path/path/isfile
function

isfile

isfile(path: String) -> Bool

Test whether a path is a regular file.

Args:

Returns:

Returns True if the path is a regular file.

​path (String): The path to the directory.





url:https://docs.modular.com/mojo/stdlib/os/path/path/islink
function

islink

islink(path: String) -> Bool

Return True if path refers to an existing directory entry that is a symbolic link.

Args:

Returns:

True if the path is a link to a directory and False otherwise.

​path (String): The path to the directory.





url:https://docs.modular.com/mojo/stdlib/os/path/path/join
function

join

join(path: String, *paths: String) -> String

Join two or more pathname components, inserting '/' as needed. If any component is an absolute path, all previous path components will be discarded.  An empty last part will result in a path that ends with a separator.

Args:

Returns:

The joined path.

​path (String): The path to join.
​*paths (String): The paths to join.





url:https://docs.modular.com/mojo/stdlib/os/path/path/lexists
function

lexists

lexists(path: String) -> Bool

Return True if path exists or is a broken symlink.

Args:

Returns:

Returns True if the path exists or is a broken symbolic link.

​path (String): The path to the directory.





url:https://docs.modular.com/mojo/stdlib/os/pathlike/
module

pathlike





url:https://docs.modular.com/mojo/stdlib/os/pathlike/PathLike
trait

PathLike





url:https://docs.modular.com/mojo/stdlib/pathlib/
package

pathlib





url:https://docs.modular.com/mojo/stdlib/pathlib/path/
module

path





url:https://docs.modular.com/mojo/stdlib/pathlib/path/Path
struct

Path

__init__(inout self: Self)

Initializes a path with the current directory.

__init__(inout self: Self)

Initializes a path with the current directory.

__init__(inout self: Self)

Initializes a path with the current directory.

__copyinit__(inout self: Self, existing: Self)

Copy constructor for the path struct.

Args:

​existing (Self): The existing struct to copy from.

__moveinit__(inout self: Self, owned existing: Self)

Move data of an existing Path into a new one.

Args:

​existing (Self): The existing Path.

__eq__(self: Self, other: Self) -> Bool

Returns True if the two paths are equal.

Args:

Returns:

True if the paths are equal and False otherwise.

​other (Self): The other path to compare against.

__ne__(self: Self, other: Self) -> Bool

Returns True if the two paths are not equal.

Args:

Returns:

True if the paths are not equal and False otherwise.

​other (Self): The other path to compare against.

__truediv__(self: Self, suffix: Self) -> Self

Joins two paths using the system-defined path separator.

Args:

Returns:

A new path with the suffix appended to the current path.

​suffix (Self): The suffix to append to the path.

__itruediv__(inout self: Self, suffix: String)

Joins two paths using the system-defined path separator.

Args:

​suffix (String): The suffix to append to the path.

stat(self: Self) -> stat_result

Returns the stat information on the path.

Returns:

A stat_result object containing information about the path.

lstat(self: Self) -> stat_result

Returns the lstat information on the path. This is similar to stat, but if the file is a symlink then it gives you information about the symlink rather than the target.

Returns:

A stat_result object containing information about the path.

exists(self: Self) -> Bool

Returns True if the path exists and False otherwise.

Returns:

True if the path exists on disk and False otherwise.

is_dir(self: Self) -> Bool

Returns True if the path is a directory and False otherwise.

Returns:

Return True if the path points to a directory (or a link pointing to a directory).

is_file(self: Self) -> Bool

Returns True if the path is a file and False otherwise.

Returns:

Return True if the path points to a file (or a link pointing to a file).

read_text(self: Self) -> String

Returns content of the file.

Returns:

Contents of file as string.

read_bytes(self: Self) -> List[SIMD[uint8, 1]]

Returns content of the file as bytes.

Returns:

Contents of file as list of bytes.

write_text[stringable: Stringable](self: Self, value: stringable)

Writes the value to the file as text.

Parameters:

Args:

​stringable (Stringable): The Stringable type.

​value (stringable): The value to write.

suffix(self: Self) -> String

The path's extension, if any. This includes the leading period. For example: '.txt'. If no extension is found, returns the empty string.

Returns:

The path's extension.

joinpath(self: Self, *pathsegments: String) -> Self

Joins the Path using the pathsegments.

Args:

Returns:

The path concatenation with the pathsegments using the directory separator.

​*pathsegments (String): The path segments.

listdir(self: Self) -> List[Path]

Gets the list of entries contained in the path provided.

Returns:

The list of entries in the path provided.





url:https://docs.modular.com/mojo/stdlib/pathlib/path/cwd
function

cwd

cwd() -> Path

Gets the current directory.

Returns:

The current directory.





url:https://docs.modular.com/mojo/stdlib/python/
package

python





url:https://docs.modular.com/mojo/stdlib/python/object/
module

object





url:https://docs.modular.com/mojo/stdlib/python/object/PythonObject
struct

PythonObject

__init__(inout self: Self)

Initialize the object with a None value.

__init__(inout self: Self)

Initialize the object with a None value.

__init__(inout self: Self)

Initialize the object with a None value.

__copyinit__(inout self: Self, existing: Self)

Copy the object.

This increments the underlying refcount of the existing object.

Args:

​existing (Self): The value to copy.

__del__(owned self: Self)

Destroy the object.

This decrements the underlying refcount of the pointed-to object.

__bool__(self: Self) -> Bool

Evaluate the boolean value of the object.

Returns:

Whether the object evaluates as true.

__getitem__(self: Self, *args: Self) -> Self

Return the value for the given key or keys.

Args:

Returns:

The value corresponding to the given key for this object.

​*args (Self): The key or keys to access on this object.

__setitem__(inout self: Self, *args: Self)

Set the value with the given key or keys.

Args:

​*args (Self): The key or keys to set on this object, followed by the value.

__neg__(self: Self) -> Self

Negative.

Calls the underlying object's __neg__ method.

Returns:

The result of prefixing this object with a - operator. For most numerical objects, this returns the negative.

__pos__(self: Self) -> Self

Positive.

Calls the underlying object's __pos__ method.

Returns:

The result of prefixing this object with a + operator. For most numerical objects, this does nothing.

__invert__(self: Self) -> Self

Inversion.

Calls the underlying object's __invert__ method.

Returns:

The logical inverse of this object: a bitwise representation where all bits are flipped, from zero to one, and from one to zero.

__lt__(self: Self, rhs: Self) -> Self

Less than comparator. This lexicographically compares strings and lists.

Args:

Returns:

True if the object is less than the right hard argument.

​rhs (Self): Right hand value.

__le__(self: Self, rhs: Self) -> Self

Less than or equal to comparator. This lexicographically compares strings and lists.

Args:

Returns:

True if the object is less than or equal to the right hard argument.

​rhs (Self): Right hand value.

__eq__(self: Self, rhs: Self) -> Bool

Equality comparator. This compares the elements of strings and lists.

Args:

Returns:

True if the objects are equal.

​rhs (Self): Right hand value.

__ne__(self: Self, rhs: Self) -> Bool

Inequality comparator. This compares the elements of strings and lists.

Args:

Returns:

True if the objects are not equal.

​rhs (Self): Right hand value.

__gt__(self: Self, rhs: Self) -> Self

Greater than comparator. This lexicographically compares the elements of strings and lists.

Args:

Returns:

True if the left hand value is greater.

​rhs (Self): Right hand value.

__ge__(self: Self, rhs: Self) -> Self

Greater than or equal to comparator. This lexicographically compares the elements of strings and lists.

Args:

Returns:

True if the left hand value is greater than or equal to the right hand value.

​rhs (Self): Right hand value.

__is__(self: Self, other: Self) -> Bool

Test if the PythonObject is the other PythonObject, the same as x is y in Python.

Args:

Returns:

True if they are the same object and False otherwise.

​other (Self): The right-hand-side value in the comparison.

__isnot__(self: Self, other: Self) -> Bool

Test if the PythonObject is not the other PythonObject, the same as x is not y in Python.

Args:

Returns:

True if they are not the same object and False otherwise.

​other (Self): The right-hand-side value in the comparison.

__add__(self: Self, rhs: Self) -> Self

Addition and concatenation.

Calls the underlying object's __add__ method.

Args:

Returns:

The sum or concatenated values.

​rhs (Self): Right hand value.

__sub__(self: Self, rhs: Self) -> Self

Subtraction.

Calls the underlying object's __sub__ method.

Args:

Returns:

The difference.

​rhs (Self): Right hand value.

__mul__(self: Self, rhs: Self) -> Self

Multiplication.

Calls the underlying object's __mul__ method.

Args:

Returns:

The product.

​rhs (Self): Right hand value.

__truediv__(self: Self, rhs: Self) -> Self

Division.

Calls the underlying object's __truediv__ method.

Args:

Returns:

The result of dividing the right-hand-side value by this.

​rhs (Self): The right-hand-side value by which this object is divided.

__floordiv__(self: Self, rhs: Self) -> Self

Return the division of self and rhs rounded down to the nearest integer.

Calls the underlying object's __floordiv__ method.

Args:

Returns:

The result of dividing this by the right-hand-side value, modulo any remainder.

​rhs (Self): The right-hand-side value by which this object is divided.

__mod__(self: Self, rhs: Self) -> Self

Return the remainder of self divided by rhs.

Calls the underlying object's __mod__ method.

Args:

Returns:

The remainder of dividing self by rhs.

​rhs (Self): The value to divide on.

__pow__(self: Self, exp: Self) -> Self

Raises this object to the power of the given value.

Args:

Returns:

The result of raising this by the given exponent.

​exp (Self): The exponent.

__lshift__(self: Self, rhs: Self) -> Self

Bitwise left shift.

Args:

Returns:

This value, shifted left by the given value.

​rhs (Self): The right-hand-side value by which this object is bitwise shifted to the left.

__rshift__(self: Self, rhs: Self) -> Self

Bitwise right shift.

Args:

Returns:

This value, shifted right by the given value.

​rhs (Self): The right-hand-side value by which this object is bitwise shifted to the right.

__and__(self: Self, rhs: Self) -> Self

Bitwise AND.

Args:

Returns:

The bitwise AND result of this and the given value.

​rhs (Self): The right-hand-side value with which this object is bitwise AND'ed.

__or__(self: Self, rhs: Self) -> Self

Bitwise OR.

Args:

Returns:

The bitwise OR result of this and the given value.

​rhs (Self): The right-hand-side value with which this object is bitwise OR'ed.

__xor__(self: Self, rhs: Self) -> Self

Exclusive OR.

Args:

Returns:

The exclusive OR result of this and the given value.

​rhs (Self): The right-hand-side value with which this object is exclusive OR'ed.

__radd__(self: Self, lhs: Self) -> Self

Reverse addition and concatenation.

Calls the underlying object's __radd__ method.

Args:

Returns:

The sum.

​lhs (Self): The left-hand-side value to which this object is added or concatenated.

__rsub__(self: Self, lhs: Self) -> Self

Reverse subtraction.

Calls the underlying object's __rsub__ method.

Args:

Returns:

The result of subtracting this from the given value.

​lhs (Self): The left-hand-side value from which this object is subtracted.

__rmul__(self: Self, lhs: Self) -> Self

Reverse multiplication.

Calls the underlying object's __rmul__ method.

Args:

Returns:

The product of the multiplication.

​lhs (Self): The left-hand-side value that is multiplied by this object.

__rtruediv__(self: Self, lhs: Self) -> Self

Reverse division.

Calls the underlying object's __rtruediv__ method.

Args:

Returns:

The result of dividing the given value by this.

​lhs (Self): The left-hand-side value that is divided by this object.

__rfloordiv__(self: Self, lhs: Self) -> Self

Reverse floor division.

Calls the underlying object's __rfloordiv__ method.

Args:

Returns:

The result of dividing the given value by this, modulo any remainder.

​lhs (Self): The left-hand-side value that is divided by this object.

__rmod__(self: Self, lhs: Self) -> Self

Reverse modulo.

Calls the underlying object's __rmod__ method.

Args:

Returns:

The remainder from dividing the given value by this.

​lhs (Self): The left-hand-side value that is divided by this object.

__rpow__(self: Self, lhs: Self) -> Self

Reverse power of.

Args:

Returns:

The result of raising the given value by this exponent.

​lhs (Self): The number that is raised to the power of this object.

__rlshift__(self: Self, lhs: Self) -> Self

Reverse bitwise left shift.

Args:

Returns:

The given value, shifted left by this.

​lhs (Self): The left-hand-side value that is bitwise shifted to the left by this object.

__rrshift__(self: Self, lhs: Self) -> Self

Reverse bitwise right shift.

Args:

Returns:

The given value, shifted right by this.

​lhs (Self): The left-hand-side value that is bitwise shifted to the right by this object.

__rand__(self: Self, lhs: Self) -> Self

Reverse bitwise and.

Args:

Returns:

The bitwise AND result of the given value and this.

​lhs (Self): The left-hand-side value that is bitwise AND'ed with this object.

__ror__(self: Self, lhs: Self) -> Self

Reverse bitwise OR.

Args:

Returns:

The bitwise OR result of the given value and this.

​lhs (Self): The left-hand-side value that is bitwise OR'ed with this object.

__rxor__(self: Self, lhs: Self) -> Self

Reverse exclusive OR.

Args:

Returns:

The exclusive OR result of the given value and this.

​lhs (Self): The left-hand-side value that is exclusive OR'ed with this object.

__iadd__(inout self: Self, rhs: Self)

Immediate addition and concatenation.

Args:

​rhs (Self): The right-hand-side value that is added to this object.

__isub__(inout self: Self, rhs: Self)

Immediate subtraction.

Args:

​rhs (Self): The right-hand-side value that is subtracted from this object.

__imul__(inout self: Self, rhs: Self)

In-place multiplication.

Calls the underlying object's __imul__ method.

Args:

​rhs (Self): The right-hand-side value by which this object is multiplied.

__itruediv__(inout self: Self, rhs: Self)

Immediate division.

Args:

​rhs (Self): The value by which this object is divided.

__ifloordiv__(inout self: Self, rhs: Self)

Immediate floor division.

Args:

​rhs (Self): The value by which this object is divided.

__imod__(inout self: Self, rhs: Self)

Immediate modulo.

Args:

​rhs (Self): The right-hand-side value that is used to divide this object.

__ipow__(inout self: Self, rhs: Self)

Immediate power of.

Args:

​rhs (Self): The exponent.

__ilshift__(inout self: Self, rhs: Self)

Immediate bitwise left shift.

Args:

​rhs (Self): The right-hand-side value by which this object is bitwise shifted to the left.

__irshift__(inout self: Self, rhs: Self)

Immediate bitwise right shift.

Args:

​rhs (Self): The right-hand-side value by which this object is bitwise shifted to the right.

__iand__(inout self: Self, rhs: Self)

Immediate bitwise AND.

Args:

​rhs (Self): The right-hand-side value with which this object is bitwise AND'ed.

__ixor__(inout self: Self, rhs: Self)

Immediate exclusive OR.

Args:

​rhs (Self): The right-hand-side value with which this object is exclusive OR'ed.

__ior__(inout self: Self, rhs: Self)

Immediate bitwise OR.

Args:

​rhs (Self): The right-hand-side value with which this object is bitwise OR'ed.

to_float64(self: Self) -> SIMD[float64, 1]

Returns a float representation of the object.

Returns:

A floating point value that represents this object.





url:https://docs.modular.com/mojo/stdlib/python/python/
module

python





url:https://docs.modular.com/mojo/stdlib/python/python/Python
struct

Python

__init__(inout self: Self)

Default constructor.

__init__(inout self: Self)

Default constructor.

__init__(inout self: Self)

Default constructor.

__copyinit__(inout self: Self, existing: Self)

Copy constructor.

Args:

​existing (Self): The existing instance to copy from.

eval(inout self: Self, code: StringRef) -> Bool

Executes the given Python code.

Args:

Returns:

True if the code executed successfully or False if the code raised an exception.

​code (StringRef): The python code to execute.

static evaluate(expr: StringRef, file: Bool = 0, name: StringRef = "__main__") -> PythonObject

Executes the given Python code.

Args:

Returns:

PythonObject containing the result of the evaluation.

​expr (StringRef): The Python expression to evaluate.
​file (Bool): Evaluate as a file and return the module.
​name (StringRef): The name of the module (most relevant if file is True).

static add_to_path(dir_path: String)

Adds a directory to the Python path.

This might be necessary to import a Python module via import_module().
For example:

Args:

​dir_path (String): The path to a Python module you want to import.

static import_module(module: StringRef) -> PythonObject

Imports a Python module.

This provides you with a module object you can use just like you would
in Python. For example:

Args:

Returns:

The Python module.

​module (StringRef): The Python module name. This module must be visible from the list of available Python paths (you might need to add the module's path with add_to_path()).

static dict() -> PythonObject

Construct an empty Python dictionary.

Returns:

The constructed empty Python dictionary.

static list() -> PythonObject

Construct an empty Python list.

Returns:

The constructed empty Python list.

static throw_python_exception_if_error_state(inout cpython: CPython)

Raise an exception if CPython interpreter is in an error state.

Args:

​cpython (CPython): The cpython instance we wish to error check.

static is_type(x: PythonObject, y: PythonObject) -> Bool

Test if the x object is the y object, the same as x is y in Python.

Args:

Returns:

True if x and y are the same object and False otherwise.

​x (PythonObject): The left-hand-side value in the comparison.
​y (PythonObject): The right-hand-side type value in the comparison.

static type(obj: PythonObject) -> PythonObject

Return Type of this PythonObject.

Args:

Returns:

A PythonObject that holds the type object.

​obj (PythonObject): PythonObject we want the type of.

static none() -> PythonObject

Get a PythonObject representing None.

Returns:

PythonObject representing None.





url:https://docs.modular.com/mojo/stdlib/random/
package

random





url:https://docs.modular.com/mojo/stdlib/random/random/
module

random





url:https://docs.modular.com/mojo/stdlib/random/random/rand
function

rand

rand[type: DType](ptr: DTypePointer[type, 0], size: Int)

Fills memory with random values from a uniform distribution.

Parameters:

Args:

​type (DType): The dtype of the pointer.

​ptr (DTypePointer[type, 0]): The pointer to the memory area to fill.
​size (Int): The number of elements to fill.





url:https://docs.modular.com/mojo/stdlib/random/random/randint
function

randint

randint[type: DType](ptr: DTypePointer[type, 0], size: Int, low: Int, high: Int)

Fills memory with uniform random in range [low, high].

Constraints:

The type should be integral.

Parameters:

Args:

​type (DType): The dtype of the pointer.

​ptr (DTypePointer[type, 0]): The pointer to the memory area to fill.
​size (Int): The number of elements to fill.
​low (Int): The minimal value for random.
​high (Int): The maximal value for random.





url:https://docs.modular.com/mojo/stdlib/random/random/randn
function

randn

randn[type: DType](ptr: DTypePointer[type, 0], size: Int, mean: SIMD[float64, 1] = #kgen.float_literal<0|1>, variance: SIMD[float64, 1] = #kgen.float_literal<1|1>)

Fills memory with random values from a Normal(mean, variance) distribution.

Constraints:

The type should be floating point.

Parameters:

Args:

​type (DType): The dtype of the pointer.

​ptr (DTypePointer[type, 0]): The pointer to the memory area to fill.
​size (Int): The number of elements to fill.
​mean (SIMD[float64, 1]): Normal distribution mean.
​variance (SIMD[float64, 1]): Normal distribution variance.





url:https://docs.modular.com/mojo/stdlib/random/random/randn_float64
function

randn_float64

randn_float64(mean: SIMD[float64, 1] = #kgen.float_literal<0|1>, variance: SIMD[float64, 1] = #kgen.float_literal<1|1>) -> SIMD[float64, 1]

Returns a random double sampled from a Normal(mean, variance) distribution.

Args:

Returns:

A random float64 sampled from Normal(mean, variance).

​mean (SIMD[float64, 1]): Normal distribution mean.
​variance (SIMD[float64, 1]): Normal distribution variance.





url:https://docs.modular.com/mojo/stdlib/random/random/random_float64
function

random_float64

random_float64(min: SIMD[float64, 1] = 0, max: SIMD[float64, 1] = 1) -> SIMD[float64, 1]

Returns a random Float64 number from the given range.

Args:

Returns:

A random number from the specified range.

​min (SIMD[float64, 1]): The minimum number in the range (default is 0.0).
​max (SIMD[float64, 1]): The maximum number in the range (default is 1.0).





url:https://docs.modular.com/mojo/stdlib/random/random/random_si64
function

random_si64

random_si64(min: SIMD[int64, 1], max: SIMD[int64, 1]) -> SIMD[int64, 1]

Returns a random Int64 number from the given range.

Args:

Returns:

A random number from the specified range.

​min (SIMD[int64, 1]): The minimum number in the range.
​max (SIMD[int64, 1]): The maximum number in the range.





url:https://docs.modular.com/mojo/stdlib/random/random/random_ui64
function

random_ui64

random_ui64(min: SIMD[uint64, 1], max: SIMD[uint64, 1]) -> SIMD[uint64, 1]

Returns a random UInt64 number from the given range.

Args:

Returns:

A random number from the specified range.

​min (SIMD[uint64, 1]): The minimum number in the range.
​max (SIMD[uint64, 1]): The maximum number in the range.





url:https://docs.modular.com/mojo/stdlib/random/random/seed
function

seed

seed()

Seeds the random number generator using the current time.





url:https://docs.modular.com/mojo/stdlib/stat/
package

stat





url:https://docs.modular.com/mojo/stdlib/stat/stat/
module

stat





url:https://docs.modular.com/mojo/stdlib/stat/stat/S_ISBLK
function

S_ISBLK

S_ISBLK[intable: Intable](mode: intable) -> Bool

Returns True if the mode is a block device.

Parameters:

Args:

Returns:

True if the mode is a block device and False otherwise.

​intable (Intable): A type conforming to Intable.

​mode (intable): The file mode.





url:https://docs.modular.com/mojo/stdlib/stat/stat/S_ISCHR
function

S_ISCHR

S_ISCHR[intable: Intable](mode: intable) -> Bool

Returns True if the mode is a character device.

Parameters:

Args:

Returns:

True if the mode is a character device and False otherwise.

​intable (Intable): A type conforming to Intable.

​mode (intable): The file mode.





url:https://docs.modular.com/mojo/stdlib/stat/stat/S_ISDIR
function

S_ISDIR

S_ISDIR[intable: Intable](mode: intable) -> Bool

Returns True if the mode is a directory.

Parameters:

Args:

Returns:

True if the mode is a directory and False otherwise.

​intable (Intable): A type conforming to Intable.

​mode (intable): The file mode.





url:https://docs.modular.com/mojo/stdlib/stat/stat/S_ISFIFO
function

S_ISFIFO

S_ISFIFO[intable: Intable](mode: intable) -> Bool

Returns True if the mode is a fifo.

Parameters:

Args:

Returns:

True if the mode is a fifo and False otherwise.

​intable (Intable): A type conforming to Intable.

​mode (intable): The file mode.





url:https://docs.modular.com/mojo/stdlib/stat/stat/S_ISLNK
function

S_ISLNK

S_ISLNK[intable: Intable](mode: intable) -> Bool

Returns True if the mode is a symlink.

Parameters:

Args:

Returns:

True if the mode is a symlink and False otherwise.

​intable (Intable): A type conforming to Intable.

​mode (intable): The file mode.





url:https://docs.modular.com/mojo/stdlib/stat/stat/S_ISREG
function

S_ISREG

S_ISREG[intable: Intable](mode: intable) -> Bool

Returns True if the mode is a regular file.

Parameters:

Args:

Returns:

True if the mode is a regular file and False otherwise.

​intable (Intable): A type conforming to Intable.

​mode (intable): The file mode.





url:https://docs.modular.com/mojo/stdlib/stat/stat/S_ISSOCK
function

S_ISSOCK

S_ISSOCK[intable: Intable](mode: intable) -> Bool

Returns True if the mode is a socket.

Parameters:

Args:

Returns:

True if the mode is a socket and False otherwise.

​intable (Intable): A type conforming to Intable.

​mode (intable): The file mode.





url:https://docs.modular.com/mojo/stdlib/sys/
package

sys





url:https://docs.modular.com/mojo/stdlib/sys/arg/
module

arg





url:https://docs.modular.com/mojo/stdlib/sys/arg/argv
function

argv

argv() -> VariadicList[StringRef]

The list of command line arguments.

Returns:

The list of command line arguments provided when mojo was invoked.





url:https://docs.modular.com/mojo/stdlib/sys/debug/
module

debug





url:https://docs.modular.com/mojo/stdlib/sys/debug/breakpointhook
function

breakpointhook

breakpointhook()

Cause an execution trap with the intention of requesting the attention of a debugger.





url:https://docs.modular.com/mojo/stdlib/sys/ffi/
module

ffi





url:https://docs.modular.com/mojo/stdlib/sys/ffi/DLHandle
struct

DLHandle

__init__(inout self: Self, path: String, flags: Int = __or__(2, 256 if eq(:string target_get_field(current_target(), "os"), "linux") else 8))

Initialize a DLHandle object by loading the dynamic library at the given path.

Args:

​path (String): The path to the dynamic library file.
​flags (Int): The flags to load the dynamic library.

__init__(inout self: Self, path: String, flags: Int = __or__(2, 256 if eq(:string target_get_field(current_target(), "os"), "linux") else 8))

Initialize a DLHandle object by loading the dynamic library at the given path.

Args:

​path (String): The path to the dynamic library file.
​flags (Int): The flags to load the dynamic library.

__init__(inout self: Self, path: String, flags: Int = __or__(2, 256 if eq(:string target_get_field(current_target(), "os"), "linux") else 8))

Initialize a DLHandle object by loading the dynamic library at the given path.

Args:

​path (String): The path to the dynamic library file.
​flags (Int): The flags to load the dynamic library.

__bool__(self: Self) -> Bool

Checks if the handle is valid.

Returns:

True if the DLHandle is not null and False otherwise.

check_symbol(self: Self, name: String) -> Bool

Check that the symbol exists in the dynamic library.

Args:

Returns:

True if the symbol exists.

​name (String): The symbol to check.

close(inout self: Self)

Delete the DLHandle object unloading the associated dynamic library.

get_function[result_type: AnyTrivialRegType](self: Self, name: String) -> $0

Returns a handle to the function with the given name in the dynamic library.

Parameters:

Args:

Returns:

A handle to the function.

​result_type (AnyTrivialRegType): The type of the function pointer to return.

​name (String): The name of the function to get the handle for.





url:https://docs.modular.com/mojo/stdlib/sys/ffi/RTLD
struct

RTLD





url:https://docs.modular.com/mojo/stdlib/sys/ffi/external_call
function

external_call

external_call[callee: StringLiteral, type: AnyTrivialRegType]() -> $1

Calls an external function.

Parameters:

Returns:

The external call result.

​callee (StringLiteral): The name of the external function.
​type (AnyTrivialRegType): The return type.





url:https://docs.modular.com/mojo/stdlib/sys/info/
module

info





url:https://docs.modular.com/mojo/stdlib/sys/info/alignof
function

alignof

alignof[type: AnyType, target: target = current_target()]() -> IntLiteral

Returns the align of (in bytes) of the type.

Parameters:

Returns:

The alignment of the type in bytes.

​type (AnyType): The type in question.
​target (target): The target architecture.





url:https://docs.modular.com/mojo/stdlib/sys/info/bitwidthof
function

bitwidthof

bitwidthof[type: AnyTrivialRegType, target: target = current_target()]() -> IntLiteral

Returns the size of (in bits) of the type.

Parameters:

Returns:

The size of the type in bits.

​type (AnyTrivialRegType): The type in question.
​target (target): The target architecture.





url:https://docs.modular.com/mojo/stdlib/sys/info/has_avx
function

has_avx

has_avx() -> Bool

Returns True if the host system has AVX, otherwise returns False.

Returns:

True if the host system has AVX, otherwise returns False.





url:https://docs.modular.com/mojo/stdlib/sys/info/has_avx2
function

has_avx2

has_avx2() -> Bool

Returns True if the host system has AVX2, otherwise returns False.

Returns:

True if the host system has AVX2, otherwise returns False.





url:https://docs.modular.com/mojo/stdlib/sys/info/has_avx512f
function

has_avx512f

has_avx512f() -> Bool

Returns True if the host system has AVX512, otherwise returns False.

Returns:

True if the host system has AVX512, otherwise returns False.





url:https://docs.modular.com/mojo/stdlib/sys/info/has_intel_amx
function

has_intel_amx

has_intel_amx() -> Bool

Returns True if the host system has Intel AMX support, otherwise returns False.

Returns:

True if the host system has Intel AMX and False otherwise.





url:https://docs.modular.com/mojo/stdlib/sys/info/has_neon
function

has_neon

has_neon() -> Bool

Returns True if the host system has Neon support, otherwise returns False.

Returns:

True if the host system support the Neon instruction set.





url:https://docs.modular.com/mojo/stdlib/sys/info/has_neon_int8_dotprod
function

has_neon_int8_dotprod

has_neon_int8_dotprod() -> Bool

Returns True if the host system has the Neon int8 dot product extension, otherwise returns False.

Returns:

True if the host system support the Neon int8 dot product extension and False otherwise.





url:https://docs.modular.com/mojo/stdlib/sys/info/has_neon_int8_matmul
function

has_neon_int8_matmul

has_neon_int8_matmul() -> Bool

Returns True if the host system has the Neon int8 matrix multiplication extension (I8MM), otherwise returns False.

Returns:

True if the host system support the Neon int8 matrix multiplication extension (I8MM) and False otherwise.





url:https://docs.modular.com/mojo/stdlib/sys/info/has_sse4
function

has_sse4

has_sse4() -> Bool

Returns True if the host system has sse4, otherwise returns False.

Returns:

True if the host system has sse4, otherwise returns False.





url:https://docs.modular.com/mojo/stdlib/sys/info/has_vnni
function

has_vnni

has_vnni() -> Bool

Returns True if the host system has avx512_vnni, otherwise returns False.

Returns:

True if the host system has avx512_vnni, otherwise returns False.





url:https://docs.modular.com/mojo/stdlib/sys/info/is_32bit
function

is_32bit

is_32bit[target: target = current_target()]() -> Bool

Returns True if the maximum integral value is 32 bit.

Parameters:

Returns:

True if the maximum integral value is 32 bit, False otherwise.

​target (target): The target architecture.





url:https://docs.modular.com/mojo/stdlib/sys/info/is_64bit
function

is_64bit

is_64bit[target: target = current_target()]() -> Bool

Returns True if the maximum integral value is 64 bit.

Parameters:

Returns:

True if the maximum integral value is 64 bit, False otherwise.

​target (target): The target architecture.





url:https://docs.modular.com/mojo/stdlib/sys/info/is_apple_m1
function

is_apple_m1

is_apple_m1() -> Bool

Returns True if the host system is an Apple M1 with AMX support, otherwise returns False.

Returns:

True if the host system is an Apple M1 with AMX support and False otherwise.





url:https://docs.modular.com/mojo/stdlib/sys/info/is_apple_m2
function

is_apple_m2

is_apple_m2() -> Bool

Returns True if the host system is an Apple M2 with AMX support, otherwise returns False.

Returns:

True if the host system is an Apple M2 with AMX support and False otherwise.





url:https://docs.modular.com/mojo/stdlib/sys/info/is_apple_m3
function

is_apple_m3

is_apple_m3() -> Bool

Returns True if the host system is an Apple M3 with AMX support, otherwise returns False.

Returns:

True if the host system is an Apple M3 with AMX support and False otherwise.





url:https://docs.modular.com/mojo/stdlib/sys/info/is_apple_silicon
function

is_apple_silicon

is_apple_silicon() -> Bool

Returns True if the host system is an Apple Silicon with AMX support, otherwise returns False.

Returns:

True if the host system is an Apple Silicon with AMX support and False otherwise.





url:https://docs.modular.com/mojo/stdlib/sys/info/is_big_endian
function

is_big_endian

is_big_endian[target: target = current_target()]() -> Bool

Returns True if the host endianness is big and False otherwise.

Parameters:

Returns:

True if the host target is big endian and False otherwise.

​target (target): The target architecture.





url:https://docs.modular.com/mojo/stdlib/sys/info/is_little_endian
function

is_little_endian

is_little_endian[target: target = current_target()]() -> Bool

Returns True if the host endianness is little and False otherwise.

Parameters:

Returns:

True if the host target is little endian and False otherwise.

​target (target): The target architecture.





url:https://docs.modular.com/mojo/stdlib/sys/info/is_neoverse_n1
function

is_neoverse_n1

is_neoverse_n1() -> Bool

Returns True if the host system is a Neoverse N1 system, otherwise returns False.

Returns:

True if the host system is a Neoverse N1 system and False otherwise.





url:https://docs.modular.com/mojo/stdlib/sys/info/is_triple
function

is_triple

is_triple[triple: StringLiteral]() -> Bool

Returns True if the target triple of the compiler matches the input and False otherwise.

Parameters:

Returns:

True if the triple matches and False otherwise.

​triple (StringLiteral): The triple value to be checked against.





url:https://docs.modular.com/mojo/stdlib/sys/info/is_x86
function

is_x86

is_x86() -> Bool

Returns True if the host system architecture is X86 and False otherwise.

Returns:

True if the host system architecture is X86 and False otherwise.





url:https://docs.modular.com/mojo/stdlib/sys/info/num_logical_cores
function

num_logical_cores

num_logical_cores() -> Int

Returns the number of hardware threads, including hyperthreads across all CPU sockets.

Returns:

Int: The number of threads on the system.





url:https://docs.modular.com/mojo/stdlib/sys/info/num_performance_cores
function

num_performance_cores

num_performance_cores() -> Int

Returns the number of physical performance cores across all CPU sockets. If not known, returns the total number of physical cores.

Returns:

Int: The number of physical performance cores on the system.





url:https://docs.modular.com/mojo/stdlib/sys/info/num_physical_cores
function

num_physical_cores

num_physical_cores() -> Int

Returns the number of physical cores across all CPU sockets.

Returns:

Int: The number of physical cores on the system.





url:https://docs.modular.com/mojo/stdlib/sys/info/os_is_linux
function

os_is_linux

os_is_linux() -> Bool

Returns True if the host operating system is Linux.

Returns:

True if the host operating system is Linux and False otherwise.





url:https://docs.modular.com/mojo/stdlib/sys/info/os_is_macos
function

os_is_macos

os_is_macos() -> Bool

Returns True if the host operating system is macOS.

Returns:

True if the host operating system is macOS and False otherwise.





url:https://docs.modular.com/mojo/stdlib/sys/info/os_is_windows
function

os_is_windows

os_is_windows() -> Bool

Returns True if the host operating system is Windows.

Returns:

True if the host operating system is Windows and False otherwise.





url:https://docs.modular.com/mojo/stdlib/sys/info/simdbitwidth
function

simdbitwidth

simdbitwidth[target: target = current_target()]() -> IntLiteral

Returns the vector size (in bits) of the host system.

Parameters:

Returns:

The vector size (in bits) of the host system.

​target (target): The target architecture.





url:https://docs.modular.com/mojo/stdlib/sys/info/simdbytewidth
function

simdbytewidth

simdbytewidth[target: target = current_target()]() -> IntLiteral

Returns the vector size (in bytes) of the host system.

Parameters:

Returns:

The vector size (in bytes) of the host system.

​target (target): The target architecture.





url:https://docs.modular.com/mojo/stdlib/sys/info/simdwidthof
function

simdwidthof

simdwidthof[type: AnyTrivialRegType, target: target = current_target()]() -> IntLiteral

Returns the vector size of the type on the host system.

Parameters:

Returns:

The vector size of the type on the host system.

​type (AnyTrivialRegType): The type in question.
​target (target): The target architecture.





url:https://docs.modular.com/mojo/stdlib/sys/info/sizeof
function

sizeof

sizeof[type: AnyType, target: target = current_target()]() -> IntLiteral

Returns the size of (in bytes) of the type.

Parameters:

Returns:

The size of the type in bytes.

​type (AnyType): The type in question.
​target (target): The target architecture.





url:https://docs.modular.com/mojo/stdlib/sys/info/triple_is_nvidia_cuda
function

triple_is_nvidia_cuda

triple_is_nvidia_cuda() -> Bool

Returns True if the target triple of the compiler is nvptx64-nvidia-cuda False otherwise.

Returns:

True if the triple target is cuda and False otherwise.





url:https://docs.modular.com/mojo/stdlib/sys/intrinsics/
module

intrinsics





url:https://docs.modular.com/mojo/stdlib/sys/intrinsics/PrefetchCache
struct

PrefetchCache

__init__(value: Int) -> Self

Constructs a prefetch option.

Args:

Returns:

The prefetch cache type that was constructed.

​value (Int): An integer value representing the prefetch cache option to be used. Should be a value in the range [0, 1].

__init__(value: Int) -> Self

Constructs a prefetch option.

Args:

Returns:

The prefetch cache type that was constructed.

​value (Int): An integer value representing the prefetch cache option to be used. Should be a value in the range [0, 1].

__init__(value: Int) -> Self

Constructs a prefetch option.

Args:

Returns:

The prefetch cache type that was constructed.

​value (Int): An integer value representing the prefetch cache option to be used. Should be a value in the range [0, 1].





url:https://docs.modular.com/mojo/stdlib/sys/intrinsics/PrefetchLocality
struct

PrefetchLocality

__init__(value: Int) -> Self

Constructs a prefetch locality option.

Args:

Returns:

The prefetch locality constructed.

​value (Int): An integer value representing the locality. Should be a value in the range [0, 3].

__init__(value: Int) -> Self

Constructs a prefetch locality option.

Args:

Returns:

The prefetch locality constructed.

​value (Int): An integer value representing the locality. Should be a value in the range [0, 3].

__init__(value: Int) -> Self

Constructs a prefetch locality option.

Args:

Returns:

The prefetch locality constructed.

​value (Int): An integer value representing the locality. Should be a value in the range [0, 3].





url:https://docs.modular.com/mojo/stdlib/sys/intrinsics/PrefetchOptions
struct

PrefetchOptions

__init__(inout self: Self)

Constructs an instance of PrefetchOptions with default params.

__init__(inout self: Self)

Constructs an instance of PrefetchOptions with default params.

__init__(inout self: Self)

Constructs an instance of PrefetchOptions with default params.

for_read(self: Self) -> Self

Sets the prefetch purpose to read.

Returns:

The updated prefetch parameter.

for_write(self: Self) -> Self

Sets the prefetch purpose to write.

Returns:

The updated prefetch parameter.

no_locality(self: Self) -> Self

Sets the prefetch locality to none.

Returns:

The updated prefetch parameter.

low_locality(self: Self) -> Self

Sets the prefetch locality to low.

Returns:

The updated prefetch parameter.

medium_locality(self: Self) -> Self

Sets the prefetch locality to medium.

Returns:

The updated prefetch parameter.

high_locality(self: Self) -> Self

Sets the prefetch locality to high.

Returns:

The updated prefetch parameter.

to_data_cache(self: Self) -> Self

Sets the prefetch target to data cache.

Returns:

The updated prefetch parameter.

to_instruction_cache(self: Self) -> Self

Sets the prefetch target to instruction cache.

Returns:

The updated prefetch parameter.





url:https://docs.modular.com/mojo/stdlib/sys/intrinsics/PrefetchRW
struct

PrefetchRW

__init__(value: Int) -> Self

Constructs a prefetch read-write option.

Args:

Returns:

The prefetch read-write option constructed.

​value (Int): An integer value representing the prefetch read-write option to be used. Should be a value in the range [0, 1].

__init__(value: Int) -> Self

Constructs a prefetch read-write option.

Args:

Returns:

The prefetch read-write option constructed.

​value (Int): An integer value representing the prefetch read-write option to be used. Should be a value in the range [0, 1].

__init__(value: Int) -> Self

Constructs a prefetch read-write option.

Args:

Returns:

The prefetch read-write option constructed.

​value (Int): An integer value representing the prefetch read-write option to be used. Should be a value in the range [0, 1].





url:https://docs.modular.com/mojo/stdlib/sys/intrinsics/compressed_store
function

compressed_store

compressed_store[type: DType, size: Int](value: SIMD[type, size], addr: DTypePointer[type, 0], mask: SIMD[bool, size])

Compresses the lanes of value, skipping mask lanes, and stores at addr.

Parameters:

Args:

​type (DType): DType of value, the value to store.
​size (Int): Size of value, the value to store.

​value (SIMD[type, size]): The vector containing data to store.
​addr (DTypePointer[type, 0]): The memory location to store the compressed data.
​mask (SIMD[bool, size]): A binary vector which prevents memory access to certain lanes of value.





url:https://docs.modular.com/mojo/stdlib/sys/intrinsics/gather
function

gather

gather[type: DType, size: Int](base: SIMD[address, size], mask: SIMD[bool, size], passthrough: SIMD[type, size], alignment: Int = 0) -> SIMD[$0, $1]

Reads scalar values from a SIMD vector, and gathers them into one vector.

The gather function reads scalar values from a SIMD vector of memory
locations and gathers them into one vector. The memory locations are
provided in the vector of pointers base as addresses. The memory is
accessed according to the provided mask. The mask holds a bit for each
vector lane, and is used to prevent memory accesses to the masked-off
lanes. The masked-off lanes in the result vector are taken from the
corresponding lanes of the passthrough operand.

In general, for some vector of pointers base, mask mask, and passthrough
pass a call of the form:

is equivalent to the following sequence of scalar loads in C++:

Parameters:

Args:

Returns:

A SIMD[type, size] containing the result of the gather operation.

​type (DType): DType of the return SIMD buffer.
​size (Int): Size of the return SIMD buffer.

​base (SIMD[address, size]): The vector containing memory addresses that gather will access.
​mask (SIMD[bool, size]): A binary vector which prevents memory access to certain lanes of the base vector.
​passthrough (SIMD[type, size]): In the result vector, the masked-off lanes are replaced with the passthrough vector.
​alignment (Int): The alignment of the source addresses. Must be 0 or a power of two constant integer value.





url:https://docs.modular.com/mojo/stdlib/sys/intrinsics/llvm_intrinsic
function

llvm_intrinsic

llvm_intrinsic[intrin: StringLiteral, type: AnyTrivialRegType, has_side_effect: Bool = 1]() -> $1

Calls an LLVM intrinsic with no arguments.

Calls an LLVM intrinsic with the name intrin and return type type.

Parameters:

Returns:

The result of calling the llvm intrinsic with no arguments.

​intrin (StringLiteral): The name of the llvm intrinsic.
​type (AnyTrivialRegType): The return type of the intrinsic.
​has_side_effect (Bool): If True the intrinsic will have side effects, otherwise its pure.





url:https://docs.modular.com/mojo/stdlib/sys/intrinsics/masked_load
function

masked_load

masked_load[size: Int](addr: DTypePointer[type, address_space], mask: SIMD[bool, size], passthrough: SIMD[type, size], alignment: Int = 1) -> SIMD[$1, $0]

Loads data from memory and return it, replacing masked lanes with values from the passthrough vector.

Parameters:

Args:

Returns:

The loaded memory stored in a vector of type SIMD[type, size].

​size (Int): Size of the return SIMD buffer.

​addr (DTypePointer[type, address_space]): The base pointer for the load.
​mask (SIMD[bool, size]): A binary vector which prevents memory access to certain lanes of the memory stored at addr.
​passthrough (SIMD[type, size]): In the result vector, the masked-off lanes are replaced with the passthrough vector.
​alignment (Int): The alignment of the source addresses. Must be 0 or a power of two constant integer value. Default is 1.





url:https://docs.modular.com/mojo/stdlib/sys/intrinsics/masked_store
function

masked_store

masked_store[size: Int](value: SIMD[type, size], addr: DTypePointer[type, 0], mask: SIMD[bool, size], alignment: Int = 1)

Stores a value at a memory location, skipping masked lanes.

Parameters:

Args:

​size (Int): Size of value, the data to store.

​value (SIMD[type, size]): The vector containing data to store.
​addr (DTypePointer[type, 0]): A vector of memory location to store data at.
​mask (SIMD[bool, size]): A binary vector which prevents memory access to certain lanes of value.
​alignment (Int): The alignment of the destination locations. Must be 0 or a power of two constant integer value.





url:https://docs.modular.com/mojo/stdlib/sys/intrinsics/prefetch
function

prefetch

prefetch[params: PrefetchOptions, type: DType, address_space: AddressSpace](addr: DTypePointer[type, address_space])

Prefetches an instruction or data into cache before it is used.

The prefetch function provides prefetching hints for the target
to prefetch instruction or data into cache before they are used.

Parameters:

Args:

​params (PrefetchOptions): Configuration options for the prefect intrinsic.
​type (DType): The DType of value stored in addr.
​address_space (AddressSpace): The address space of the pointer.

​addr (DTypePointer[type, address_space]): The data pointer to prefetch.





url:https://docs.modular.com/mojo/stdlib/sys/intrinsics/scatter
function

scatter

scatter[type: DType, size: Int](value: SIMD[type, size], base: SIMD[address, size], mask: SIMD[bool, size], alignment: Int = 0)

Takes scalar values from a SIMD vector and scatters them into a vector of pointers.

The scatter operation stores scalar values from a SIMD vector of memory
locations and scatters them into a vector of pointers. The memory locations
are provided in the vector of pointers base as addresses. The memory is
stored according to the provided mask. The mask holds a bit for each vector
lane, and is used to prevent memory accesses to the masked-off lanes.

The value operand is a vector value to be written to memory. The base
operand is a vector of pointers, pointing to where the value elements
should be stored. It has the same underlying type as the value operand. The
mask operand, mask, is a vector of boolean values. The types of the
mask and the value operand must have the same number of vector
elements.

Scatter with overlapping addresses is guaranteed to be ordered from
least-significant to most-significant element.

In general, for some vector %value, vector of pointers %base, and mask
%mask instructions of the form:

is equivalent to the following sequence of scalar loads in C++:

Parameters:

Args:

​type (DType): DType of value, the result SIMD buffer.
​size (Int): Size of value, the result SIMD buffer.

​value (SIMD[type, size]): The vector that will contain the result of the scatter operation.
​base (SIMD[address, size]): The vector containing memory addresses that scatter will access.
​mask (SIMD[bool, size]): A binary vector which prevents memory access to certain lanes of the base vector.
​alignment (Int): The alignment of the source addresses. Must be 0 or a power of two constant integer value.





url:https://docs.modular.com/mojo/stdlib/sys/intrinsics/strided_load
function

strided_load

strided_load[type: DType, simd_width: Int, /, address_space: AddressSpace = 0](addr: DTypePointer[type, address_space], stride: Int, mask: SIMD[bool, simd_width]) -> SIMD[$0, $1]

Loads values from addr according to a specific stride.

Parameters:

Args:

Returns:

A vector containing the loaded data.

​type (DType): DType of value, the value to store.
​simd_width (Int): The width of the SIMD vectors.
​address_space (AddressSpace): The address space of the memory location.

​addr (DTypePointer[type, address_space]): The memory location to load data from.
​stride (Int): How many lanes to skip before loading again.
​mask (SIMD[bool, simd_width]): A binary vector which prevents memory access to certain lanes of value.





url:https://docs.modular.com/mojo/stdlib/sys/intrinsics/strided_store
function

strided_store

strided_store[type: DType, simd_width: Int, /, address_space: AddressSpace = 0](value: SIMD[type, simd_width], addr: DTypePointer[type, address_space], stride: Int, mask: SIMD[bool, simd_width])

Loads values from addr according to a specific stride.

Parameters:

Args:

​type (DType): DType of value, the value to store.
​simd_width (Int): The width of the SIMD vectors.
​address_space (AddressSpace): The address space of the memory location.

​value (SIMD[type, simd_width]): The values to store.
​addr (DTypePointer[type, address_space]): The location to store values at.
​stride (Int): How many lanes to skip before storing again.
​mask (SIMD[bool, simd_width]): A binary vector which prevents memory access to certain lanes of value.





url:https://docs.modular.com/mojo/stdlib/sys/param_env/
module

param_env





url:https://docs.modular.com/mojo/stdlib/sys/param_env/env_get_int
function

env_get_int

env_get_int[name: StringLiteral]() -> Int

Try to get an integer-valued define. Compilation fails if the name is not defined.

Parameters:

Returns:

An integer parameter value.

​name (StringLiteral): The name of the define.





url:https://docs.modular.com/mojo/stdlib/sys/param_env/env_get_string
function

env_get_string

env_get_string[name: StringLiteral]() -> StringLiteral

Try to get a string-valued define. Compilation fails if the name is not defined.

Parameters:

Returns:

A string parameter value.

​name (StringLiteral): The name of the define.





url:https://docs.modular.com/mojo/stdlib/sys/param_env/is_defined
function

is_defined

is_defined[name: StringLiteral]() -> Bool

Return true if the named value is defined.

Parameters:

Returns:

True if the name is defined.

​name (StringLiteral): The name to test.





url:https://docs.modular.com/mojo/stdlib/sys/terminate/
module

terminate





url:https://docs.modular.com/mojo/stdlib/sys/terminate/exit
function

exit

exit()

Exits from Mojo. Unlike the Python implementation this does not raise an exception to exit.





url:https://docs.modular.com/mojo/stdlib/tempfile/
package

tempfile





url:https://docs.modular.com/mojo/stdlib/tempfile/tempfile/
module

tempfile





url:https://docs.modular.com/mojo/stdlib/tempfile/tempfile/gettempdir
function

gettempdir

gettempdir() -> Optional[String]

Return the default directory to use for temporary files.

Returns:

The name of the default temporary directory.





url:https://docs.modular.com/mojo/stdlib/tempfile/tempfile/mkdtemp
function

mkdtemp

mkdtemp(suffix: String = "", prefix: String = "tmp", dir: Optional[String] = #kgen.none) -> String

Create a temporary directory. Caller is responsible for deleting the directory when done with it.

Args:

Returns:

The name of the created directory.

Raises:

If the directory can not be created.

​suffix (String): Suffix to use for the directory name.
​prefix (String): Prefix to use for the directory name.
​dir (Optional[String]): Directory in which the directory will be created.





url:https://docs.modular.com/mojo/stdlib/tensor/
package

tensor





url:https://docs.modular.com/mojo/stdlib/tensor/tensor/
module

tensor





url:https://docs.modular.com/mojo/stdlib/tensor/tensor/Tensor
struct

Tensor

__init__(inout self: Self)

Default initializer for TensorShape.

__init__(inout self: Self)

Default initializer for TensorShape.

__init__(inout self: Self)

Default initializer for TensorShape.

__copyinit__(inout self: Self, other: Self)

Creates a deep copy of an existing tensor.

Args:

​other (Self): The tensor to copy from.

__moveinit__(inout self: Self, owned existing: Self)

Move initializer for the tensor.

Args:

​existing (Self): The tensor to move.

__del__(owned self: Self)

Delete the spec and release any owned memory.

__getitem__(self: Self, index: Int) -> SIMD[type, 1]

Gets the value at the specified index.

Args:

Returns:

The value at the specified indices.

​index (Int): The index of the value to retrieve.

__setitem__(inout self: Self, index: Int, val: SIMD[type, 1])

Sets the value at the specified index.

Args:

​index (Int): The index of the value to set.
​val (SIMD[type, 1]): The value to store.

__eq__(self: Self, other: Self) -> Bool

Returns True if the two tensors are the same and False otherwise.

Args:

Returns:

True if the two tensors are the same and False otherwise.

​other (Self): The other Tensor to compare against.

__ne__(self: Self, other: Self) -> Bool

Returns True if the two tensors are not the same and False otherwise.

Args:

Returns:

True if the two tensors are the not the same and False otherwise.

​other (Self): The other Tensor to compare against.

__add__(self: Self, other: Self) -> Self

Adds this tensor with another tensor.

Constraints:

The two tensors must have the same rank, type, and dimensions.

Args:

Returns:

The addition of both tensors.

​other (Self): The RHS of the add operation.

__sub__(self: Self, other: Self) -> Self

Subtracts a tensor from this tensor.

Constraints:

The two tensors must have the same rank, type, and dimensions.

Args:

Returns:

The addition of both tensors.

​other (Self): The RHS of the sub operation.

__mul__(self: Self, other: Self) -> Self

Multiplies this tensor with another tensor.

Constraints:

The two tensors must have the same rank, type, and dimensions.

Args:

Returns:

The multiplication of both tensors.

​other (Self): The RHS of the mul operation.

__truediv__(self: Self, other: Self) -> Self

Divides this tensor by another tensor.

TODO: Change the return type if inputs are int

Constraints:

The two tensors must have the same rank, type, and dimensions.

Args:

Returns:

The division of both tensors.

​other (Self): The RHS of the div operation.

__pow__(self: Self, exp: Int) -> Self

Returns a copy of the tensor with each element raised to the power of exponent.

Constraints:

For integral values the exponent cannot be negative.

Args:

Returns:

An exponentiated copy of tensor.

​exp (Int): Integer power to raise tensor to.

__radd__(self: Self, other: SIMD[type, 1]) -> Self

Adds this tensor with a scalar.

Args:

Returns:

The addition result.

​other (SIMD[type, 1]): The LHS of the add operation.

__rsub__(self: Self, other: SIMD[type, 1]) -> Self

Subtracts this tensor from a scalar.

Args:

Returns:

The addition result.

​other (SIMD[type, 1]): The LHS of the sub operation.

__rmul__(self: Self, other: SIMD[type, 1]) -> Self

Multiplies this tensor with a scalar.

Args:

Returns:

The multiplication result.

​other (SIMD[type, 1]): The LHS of the mul operation.

__rtruediv__(self: Self, other: SIMD[type, 1]) -> Self

Divides a scalar by this tensor, broadcasting elementwise.

Args:

Returns:

The division result.

​other (SIMD[type, 1]): The LHS of the div operation.

__ipow__(inout self: Self, exponent: Int)

In-place pow operator.

Raises each element of the tensor to the power of exponent in place.

Constraints:

For integral values the exponent cannot be negative.

Args:

​exponent (Int): Integer power to raise tensor to.

static rand(owned shape: TensorShape) -> Self

Constructs a new tensor with the specified shape and fills it with random elements.

Args:

Returns:

A new tensor of specified shape and filled with random elements.

​shape (TensorShape): The tensor shape.

static randn(owned shape: TensorShape, mean: SIMD[float64, 1] = #kgen.float_literal<0|1>, variance: SIMD[float64, 1] = #kgen.float_literal<1|1>) -> Self

Constructs a new Tensor from the shape and fills it with random values from a Normal(mean, variance) distribution.

Constraints:

The type should be floating point.

Args:

Returns:

A Tensor filled with random dtype samples from Normal(mean, variance).

​shape (TensorShape): The shape of the Tensor to fill with random values.
​mean (SIMD[float64, 1]): Normal distribution mean.
​variance (SIMD[float64, 1]): Normal distribution variance.

ireshape(inout self: Self, new_shape: TensorShape)

(Inplace) Reshapes the tensor by assigning it a new shape.

Args:

​new_shape (TensorShape): The new shape.

reshape(inout self: Self, new_shape: TensorShape) -> Self

Returns a reshaped tensor.

Args:

Returns:

A Tensor that is a reshaped version of the original tensor.

​new_shape (TensorShape): The new shape.

astype[new_type: DType](self: Self) -> Tensor[$0]

Copy the Tensor with elements cast to the new type.

Parameters:

Returns:

A new tensor with the same values but the new type.

​new_type (DType): The type to cast the values to.

clip(self: Self, lower_bound: SIMD[type, 1], upper_bound: SIMD[type, 1]) -> Self

Clips the values of the tensor.

Args:

Returns:

A clipped version of the tensor.

​lower_bound (SIMD[type, 1]): The lower bound.
​upper_bound (SIMD[type, 1]): The upper bound.

unsafe_ptr(self: Self) -> DTypePointer[type, 0]

Gets the underlying Data pointer to the Tensor.

Returns:

The underlying data pointer of the tensor.

unsafe_uint8_ptr(self: Self) -> DTypePointer[uint8, 0]

Gets the underlying Data pointer to the Tensor.

Returns:

The underlying data pointer of the tensor.

rank(self: Self) -> Int

Gets the rank of the tensor.

Returns:

The rank of the tensor.

num_elements(self: Self) -> Int

Gets the total number of elements in the tensor.

Returns:

The total number of elements in the tensor.

bytecount(self: Self) -> Int

Gets the total bytecount of the tensor.

Returns:

The total bytecount of the tensor.

spec(self: Self) -> TensorSpec

Gets the specification of the tensor.

Returns:

The underlying tensor spec of the tensor.

shape(self: Self) -> TensorShape

Gets the shape of the tensor.

Returns:

The underlying tensor shape of the tensor.

dim(self: Self, idx: Int) -> Int

Gets the dimension at the specified index.

Args:

Returns:

The dimension at the specified index.

​idx (Int): The dimension index.

load[*, width: Int = 1](self: Self, index: Int) -> SIMD[type, $0]

Gets the SIMD value at the specified index.

Parameters:

Args:

Returns:

The SIMD value at the specified indices.

​width (Int): The SIMD width of the vector.

​index (Int): The index of the value to retrieve.

store[*, width: Int = 1](inout self: Self, index: Int, val: SIMD[type, width])

Sets the SIMD value at the specified index.

Parameters:

Args:

​width (Int): The SIMD width of the vector.

​index (Int): The index of the value to set.
​val (SIMD[type, width]): The SIMD value to store.

argmax(self: Self, *, axis: Int = -1) -> Tensor[index]

Finds the indices of the maximum element along the specified axis.

Args:

Returns:

A new tensor containing the indices of the maximum elements along axis.

​axis (Int): The axis.

argmin(self: Self, *, axis: Int = -1) -> Tensor[index]

Finds the indices of the minimum element along the specified axis.

Args:

Returns:

A new tensor containing the indices of the minimum elements along axis.

​axis (Int): The axis.

tofile(self: Self, path: Path)

Write values to a file.

Args:

​path (Path): Path to the output file.

static fromfile(path: Path) -> Self

Read tensor from a file.

Args:

Returns:

The tensor read from file.

​path (Path): Path to the output file.

save(self: Self, path: Path)

Save given tensor to file. This method preserves    shape and datatype information.

Args:

​path (Path): Path of file.





url:https://docs.modular.com/mojo/stdlib/tensor/tensor_shape/
module

tensor_shape





url:https://docs.modular.com/mojo/stdlib/tensor/tensor_shape/TensorShape
struct

TensorShape

__init__(inout self: Self)

Default initializer for TensorShape.

__init__(inout self: Self)

Default initializer for TensorShape.

__init__(inout self: Self)

Default initializer for TensorShape.

__copyinit__(inout self: Self, other: Self)

Creates a deep copy of an existing shape.

Args:

​other (Self): The shape to copy.

__moveinit__(inout self: Self, owned existing: Self)

Move initializer for the shape.

Args:

​existing (Self): The shape to move.

__del__(owned self: Self)

Delete the shape and release any owned memory.

__getitem__(self: Self, index: Int) -> Int

Gets the dimension at the specified index.

Args:

Returns:

The dimension at the specified index.

​index (Int): The dimension index.

__eq__(self: Self, other: Self) -> Bool

Returns True if the two values are the same and False otherwise.

Args:

Returns:

True if the two shapes are the same and False otherwise.

​other (Self): The other TensorShape to compare against.

__ne__(self: Self, other: Self) -> Bool

Returns True if the two values are not the same and False otherwise.

Args:

Returns:

True if the two shapes are the not the same and False otherwise.

​other (Self): The other TensorShape to compare against.

rank(self: Self) -> Int

Gets the rank of the shape.

Returns:

The rank of the shape.

num_elements(self: Self) -> Int

Gets the total number of elements in the shape.

Returns:

The total number of elements in the shape.





url:https://docs.modular.com/mojo/stdlib/tensor/tensor_spec/
module

tensor_spec





url:https://docs.modular.com/mojo/stdlib/tensor/tensor_spec/TensorSpec
struct

TensorSpec

__init__(inout self: Self)

Default initializer for TensorShape.

__init__(inout self: Self)

Default initializer for TensorShape.

__init__(inout self: Self)

Default initializer for TensorShape.

__copyinit__(inout self: Self, other: Self)

Creates a deep copy of an existing spec.

Args:

​other (Self): The spec to copy.

__moveinit__(inout self: Self, owned existing: Self)

Move initializer for the spec.

Args:

​existing (Self): The spec to move.

__getitem__(self: Self, index: Int) -> Int

Gets the dimension at the specified index.

Args:

Returns:

The dimension at the specified index.

​index (Int): The dimension index.

__eq__(self: Self, other: Self) -> Bool

Returns True if the two values are the same and False otherwise.

Args:

Returns:

True if the two specs are the same and False otherwise.

​other (Self): The other TensorSpec to compare against.

__ne__(self: Self, other: Self) -> Bool

Returns True if the two values are not the same and False otherwise.

Args:

Returns:

True if the two specs are the not the same and False otherwise.

​other (Self): The other TensorSpec to compare against.

rank(self: Self) -> Int

Gets the rank of the spec.

Returns:

The rank of the spec.

dtype(self: Self) -> DType

Gets the DType of the spec.

Returns:

The DType of the spec.

num_elements(self: Self) -> Int

Gets the total number of elements in the spec.

Returns:

The total number of elements in the spec.

bytecount(self: Self) -> Int

Gets the total byte count.

Returns:

The total byte count.

static from_bytes(data: DTypePointer[uint8, 0]) -> Self

Create a TensorSpec object from serialized bytes.

Args:

Returns:

Given bytes as TensorSpec.

​data (DTypePointer[uint8, 0]): DTypePointer to serialized bytes.





url:https://docs.modular.com/mojo/stdlib/testing/
package

testing





url:https://docs.modular.com/mojo/stdlib/testing/testing/
module

testing





url:https://docs.modular.com/mojo/stdlib/testing/testing/Testable
trait

Testable

__eq__(self: T, other: T) -> Bool

Define whether two instances of the object are equal to each other.

Args:

Returns:

True if the instances are equal according to the type's definition of equality, False otherwise.

​other (T): Another instance of the same type.

__eq__(self: T, other: T) -> Bool

Define whether two instances of the object are equal to each other.

Args:

Returns:

True if the instances are equal according to the type's definition of equality, False otherwise.

​other (T): Another instance of the same type.

__eq__(self: T, other: T) -> Bool

Define whether two instances of the object are equal to each other.

Args:

Returns:

True if the instances are equal according to the type's definition of equality, False otherwise.

​other (T): Another instance of the same type.

__ne__(self: T, other: T) -> Bool

Define whether two instances of the object are not equal to each other.

Args:

Returns:

True if the instances are not equal according to the type's definition of equality, False otherwise.

​other (T): Another instance of the same type.





url:https://docs.modular.com/mojo/stdlib/testing/testing/assert_almost_equal
function

assert_almost_equal

assert_almost_equal[type: DType, size: Int](lhs: SIMD[type, size], rhs: SIMD[type, size], /, *, msg: String = "", atol: SIMD[type, 1] = #kgen.float_literal<1|100000000>, rtol: SIMD[type, 1] = #kgen.float_literal<1|100000>, equal_nan: Bool = 0)

Asserts that the input values are equal up to a tolerance. If it is not then an Error is raised.

When the type is boolean or integral, then equality is checked. When the
type is floating-point, then this checks if the two input values are
numerically the close using the abs(lhs−rhs)<=max(rtol∗max(abs(lhs),abs(rhs)),atol)abs(lhs - rhs) <= max(rtol * max(abs(lhs), abs(rhs)), atol)abs(lhs−rhs)<=max(rtol∗max(abs(lhs),abs(rhs)),atol) formula.

Constraints:

The type must be boolean, integral, or floating-point.

Parameters:

Args:

Raises:

An Error with the provided message if assert fails and None otherwise.

​type (DType): The dtype of the left- and right-hand-side SIMD vectors.
​size (Int): The width of the left- and right-hand-side SIMD vectors.

​lhs (SIMD[type, size]): The lhs of the equality.
​rhs (SIMD[type, size]): The rhs of the equality.
​msg (String): The message to print.
​atol (SIMD[type, 1]): The absolute tolerance.
​rtol (SIMD[type, 1]): The relative tolerance.
​equal_nan (Bool): Whether to treat nans as equal.





url:https://docs.modular.com/mojo/stdlib/testing/testing/assert_equal
function

assert_equal

assert_equal[T: Testable](lhs: T, rhs: T, msg: String = "")

Asserts that the input values are equal. If it is not then an Error is raised.

Parameters:

Args:

Raises:

An Error with the provided message if assert fails and None otherwise.

​T (Testable): A Testable type.

​lhs (T): The lhs of the equality.
​rhs (T): The rhs of the equality.
​msg (String): The message to be printed if the assertion fails.





url:https://docs.modular.com/mojo/stdlib/testing/testing/assert_false
function

assert_false

assert_false(val: Bool, msg: String = "condition was unexpectedly True")

Asserts that the input value is False. If it is not then an Error is raised.

Args:

Raises:

An Error with the provided message if assert fails and None otherwise.

​val (Bool): The value to assert to be False.
​msg (String): The message to be printed if the assertion fails.





url:https://docs.modular.com/mojo/stdlib/testing/testing/assert_not_equal
function

assert_not_equal

assert_not_equal[T: Testable](lhs: T, rhs: T, msg: String = "")

Asserts that the input values are not equal. If it is not then an Error is raised.

Parameters:

Args:

Raises:

An Error with the provided message if assert fails and None otherwise.

​T (Testable): A Testable type.

​lhs (T): The lhs of the inequality.
​rhs (T): The rhs of the inequality.
​msg (String): The message to be printed if the assertion fails.





url:https://docs.modular.com/mojo/stdlib/testing/testing/assert_raises
struct

assert_raises

__init__(inout self: Self)

Construct a context manager with no message pattern.

__init__(inout self: Self)

Construct a context manager with no message pattern.

__init__(inout self: Self)

Construct a context manager with no message pattern.





url:https://docs.modular.com/mojo/stdlib/testing/testing/assert_true
function

assert_true

assert_true(val: Bool, msg: String = "condition was unexpectedly False")

Asserts that the input value is True. If it is not then an Error is raised.

Args:

Raises:

An Error with the provided message if assert fails and None otherwise.

​val (Bool): The value to assert to be True.
​msg (String): The message to be printed if the assertion fails.





url:https://docs.modular.com/mojo/stdlib/time/
package

time





url:https://docs.modular.com/mojo/stdlib/time/time/
module

time





url:https://docs.modular.com/mojo/stdlib/time/time/now
function

now

now() -> Int

Returns the current monotonic time time in nanoseconds. This function queries the current platform's monotonic clock, making it useful for measuring time differences, but the significance of the returned value varies depending on the underlying implementation.

Returns:

The current time in ns.





url:https://docs.modular.com/mojo/stdlib/time/time/sleep
function

sleep

sleep(sec: SIMD[float64, 1])

Suspends the current thread for the seconds specified.

Args:

​sec (SIMD[float64, 1]): The number of seconds to sleep for.





url:https://docs.modular.com/mojo/stdlib/time/time/time_function
function

time_function

time_function[func: fn() capturing -> None]() -> Int

Measures the time spent in the function.

Parameters:

Returns:

The time elapsed in the function in ns.

​func (fn() capturing -> None): The function to time.





url:https://docs.modular.com/mojo/stdlib/utils/
package

utils





url:https://docs.modular.com/mojo/stdlib/utils/index_/
module

index





url:https://docs.modular.com/mojo/stdlib/utils/index_/Index-function
function

Index

Index[T0: Intable](x: T0) -> StaticIntTuple[1]

Constructs a 1-D Index from the given value.

Parameters:

Args:

Returns:

The constructed StaticIntTuple.

​T0 (Intable): The type of the 1st argument.

​x (T0): The initial value.





url:https://docs.modular.com/mojo/stdlib/utils/index_/StaticIntTuple
struct

StaticIntTuple

__init__(inout self: Self)

Constructs a static int tuple of the given size.

__init__(inout self: Self)

Constructs a static int tuple of the given size.

__init__(inout self: Self)

Constructs a static int tuple of the given size.

__getitem__(self: Self, idx: Int) -> Int

Gets an element from the tuple by index.

Args:

Returns:

The tuple element value.

​idx (Int): The element index.

__setitem__[index: Int](inout self: Self, val: Int)

Sets an element in the tuple at the given static index.

Parameters:

Args:

​index (Int): The element index.

​val (Int): The value to store.

__lt__(self: Self, rhs: Self) -> Bool

Compares this tuple to another tuple using LT comparison.

A tuple is less-than another tuple if all corresponding elements of lhs
is less than rhs.

Note: This is not a lexical comparison.

Args:

Returns:

The comparison result.

​rhs (Self): Right hand side tuple.

__le__(self: Self, rhs: Self) -> Bool

Compares this tuple to another tuple using LE comparison.

A tuple is less-or-equal than another tuple if all corresponding
elements of lhs is less-or-equal than rhs.

Note: This is not a lexical comparison.

Args:

Returns:

The comparison result.

​rhs (Self): Right hand side tuple.

__eq__(self: Self, rhs: Self) -> Bool

Compares this tuple to another tuple for equality.

The tuples are equal if all corresponding elements are equal.

Args:

Returns:

The comparison result.

​rhs (Self): The other tuple.

__ne__(self: Self, rhs: Self) -> Bool

Compares this tuple to another tuple for non-equality.

The tuples are non-equal if at least one element of LHS isn't equal to
the corresponding element from RHS.

Args:

Returns:

The comparison result.

​rhs (Self): The other tuple.

__gt__(self: Self, rhs: Self) -> Bool

Compares this tuple to another tuple using GT comparison.

A tuple is greater-than than another tuple if all corresponding
elements of lhs is greater-than than rhs.

Note: This is not a lexical comparison.

Args:

Returns:

The comparison result.

​rhs (Self): Right hand side tuple.

__ge__(self: Self, rhs: Self) -> Bool

Compares this tuple to another tuple using GE comparison.

A tuple is greater-or-equal than another tuple if all corresponding
elements of lhs is greater-or-equal than rhs.

Note: This is not a lexical comparison.

Args:

Returns:

The comparison result.

​rhs (Self): Right hand side tuple.

__add__(self: Self, rhs: Self) -> Self

Performs element-wise integer add.

Args:

Returns:

The resulting index tuple.

​rhs (Self): Right hand side operand.

__sub__(self: Self, rhs: Self) -> Self

Performs element-wise integer subtract.

Args:

Returns:

The resulting index tuple.

​rhs (Self): Right hand side operand.

__mul__(self: Self, rhs: Self) -> Self

Performs element-wise integer multiply.

Args:

Returns:

The resulting index tuple.

​rhs (Self): Right hand side operand.

__floordiv__(self: Self, rhs: Self) -> Self

Performs element-wise integer floor division.

Args:

Returns:

The resulting index tuple.

​rhs (Self): The elementwise divisor.

__rfloordiv__(self: Self, rhs: Self) -> Self

Floor divides rhs by this object.

Args:

Returns:

The resulting index tuple.

​rhs (Self): The value to elementwise divide by self.

as_tuple(self: Self) -> StaticTuple[Int, size]

Converts this StaticIntTuple to StaticTuple.

Returns:

The corresponding StaticTuple object.

flattened_length(self: Self) -> Int

Returns the flattened length of the tuple.

Returns:

The flattened length of the tuple.

remu(self: Self, rhs: Self) -> Self

Performs element-wise integer unsigned modulo.

Args:

Returns:

The resulting index tuple.

​rhs (Self): Right hand side operand.





url:https://docs.modular.com/mojo/stdlib/utils/index_/product
function

product

product[size: Int](tuple: StaticIntTuple[size], end_idx: Int) -> Int

Computes a product of values in the tuple up to the given index.

Parameters:

Args:

Returns:

The product of all tuple elements in the given range.

​size (Int): The tuple size.

​tuple (StaticIntTuple[size]): The tuple to get a product of.
​end_idx (Int): The end index.





url:https://docs.modular.com/mojo/stdlib/utils/inline_string/
module

inline_string





url:https://docs.modular.com/mojo/stdlib/utils/inline_string/InlineString
struct

InlineString

__init__(inout self: Self)

Constructs a new empty string.

__init__(inout self: Self)

Constructs a new empty string.

__init__(inout self: Self)

Constructs a new empty string.

__add__(self: Self, other: StringLiteral) -> Self

Construct a string by appending another string at the end of this string.

Args:

Returns:

A new string containing the concatenation of self and other.

​other (StringLiteral): The string to append.

__iadd__(inout self: Self, literal: StringLiteral)

Appends another string to this string.

Args:

​literal (StringLiteral): The string to append.

unsafe_ptr(self: Self) -> UnsafePointer[SIMD[uint8, 1], 0]

Returns a pointer to the bytes of string data.

Returns:

The pointer to the underlying memory.

as_string_slice(self: Reference[InlineString, is_mutable, lifetime, 0]) -> StringSlice[$0, $1]

Returns a string slice of the data owned by this inline string.

Returns:

A string slice pointing to the data owned by this inline string.

as_bytes_slice(self: Reference[InlineString, is_mutable, lifetime, 0]) -> Span[SIMD[uint8, 1], $0, $1]

Returns a contiguous slice of the bytes owned by this string.

This does not include the trailing null terminator.

Returns:

A contiguous slice pointing to the bytes owned by this string.





url:https://docs.modular.com/mojo/stdlib/utils/loop/
module

loop





url:https://docs.modular.com/mojo/stdlib/utils/loop/unroll
function

unroll

unroll[func: fn[Int]() capturing -> None, count: Int]()

Repeatedly evaluates a function count times.

Parameters:

​func (fn[Int]() capturing -> None): The function to evaluate. The function should take a single Int argument, which is the loop index value.
​count (Int): A number of repetitions.





url:https://docs.modular.com/mojo/stdlib/utils/numerics/
module

numerics





url:https://docs.modular.com/mojo/stdlib/utils/numerics/FPUtils
struct

FPUtils

static mantissa_width() -> IntLiteral

Returns the mantissa width of a floating point type.

Returns:

The mantissa width.

static mantissa_width() -> IntLiteral

Returns the mantissa width of a floating point type.

Returns:

The mantissa width.

static mantissa_width() -> IntLiteral

Returns the mantissa width of a floating point type.

Returns:

The mantissa width.

static max_exponent() -> IntLiteral

Returns the max exponent of a floating point type.

Returns:

The max exponent.

static exponent_width() -> IntLiteral

Returns the exponent width of a floating point type.

Returns:

The exponent width.

static mantissa_mask() -> Int

Returns the mantissa mask of a floating point type.

Returns:

The mantissa mask.

static exponent_bias() -> IntLiteral

Returns the exponent bias of a floating point type.

Returns:

The exponent bias.

static sign_mask() -> Int

Returns the sign mask of a floating point type.

It is computed by 1 << (exponent_width + mantissa_width).

Returns:

The sign mask.

static exponent_mask() -> Int

Returns the exponent mask of a floating point type.

It is computed by ~(sign_mask | mantissa_mask).

Returns:

The exponent mask.

static exponent_mantissa_mask() -> Int

Returns the exponent and mantissa mask of a floating point type.

It is computed by exponent_mask + mantissa_mask.

Returns:

The exponent and mantissa mask.

static quiet_nan_mask() -> Int

Returns the quiet NaN mask for a floating point type.

The mask is defined by evaluating:

Returns:

The quiet NaN mask.

static bitcast_to_integer(value: SIMD[type, 1]) -> Int

Bitcasts the floating-point value to an integer.

Args:

Returns:

An integer representation of the floating-point value.

​value (SIMD[type, 1]): The floating-point type.

static bitcast_from_integer(value: Int) -> SIMD[type, 1]

Bitcasts the floating-point value from an integer.

Args:

Returns:

An floating-point representation of the Int.

​value (Int): The int value.

static get_sign(value: SIMD[type, 1]) -> Bool

Returns the sign of the floating point value.

Args:

Returns:

Returns True if the sign is set and False otherwise.

​value (SIMD[type, 1]): The floating-point type.

static set_sign(value: SIMD[type, 1], sign: Bool) -> SIMD[type, 1]

Sets the sign of the floating point value.

Args:

Returns:

Returns the floating point value with the sign set.

​value (SIMD[type, 1]): The floating-point value.
​sign (Bool): True to set the sign and false otherwise.

static get_exponent(value: SIMD[type, 1]) -> Int

Returns the exponent bits of the floating-point value.

Args:

Returns:

Returns the exponent bits.

​value (SIMD[type, 1]): The floating-point value.

static get_exponent_without_bias(value: SIMD[type, 1]) -> Int

Returns the exponent bits of the floating-point value.

Args:

Returns:

Returns the exponent bits.

​value (SIMD[type, 1]): The floating-point value.

static set_exponent(value: SIMD[type, 1], exponent: Int) -> SIMD[type, 1]

Sets the exponent bits of the floating-point value.

Args:

Returns:

Returns the floating-point value with the exponent bits set.

​value (SIMD[type, 1]): The floating-point value.
​exponent (Int): The exponent bits.

static get_mantissa(value: SIMD[type, 1]) -> Int

Gets the mantissa bits of the floating-point value.

Args:

Returns:

The mantissa bits.

​value (SIMD[type, 1]): The floating-point value.

static set_mantissa(value: SIMD[type, 1], mantissa: Int) -> SIMD[type, 1]

Sets the mantissa bits of the floating-point value.

Args:

Returns:

Returns the floating-point value with the mantissa bits set.

​value (SIMD[type, 1]): The floating-point value.
​mantissa (Int): The mantissa bits.

static pack(sign: Bool, exponent: Int, mantissa: Int) -> SIMD[type, 1]

Construct a floating-point value from its constituent sign, exponent, and mantissa.

Args:

Returns:

Returns the floating-point value.

​sign (Bool): The sign of the floating-point value.
​exponent (Int): The exponent of the floating-point value.
​mantissa (Int): The mantissa of the floating-point value.





url:https://docs.modular.com/mojo/stdlib/utils/numerics/FlushDenormals
struct

FlushDenormals

__init__(inout self: Self)

Initializes the FlushDenormals.

__init__(inout self: Self)

Initializes the FlushDenormals.

__init__(inout self: Self)

Initializes the FlushDenormals.





url:https://docs.modular.com/mojo/stdlib/utils/numerics/get_accum_type
function

get_accum_type

get_accum_type[type: DType]() -> DType

Returns the recommended type for accumulation operations.

Half precision types can introduce numerical error if they are used
in reduction/accumulation operations. This method returns a higher precision
type to use for accumulation if a half precision types is provided,
otherwise it returns the original type.

Parameters:

Returns:

DType.float32 if type is a half-precision float, type otherwise.

​type (DType): The type of some accumulation operation.





url:https://docs.modular.com/mojo/stdlib/utils/numerics/inf
function

inf

inf[type: DType]() -> SIMD[$0, 1]

Gets a +inf value for the given dtype.

Constraints:

Can only be used for FP dtypes.

Parameters:

Returns:

The +inf value of the given dtype.

​type (DType): The value dtype.





url:https://docs.modular.com/mojo/stdlib/utils/numerics/isfinite
function

isfinite

isfinite[type: DType, simd_width: Int](val: SIMD[type, simd_width]) -> SIMD[bool, $1]

Checks if the value is not infinite.

This is always True for non-FP data types.

Parameters:

Args:

Returns:

True if val is finite and False otherwise.

​type (DType): The value dtype.
​simd_width (Int): The width of the SIMD vector.

​val (SIMD[type, simd_width]): The value to check.





url:https://docs.modular.com/mojo/stdlib/utils/numerics/isinf
function

isinf

isinf[type: DType, simd_width: Int](val: SIMD[type, simd_width]) -> SIMD[bool, $1]

Checks if the value is infinite.

This is always False for non-FP data types.

Parameters:

Args:

Returns:

True if val is infinite and False otherwise.

​type (DType): The value dtype.
​simd_width (Int): The width of the SIMD vector.

​val (SIMD[type, simd_width]): The value to check.





url:https://docs.modular.com/mojo/stdlib/utils/numerics/isnan
function

isnan

isnan[type: DType, simd_width: Int](val: SIMD[type, simd_width]) -> SIMD[bool, $1]

Checks if the value is Not a Number (NaN).

Parameters:

Args:

Returns:

True if val is NaN and False otherwise.

​type (DType): The value dtype.
​simd_width (Int): The width of the SIMD vector.

​val (SIMD[type, simd_width]): The value to check.





url:https://docs.modular.com/mojo/stdlib/utils/numerics/max_finite
function

max_finite

max_finite[type: DType]() -> SIMD[$0, 1]

Returns the maximum finite value of type.

Parameters:

Returns:

The maximum representable value of the type. Does not include infinity for floating-point types.

​type (DType): The value dtype.





url:https://docs.modular.com/mojo/stdlib/utils/numerics/max_or_inf
function

max_or_inf

max_or_inf[type: DType]() -> SIMD[$0, 1]

Returns the maximum (potentially infinite) value of type.

Parameters:

Returns:

The maximum representable value of the type. Can include infinity for floating-point types.

​type (DType): The value dtype.





url:https://docs.modular.com/mojo/stdlib/utils/numerics/min_finite
function

min_finite

min_finite[type: DType]() -> SIMD[$0, 1]

Returns the minimum (lowest) finite value of type.

Parameters:

Returns:

The minimum representable value of the type. Does not include negative infinity for floating-point types.

​type (DType): The value dtype.





url:https://docs.modular.com/mojo/stdlib/utils/numerics/min_or_neg_inf
function

min_or_neg_inf

min_or_neg_inf[type: DType]() -> SIMD[$0, 1]

Returns the minimum (potentially negative infinite) value of type.

Parameters:

Returns:

The minimum representable value of the type. Can include negative infinity for floating-point types.

​type (DType): The value dtype.





url:https://docs.modular.com/mojo/stdlib/utils/numerics/nan
function

nan

nan[type: DType]() -> SIMD[$0, 1]

Gets a NaN value for the given dtype.

Constraints:

Can only be used for FP dtypes.

Parameters:

Returns:

The NaN value of the given dtype.

​type (DType): The value dtype.





url:https://docs.modular.com/mojo/stdlib/utils/numerics/neg_inf
function

neg_inf

neg_inf[type: DType]() -> SIMD[$0, 1]

Gets a -inf value for the given dtype.

Constraints:

Can only be used for FP dtypes.

Parameters:

Returns:

The -inf value of the given dtype.

​type (DType): The value dtype.





url:https://docs.modular.com/mojo/stdlib/utils/numerics/nextafter
function

nextafter

nextafter[type: DType, simd_width: Int](arg0: SIMD[type, simd_width], arg1: SIMD[type, simd_width]) -> SIMD[$0, $1]

Computes next representable value of arg0 in the direction of arg1.

Constraints:

The element type of the input must be a floating-point type.

Parameters:

Args:

Returns:

The nextafter of the inputs.

​type (DType): The dtype of the input and output SIMD vector.
​simd_width (Int): The width of the input and output SIMD vector.

​arg0 (SIMD[type, simd_width]): The first input argument.
​arg1 (SIMD[type, simd_width]): The second input argument.





url:https://docs.modular.com/mojo/stdlib/utils/numerics/ulp
function

ulp

ulp[type: DType, simd_width: Int](x: SIMD[type, simd_width]) -> SIMD[$0, $1]

Computes the ULP (units of last place) or (units of least precision) of the number.

Constraints:

The element type of the inpiut must be a floating-point type.

Parameters:

Args:

Returns:

The ULP of x.

​type (DType): The dtype of the input and output SIMD vector.
​simd_width (Int): The width of the input and output SIMD vector.

​x (SIMD[type, simd_width]): SIMD vector input.





url:https://docs.modular.com/mojo/stdlib/utils/span/
module

span





url:https://docs.modular.com/mojo/stdlib/utils/span/Span
struct

Span

__init__(inout self: Self, *, unsafe_ptr: UnsafePointer[T, 0], len: Int)

Unsafe construction from a pointer and length.

Args:

​unsafe_ptr (UnsafePointer[T, 0]): The underlying pointer of the span.
​len (Int): The length of the view.

__init__(inout self: Self, *, unsafe_ptr: UnsafePointer[T, 0], len: Int)

Unsafe construction from a pointer and length.

Args:

​unsafe_ptr (UnsafePointer[T, 0]): The underlying pointer of the span.
​len (Int): The length of the view.

__init__(inout self: Self, *, unsafe_ptr: UnsafePointer[T, 0], len: Int)

Unsafe construction from a pointer and length.

Args:

​unsafe_ptr (UnsafePointer[T, 0]): The underlying pointer of the span.
​len (Int): The length of the view.

__getitem__(self: Self, idx: Int) -> ref [lifetime] T

Get a reference to an element in the span.

Args:

Returns:

An element reference.

​idx (Int): The index of the value to return.

unsafe_ptr(self: Self) -> UnsafePointer[T, 0]

Gets a pointer to the first element of this slice.

Returns:

A pointer pointing at the first element of this slice.





url:https://docs.modular.com/mojo/stdlib/utils/static_tuple/
module

static_tuple





url:https://docs.modular.com/mojo/stdlib/utils/static_tuple/InlineArray
struct

InlineArray

__init__(inout self: Self)

This constructor will always cause a compile time error if used. It is used to steer users away from uninitialized memory.

__init__(inout self: Self)

This constructor will always cause a compile time error if used. It is used to steer users away from uninitialized memory.

__init__(inout self: Self)

This constructor will always cause a compile time error if used. It is used to steer users away from uninitialized memory.

__getitem__(self: Reference[InlineArray[ElementType, size], is_mutable, lifetime, 0], idx: Int) -> ref [$1] ElementType

Get a Reference to the element at the given index.

Args:

Returns:

A reference to the item at the given index.

​idx (Int): The index of the item.

__contains__[T: ComparableCollectionElement](self: Self, value: T) -> Bool

Verify if a given value is present in the array.

Parameters:

Args:

Returns:

True if the value is contained in the array, False otherwise.

​T (ComparableCollectionElement): The type of the elements in the array. Must implement the traits EqualityComparable and CollectionElement.

​value (T): The value to find.

unsafe_ptr(self: Self) -> UnsafePointer[ElementType, 0]

Get an UnsafePointer to the underlying array.

That pointer is unsafe but can be used to read or write to the array.
Be careful when using this. As opposed to a pointer to a List,
this pointer becomes invalid when the InlineArray is moved.

Make sure to refresh your pointer every time the InlineArray is moved.

Returns:

An UnsafePointer to the underlying array.





url:https://docs.modular.com/mojo/stdlib/utils/static_tuple/StaticTuple
struct

StaticTuple

__init__(inout self: Self)

Constructs an empty (undefined) tuple.

__init__(inout self: Self)

Constructs an empty (undefined) tuple.

__init__(inout self: Self)

Constructs an empty (undefined) tuple.

__getitem__[index: Int](self: Self) -> element_type

Returns the value of the tuple at the given index.

Parameters:

Returns:

The value at the specified position.

​index (Int): The index into the tuple.

__setitem__[index: Int](inout self: Self, val: element_type)

Stores a single value into the tuple at the specified index.

Parameters:

Args:

​index (Int): The index into the tuple.

​val (element_type): The value to store.





url:https://docs.modular.com/mojo/stdlib/utils/string_slice/
module

string_slice





url:https://docs.modular.com/mojo/stdlib/utils/string_slice/StringSlice
struct

StringSlice

__init__(inout self: Self, *, owned unsafe_from_utf8: Span[SIMD[uint8, 1], is_mutable, lifetime])

Construct a new StringSlice from a sequence of UTF-8 encoded bytes.

Safety:
unsafe_from_utf8 MUST be valid UTF-8 encoded data.

Args:

​unsafe_from_utf8 (Span[SIMD[uint8, 1], is_mutable, lifetime]): A slice of bytes encoded in UTF-8.

__init__(inout self: Self, *, owned unsafe_from_utf8: Span[SIMD[uint8, 1], is_mutable, lifetime])

Construct a new StringSlice from a sequence of UTF-8 encoded bytes.

Safety:
unsafe_from_utf8 MUST be valid UTF-8 encoded data.

Args:

​unsafe_from_utf8 (Span[SIMD[uint8, 1], is_mutable, lifetime]): A slice of bytes encoded in UTF-8.

__init__(inout self: Self, *, owned unsafe_from_utf8: Span[SIMD[uint8, 1], is_mutable, lifetime])

Construct a new StringSlice from a sequence of UTF-8 encoded bytes.

Safety:
unsafe_from_utf8 MUST be valid UTF-8 encoded data.

Args:

​unsafe_from_utf8 (Span[SIMD[uint8, 1], is_mutable, lifetime]): A slice of bytes encoded in UTF-8.

as_bytes_slice(self: Self) -> Span[SIMD[uint8, 1], is_mutable, lifetime]

Get the sequence of encoded bytes as a slice of the underlying string.

Returns:

A slice containing the underlying sequence of encoded bytes.

unsafe_ptr(self: Self) -> UnsafePointer[SIMD[uint8, 1], 0]

Gets a pointer to the first element of this string slice.

Returns:

A pointer pointing at the first element of this string slice.





url:https://docs.modular.com/mojo/stdlib/utils/stringref/
module

stringref





url:https://docs.modular.com/mojo/stdlib/utils/stringref/StringRef
struct

StringRef

__init__() -> Self

Construct a StringRef value with length zero.

Returns:

Constructed StringRef object.

__init__() -> Self

Construct a StringRef value with length zero.

Returns:

Constructed StringRef object.

__init__() -> Self

Construct a StringRef value with length zero.

Returns:

Constructed StringRef object.

__bool__(self: Self) -> Bool

Checks if the string is empty or not.

Returns:

Returns True if the string is not empty and False otherwise.

__getitem__(self: Self, idx: Int) -> Self

Get the string value at the specified position.

Args:

Returns:

The character at the specified position.

​idx (Int): The index position.

__lt__(self: Self, rhs: Self) -> Bool

Compare this StringRef to the RHS using LT comparison.

Args:

Returns:

True if this string is strictly less than the RHS string and False otherwise.

​rhs (Self): The other StringRef to compare against.

__le__(self: Self, rhs: Self) -> Bool

Compare this StringRef to the RHS using LE comparison.

Args:

Returns:

True if this string is less than or equal to the RHS string and False otherwise.

​rhs (Self): The other StringRef to compare against.

__eq__(self: Self, rhs: Self) -> Bool

Compares two strings are equal.

Args:

Returns:

True if the strings match and False otherwise.

​rhs (Self): The other string.

__ne__(self: Self, rhs: Self) -> Bool

Compares two strings are not equal.

Args:

Returns:

True if the strings do not match and False otherwise.

​rhs (Self): The other string.

__gt__(self: Self, rhs: Self) -> Bool

Compare this StringRef to the RHS using GT comparison.

Args:

Returns:

True if this string is strictly greater than the RHS string and False otherwise.

​rhs (Self): The other StringRef to compare against.

__ge__(self: Self, rhs: Self) -> Bool

Compare this StringRef to the RHS using GE comparison.

Args:

Returns:

True if this string is greater than or equal to the RHS string and False otherwise.

​rhs (Self): The other StringRef to compare against.

__contains__(self: Self, substr: Self) -> Bool

Returns True if the substring is contained within the current string.

Args:

Returns:

True if the string contains the substring.

​substr (Self): The substring to check.

take_front(self: Self, num_bytes: Int = 1) -> Self

Return a StringRef equal to 'self' but with only the first num_bytes elements remaining.  If num_bytes is greater than the length of the string, the entire string is returned.

Args:

Returns:

A new slice that starts with those bytes.

​num_bytes (Int): The number of bytes to include.

take_back(self: Self, num_bytes: Int = 1) -> Self

Return a StringRef equal to 'self' but with only the last num_bytes elements remaining.  If num_bytes is greater than the length of the string, the entire string is returned.

Args:

Returns:

A new slice that ends with those bytes.

​num_bytes (Int): The number of bytes to include.

drop_front(self: Self, num_bytes: Int = 1) -> Self

Return a StringRef equal to 'self' but with the first num_bytes elements skipped.  If num_bytes is greater than the length of the string, an empty StringRef is returned.

Args:

Returns:

A new slice with those bytes skipped.

​num_bytes (Int): The number of bytes to drop.

drop_back(self: Self, num_bytes: Int = 1) -> Self

Return a StringRef equal to 'self' but with the last num_bytes elements skipped.  If num_bytes is greater than the length of the string, the entire string is returned.

Args:

Returns:

A new slice ends earlier than those bytes.

​num_bytes (Int): The number of bytes to include.

unsafe_ptr(self: Self) -> UnsafePointer[SIMD[uint8, 1], 0]

Retrieves  a pointer to the underlying memory.

Prefer to use as_uint8_ptr() instead.

Returns:

The pointer to the underlying memory.

empty(self: Self) -> Bool

Returns True if the StringRef has length = 0.

Returns:

Whether the stringref is empty.

count(self: Self, substr: Self) -> Int

Return the number of non-overlapping occurrences of substring substr in the string.

If sub is empty, returns the number of empty strings between characters
which is the length of the string plus one.

Args:

Returns:

The number of occurrences of substr.

​substr (Self): The substring to count.

find(self: Self, substr: Self, start: Int = 0) -> Int

Finds the offset of the first occurrence of substr starting at start. If not found, returns -1.

Args:

Returns:

The offset of substr relative to the beginning of the string.

​substr (Self): The substring to find.
​start (Int): The offset from which to find.

rfind(self: Self, substr: Self, start: Int = 0) -> Int

Finds the offset of the last occurrence of substr starting at start. If not found, returns -1.

Args:

Returns:

The offset of substr relative to the beginning of the string.

​substr (Self): The substring to find.
​start (Int): The offset from which to find.

strip(self: Self) -> Self

Gets a StringRef with leading and trailing whitespaces removed. This only takes C spaces into account: " \t\n\r\f\v".

For example, "  mojo  " returns "mojo".

Returns:

A StringRef with leading and trailing whitespaces removed.

startswith(self: Self, prefix: Self, start: Int = 0, end: Int = -1) -> Bool

Checks if the StringRef starts with the specified prefix between start and end positions. Returns True if found and False otherwise.

Args:

Returns:

True if the self[start:end] is prefixed by the input prefix.

​prefix (Self): The prefix to check.
​start (Int): The start offset from which to check.
​end (Int): The end offset from which to check.

endswith(self: Self, suffix: Self, start: Int = 0, end: Int = -1) -> Bool

Checks if the StringRef end with the specified suffix between start and end positions. Returns True if found and False otherwise.

Args:

Returns:

True if the self[start:end] is suffixed by the input suffix.

​suffix (Self): The suffix to check.
​start (Int): The start offset from which to check.
​end (Int): The end offset from which to check.





url:https://docs.modular.com/mojo/stdlib/utils/variant/
module

variant





url:https://docs.modular.com/mojo/stdlib/utils/variant/Variant
struct

Variant

__init__(inout self: Self, *, unsafe_uninitialized: Tuple[])

Unsafely create an uninitialized Variant.

Args:

​unsafe_uninitialized (Tuple[]): Marker argument indicating this initializer is unsafe.

__init__(inout self: Self, *, unsafe_uninitialized: Tuple[])

Unsafely create an uninitialized Variant.

Args:

​unsafe_uninitialized (Tuple[]): Marker argument indicating this initializer is unsafe.

__init__(inout self: Self, *, unsafe_uninitialized: Tuple[])

Unsafely create an uninitialized Variant.

Args:

​unsafe_uninitialized (Tuple[]): Marker argument indicating this initializer is unsafe.

__copyinit__(inout self: Self, other: Self)

Creates a deep copy of an existing variant.

Args:

​other (Self): The variant to copy from.

__moveinit__(inout self: Self, owned other: Self)

Move initializer for the variant.

Args:

​other (Self): The variant to move.

__del__(owned self: Self)

Destroy the variant.

__getitem__[T: CollectionElement](self: Reference[Variant[Ts], is_mutable, lifetime, 0]) -> ref [$2] $0

Get the value out of the variant as a type-checked type.

This explicitly check that your value is of that type!
If you haven't verified the type correctness at runtime, the program
will abort!

For now this has the limitations that it
- requires the variant value to be mutable

Parameters:

Returns:

The internal data represented as a Reference[T].

​T (CollectionElement): The type of the value to get out.

take[T: CollectionElement](inout self: Self) -> $0

Take the current value of the variant with the provided type.

The caller takes ownership of the underlying value.

This explicitly check that your value is of that type!
If you haven't verified the type correctness at runtime, the program
will abort!

Parameters:

Returns:

The underlying data to be taken out as an owned value.

​T (CollectionElement): The type to take out.

unsafe_take[T: CollectionElement](inout self: Self) -> $0

Unsafely take the current value of the variant with the provided type.

The caller takes ownership of the underlying value.

This doesn't explicitly check that your value is of that type!
If you haven't verified the type correctness at runtime, you'll get
a type that looks like your type, but has potentially unsafe
and garbage member data.

Parameters:

Returns:

The underlying data to be taken out as an owned value.

​T (CollectionElement): The type to take out.

replace[Tin: CollectionElement, Tout: CollectionElement](inout self: Self, value: Tin) -> $1

Replace the current value of the variant with the provided type.

The caller takes ownership of the underlying value.

This explicitly check that your value is of that type!
If you haven't verified the type correctness at runtime, the program
will abort!

Parameters:

Args:

Returns:

The underlying data to be taken out as an owned value.

​Tin (CollectionElement): The type to put in.
​Tout (CollectionElement): The type to take out.

​value (Tin): The value to put in.

unsafe_replace[Tin: CollectionElement, Tout: CollectionElement](inout self: Self, value: Tin) -> $1

Unsafely replace the current value of the variant with the provided type.

The caller takes ownership of the underlying value.

This doesn't explicitly check that your value is of that type!
If you haven't verified the type correctness at runtime, you'll get
a type that looks like your type, but has potentially unsafe
and garbage member data.

Parameters:

Args:

Returns:

The underlying data to be taken out as an owned value.

​Tin (CollectionElement): The type to put in.
​Tout (CollectionElement): The type to take out.

​value (Tin): The value to put in.

set[T: CollectionElement](inout self: Self, owned value: T)

Set the variant value.

This will call the destructor on the old value, and update the variant's
internal type and data to the new value.

Parameters:

Args:

​T (CollectionElement): The new variant type. Must be one of the Variant's type arguments.

​value (T): The new value to set the variant to.

isa[T: CollectionElement](self: Self) -> Bool

Check if the variant contains the required type.

Parameters:

Returns:

True if the variant contains the requested type.

​T (CollectionElement): The type to check.

unsafe_get[T: CollectionElement](self: Reference[Variant[Ts], is_mutable, lifetime, 0]) -> Reference[$0, $1, $2, 0]

Get the value out of the variant as a type-checked type.

This doesn't explicitly check that your value is of that type!
If you haven't verified the type correctness at runtime, you'll get
a type that looks like your type, but has potentially unsafe
and garbage member data.

For now this has the limitations that it
- requires the variant value to be mutable

Parameters:

Returns:

The internal data represented as a Reference[T].

​T (CollectionElement): The type of the value to get out.



